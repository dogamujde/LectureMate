WEBVTT

00:00:05.040 --> 00:00:07.280
<v Speaker 0>We have Jillian Kraft.

NOTE CONF {"raw":[68,78,27,22]}

00:00:07.280 --> 00:00:08.240
<v Speaker 0>So you feel.

NOTE CONF {"raw":[37,55,36]}

00:00:14.160 --> 00:00:14.600
<v Speaker 1>So.

NOTE CONF {"raw":[94]}

00:00:14.600 --> 00:00:14.920
<v Speaker 1>Hi.

NOTE CONF {"raw":[98]}

00:00:14.920 --> 00:00:15.520
<v Speaker 1>Welcome.

NOTE CONF {"raw":[100]}

00:00:15.760 --> 00:00:19.480
<v Speaker 1>I'm really sorry for the delay, I'm afraid.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:00:20.760 --> 00:00:21.160
<v Speaker 1>No.

NOTE CONF {"raw":[100]}

00:00:21.160 --> 00:00:25.040
<v Speaker 1>Internet also means no lecture recording and no wool club.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,47,90]}

00:00:25.800 --> 00:00:28.600
<v Speaker 1>All right, so we'll just have the slides today.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:00:29.640 --> 00:00:31.680
<v Speaker 1>I think I'll make I can make an old lecture

NOTE CONF {"raw":[100,100,90,79,100,100,100,100,100,100]}

00:00:31.680 --> 00:00:32.759
<v Speaker 1>recording available.

NOTE CONF {"raw":[100,100]}

00:00:33.600 --> 00:00:35.600
<v Speaker 1>Uh, just taking the one from last year.

NOTE CONF {"raw":[78,100,100,100,100,100,100,100]}

00:00:36.720 --> 00:00:37.280
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:00:37.280 --> 00:00:40.360
<v Speaker 1>So today is about, uh, the perceptron.

NOTE CONF {"raw":[100,100,100,100,91,100,100]}

00:00:40.360 --> 00:00:41.720
<v Speaker 1>So what is the perceptron?

NOTE CONF {"raw":[100,100,100,100,100]}

00:00:41.760 --> 00:00:44.520
<v Speaker 1>It's a very simple neural network architecture.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:00:44.920 --> 00:00:49.240
<v Speaker 1>So so far we've only talked about, um, cognitive models

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,100,100]}

00:00:49.240 --> 00:00:53.400
<v Speaker 1>in an abstract sense as something that's a computational simulation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:53.400 --> 00:00:57.240
<v Speaker 1>of, of human behaviour and is something that helps you

NOTE CONF {"raw":[100,100,100,93,100,83,100,100,100,100]}

00:00:57.600 --> 00:01:01.900
<v Speaker 1>understand that behaviour and hopefully generate research hypotheses or test

NOTE CONF {"raw":[100,100,96,100,100,100,100,100,100,100]}

00:01:01.900 --> 00:01:03.020
<v Speaker 1>research hypotheses.

NOTE CONF {"raw":[100,100]}

00:01:03.460 --> 00:01:06.620
<v Speaker 1>Now we're actually going to get down to the nitty

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:06.620 --> 00:01:11.140
<v Speaker 1>gritty and talk about a particular modelling framework in in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:11.180 --> 00:01:11.900
<v Speaker 1>more detail.

NOTE CONF {"raw":[100,100]}

00:01:11.900 --> 00:01:13.260
<v Speaker 1>And this is neural networks.

NOTE CONF {"raw":[100,100,100,100,100]}

00:01:15.580 --> 00:01:20.660
<v Speaker 1>We'll start really simple with the simplest possible architectures called

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:20.660 --> 00:01:23.780
<v Speaker 1>the perceptron which is essentially just modelling a single neurone.

NOTE CONF {"raw":[100,100,100,96,100,100,99,100,100,100]}

00:01:24.820 --> 00:01:30.780
<v Speaker 1>And then tomorrow we'll we'll look at larger assemblies of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:30.780 --> 00:01:34.740
<v Speaker 1>these neurones in something that's called a multi-layer perceptron.

NOTE CONF {"raw":[100,100,100,100,100,100,100,69,100]}

00:01:35.020 --> 00:01:37.700
<v Speaker 1>And in particular we're also going to talk about training.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:37.700 --> 00:01:42.700
<v Speaker 1>How do we actually get these models to learn anything

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:43.780 --> 00:01:44.980
<v Speaker 1>from from data.

NOTE CONF {"raw":[100,100,100]}

00:01:45.020 --> 00:01:45.460
<v Speaker 1>Right.

NOTE CONF {"raw":[90]}

00:01:45.900 --> 00:01:49.940
<v Speaker 1>Last time we talked about radical empiricism as a way

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:49.940 --> 00:01:50.980
<v Speaker 1>of of modelling.

NOTE CONF {"raw":[100,100,100]}

00:01:51.460 --> 00:01:53.340
<v Speaker 1>Everything is learning from data.

NOTE CONF {"raw":[100,100,100,100,100]}

00:01:53.500 --> 00:01:55.780
<v Speaker 1>And so these are the models that actually are able

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:55.780 --> 00:01:56.380
<v Speaker 1>to do that.

NOTE CONF {"raw":[100,100,100]}

00:01:58.010 --> 00:01:58.690
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:01:59.010 --> 00:02:00.650
<v Speaker 1>Um, so quick overview.

NOTE CONF {"raw":[64,100,100,100]}

00:02:01.530 --> 00:02:05.090
<v Speaker 1>Uh, talk about neural networks as a biological, not a

NOTE CONF {"raw":[57,100,100,100,100,100,100,100,100,100]}

00:02:05.090 --> 00:02:05.850
<v Speaker 1>biological model.

NOTE CONF {"raw":[100,100]}

00:02:05.850 --> 00:02:06.850
<v Speaker 1>More like a metaphor.

NOTE CONF {"raw":[100,100,100,100]}

00:02:07.170 --> 00:02:12.130
<v Speaker 1>Then I'll talk about the perceptron and how they can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:12.130 --> 00:02:13.530
<v Speaker 1>use as classifiers.

NOTE CONF {"raw":[100,100,100]}

00:02:13.970 --> 00:02:15.370
<v Speaker 1>And then we'll talk about learning.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:02:15.370 --> 00:02:18.010
<v Speaker 1>And in particular, the perceptron learning rule probably will run

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:18.010 --> 00:02:20.490
<v Speaker 1>out of time because we started late.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:21.570 --> 00:02:22.050
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:02:22.050 --> 00:02:26.930
<v Speaker 1>So if you think about a neurone then it has

NOTE CONF {"raw":[100,100,100,100,100,100,100,75,100,100]}

00:02:26.930 --> 00:02:29.890
<v Speaker 1>roughly this is obviously just a caricature, but it has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:29.890 --> 00:02:30.810
<v Speaker 1>roughly the structure.

NOTE CONF {"raw":[100,91,100]}

00:02:30.810 --> 00:02:33.690
<v Speaker 1>You have a neurone here with the nucleus and the

NOTE CONF {"raw":[100,100,100,100,100,100,89,100,100,100]}

00:02:33.690 --> 00:02:34.410
<v Speaker 1>cell body.

NOTE CONF {"raw":[100,100]}

00:02:34.890 --> 00:02:38.250
<v Speaker 1>Then you have dendrites which are connections to other neurones.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:38.330 --> 00:02:40.330
<v Speaker 1>And this is where the neurone gets its input.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:40.890 --> 00:02:45.890
<v Speaker 1>And you have an axon, uh, which is where the

NOTE CONF {"raw":[100,100,100,100,100,69,100,100,100,100]}

00:02:45.890 --> 00:02:47.890
<v Speaker 1>neurone is connected to other neurones.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:02:48.330 --> 00:02:52.490
<v Speaker 1>And at the axon terminal it potentially generates an output.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:52.570 --> 00:02:56.130
<v Speaker 1>So input output in our model will just be numbers

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:56.550 --> 00:03:00.990
<v Speaker 1>In in biology, they're electrical currents and they're generated through

NOTE CONF {"raw":[94,100,100,100,100,100,100,100,100,100]}

00:03:01.030 --> 00:03:02.110
<v Speaker 1>electrochemistry.

NOTE CONF {"raw":[100]}

00:03:03.110 --> 00:03:03.350
<v Speaker 1>Right.

NOTE CONF {"raw":[97]}

00:03:03.390 --> 00:03:05.630
<v Speaker 1>And then there's a lot of other parts like the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:05.630 --> 00:03:09.150
<v Speaker 1>Schwann cells and node of Ranvier and so on.

NOTE CONF {"raw":[100,100,100,44,42,100,100,100,100]}

00:03:10.990 --> 00:03:14.110
<v Speaker 1>The actual biological neurone is a lot more complicated still.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:14.550 --> 00:03:17.270
<v Speaker 1>And we're not even going to model all of these

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:17.270 --> 00:03:18.550
<v Speaker 1>things on the picture.

NOTE CONF {"raw":[100,100,100,100]}

00:03:18.590 --> 00:03:18.750
<v Speaker 1>Right?

NOTE CONF {"raw":[95]}

00:03:18.790 --> 00:03:21.190
<v Speaker 1>So that's what I meant when I said, this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:21.190 --> 00:03:22.990
<v Speaker 1>not a model of a biological neurone.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:03:22.990 --> 00:03:25.750
<v Speaker 1>This is really a computational device that uses a neurone

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:25.750 --> 00:03:29.430
<v Speaker 1>as a metaphor and has a loose relationship to it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:30.790 --> 00:03:33.510
<v Speaker 1>But the important thing to note is that the neurone

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:33.510 --> 00:03:37.550
<v Speaker 1>takes an input, it combines those, and once the input

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:37.550 --> 00:03:40.270
<v Speaker 1>reaches a certain threshold, it produces an output.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:03:40.270 --> 00:03:45.430
<v Speaker 1>It fires and the inputs can be excitatory.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:03:45.790 --> 00:03:49.910
<v Speaker 1>So increase the output or inhibitory i.e. they reduce the

NOTE CONF {"raw":[100,100,100,100,100,100,89,94,100,100]}

00:03:49.910 --> 00:03:50.470
<v Speaker 1>output.

NOTE CONF {"raw":[100]}

00:03:51.710 --> 00:03:56.130
<v Speaker 1>And the important thing is what happens when the axons

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:56.130 --> 00:03:59.010
<v Speaker 1>and the dendrites connect between two neurones?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:03:59.050 --> 00:03:59.290
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:03:59.330 --> 00:04:02.010
<v Speaker 1>So the dendrite is the input and the axon is

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:04:02.010 --> 00:04:02.570
<v Speaker 1>the output.

NOTE CONF {"raw":[100,100]}

00:04:03.810 --> 00:04:05.410
<v Speaker 1>We have a so-called synapse.

NOTE CONF {"raw":[100,100,100,100,100]}

00:04:05.850 --> 00:04:08.330
<v Speaker 1>And the synapse basically regulates the firing.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:08.730 --> 00:04:09.010
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:04:09.050 --> 00:04:14.170
<v Speaker 1>So it waits until a certain amount of input has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:14.170 --> 00:04:16.329
<v Speaker 1>arrived and then it generates an output.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:16.609 --> 00:04:17.769
<v Speaker 1>And this is called firing.

NOTE CONF {"raw":[100,100,100,100,100]}

00:04:17.769 --> 00:04:21.730
<v Speaker 1>And this is in biological terms there's a chemical process.

NOTE CONF {"raw":[100,100,100,100,100,100,95,92,100,100]}

00:04:21.930 --> 00:04:25.650
<v Speaker 1>But here we'll just model it using a function which

NOTE CONF {"raw":[100,100,99,100,100,100,100,100,100,100]}

00:04:25.650 --> 00:04:29.730
<v Speaker 1>we'll call a threshold function or an output function activation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:29.730 --> 00:04:30.810
<v Speaker 1>function sometimes.

NOTE CONF {"raw":[100,100]}

00:04:31.530 --> 00:04:34.370
<v Speaker 1>So that is the only biology in my part of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:34.370 --> 00:04:34.930
<v Speaker 1>the course.

NOTE CONF {"raw":[100,100]}

00:04:35.210 --> 00:04:37.210
<v Speaker 1>Matthias will have a lot more to say in his

NOTE CONF {"raw":[68,100,100,100,100,100,100,100,100,100]}

00:04:37.210 --> 00:04:37.610
<v Speaker 1>part.

NOTE CONF {"raw":[100]}

00:04:37.930 --> 00:04:40.810
<v Speaker 1>But here we're just using the neurone as a metaphor.

NOTE CONF {"raw":[100,100,95,100,100,100,100,100,100,100]}

00:04:40.890 --> 00:04:45.090
<v Speaker 1>So taking the inputs and here introducing a little bit

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,100]}

00:04:45.090 --> 00:04:49.490
<v Speaker 1>of notation already, let's call the inputs x1, x2, x3

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:49.490 --> 00:04:50.090
<v Speaker 1>and so on.

NOTE CONF {"raw":[100,100,100]}

00:04:50.450 --> 00:04:53.920
<v Speaker 1>And as I said these are numbers real numbers in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:53.920 --> 00:04:58.440
<v Speaker 1>the journal case and then the strength of the connection.

NOTE CONF {"raw":[100,77,100,100,100,100,100,100,100,100]}

00:04:58.440 --> 00:05:01.280
<v Speaker 1>So the the synapses at the input.

NOTE CONF {"raw":[100,100,100,72,100,100,100]}

00:05:02.080 --> 00:05:05.280
<v Speaker 1>Here at the dendrites we will call these weights.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:05.840 --> 00:05:09.600
<v Speaker 1>And each input comes with a weight w1, w2, w3

NOTE CONF {"raw":[100,100,100,100,100,52,100,100,100,100]}

00:05:09.600 --> 00:05:10.120
<v Speaker 1>and so on.

NOTE CONF {"raw":[100,100,100]}

00:05:10.720 --> 00:05:14.520
<v Speaker 1>And then what the neurone does it computes an output

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:14.520 --> 00:05:18.200
<v Speaker 1>function, which in our case is just a weighted sum.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:18.800 --> 00:05:23.440
<v Speaker 1>And then what the synapse does, it decides to either

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:23.440 --> 00:05:24.240
<v Speaker 1>fire or not.

NOTE CONF {"raw":[100,100,100]}

00:05:24.440 --> 00:05:27.280
<v Speaker 1>And this will just model through a simple threshold function.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:29.560 --> 00:05:31.920
<v Speaker 1>So this is just a single neurone.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:31.920 --> 00:05:33.760
<v Speaker 1>And a single neurone is not very powerful.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:33.760 --> 00:05:37.600
<v Speaker 1>There's not that much we can do, but they're the

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,43,100]}

00:05:37.600 --> 00:05:41.560
<v Speaker 1>basic units of information processing that we'll assume.

NOTE CONF {"raw":[100,100,100,100,100,100,78,100]}

00:05:42.120 --> 00:05:45.240
<v Speaker 1>And if we want to be precise in computational terms,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:45.240 --> 00:05:46.320
<v Speaker 1>we'll talk about units.

NOTE CONF {"raw":[100,100,100,100]}

00:05:46.320 --> 00:05:48.880
<v Speaker 1>We don't talk about neurones because they're not neurones.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:48.880 --> 00:05:52.540
<v Speaker 1>They're not even proper models of neurones Even though people

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:05:52.580 --> 00:05:54.820
<v Speaker 1>often confused or conflate the two.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:05:54.940 --> 00:05:58.300
<v Speaker 1>So in the neural network literature, as the name implies,

NOTE CONF {"raw":[100,100,100,100,100,100,48,100,100,100]}

00:05:58.540 --> 00:06:01.860
<v Speaker 1>people talk about neurones, but in fact they're just simple

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:01.860 --> 00:06:03.740
<v Speaker 1>computational units.

NOTE CONF {"raw":[91,100]}

00:06:04.780 --> 00:06:09.700
<v Speaker 1>And in biological networks, in the cortex, for example, these

NOTE CONF {"raw":[100,100,100,100,84,100,100,100,100,100]}

00:06:09.820 --> 00:06:12.900
<v Speaker 1>neurones, they're organised in terms of layers.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:14.340 --> 00:06:17.940
<v Speaker 1>So they're not just randomly distributed but they're organised in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:17.940 --> 00:06:21.380
<v Speaker 1>a certain way, uh, typically in terms of layers.

NOTE CONF {"raw":[100,100,100,49,100,100,100,100,100]}

00:06:21.500 --> 00:06:23.860
<v Speaker 1>And this is something that we can model as well

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:23.860 --> 00:06:26.700
<v Speaker 1>in our artificial neural networks.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:28.060 --> 00:06:29.700
<v Speaker 1>But something is still missing, right.

NOTE CONF {"raw":[100,100,100,100,100,81]}

00:06:29.740 --> 00:06:32.100
<v Speaker 1>So we have these units and that's all great.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:06:32.100 --> 00:06:35.820
<v Speaker 1>But of course we need connections as well to get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:35.820 --> 00:06:36.260
<v Speaker 1>a network.

NOTE CONF {"raw":[100,100]}

00:06:36.300 --> 00:06:38.380
<v Speaker 1>At this point this is just a bunch of nodes.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:39.220 --> 00:06:42.980
<v Speaker 1>So we're interested in the connections and in the neural

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:42.980 --> 00:06:46.140
<v Speaker 1>network literature, in almost all cases we assume what's called

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:46.140 --> 00:06:47.460
<v Speaker 1>a fully connected network.

NOTE CONF {"raw":[98,100,100,100]}

00:06:47.860 --> 00:06:50.920
<v Speaker 1>So we have a single unit here let's say in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:50.920 --> 00:06:51.480
<v Speaker 1>layer two.

NOTE CONF {"raw":[100,100]}

00:06:51.720 --> 00:06:54.480
<v Speaker 1>And this is connected to all the units in layer

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:54.480 --> 00:06:56.400
<v Speaker 1>three and in layer one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:56.960 --> 00:06:57.160
<v Speaker 1>Right.

NOTE CONF {"raw":[69]}

00:06:57.200 --> 00:07:00.160
<v Speaker 1>So this is a feed forward network in the sense

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:00.160 --> 00:07:02.720
<v Speaker 1>that the connections are only in one direction from top

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:02.720 --> 00:07:04.920
<v Speaker 1>to bottom, layer one to layer two, from layer two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:04.960 --> 00:07:05.640
<v Speaker 1>to layer three.

NOTE CONF {"raw":[100,100,100]}

00:07:06.160 --> 00:07:10.840
<v Speaker 1>And it's fully connected in that all these units in

NOTE CONF {"raw":[100,93,100,100,100,100,100,100,100,100]}

00:07:10.840 --> 00:07:13.000
<v Speaker 1>this layer are connected to all those units in that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:13.000 --> 00:07:13.320
<v Speaker 1>layer.

NOTE CONF {"raw":[100]}

00:07:13.400 --> 00:07:17.040
<v Speaker 1>So here I'm just drawing the connections of a single

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:17.040 --> 00:07:17.480
<v Speaker 1>unit.

NOTE CONF {"raw":[100]}

00:07:17.880 --> 00:07:21.240
<v Speaker 1>But in in in the general case there's lots of

NOTE CONF {"raw":[100,88,100,100,100,100,100,100,100,100]}

00:07:21.240 --> 00:07:24.080
<v Speaker 1>units because we're lots of connections because we're assuming it's

NOTE CONF {"raw":[100,100,44,100,100,100,100,98,99,100]}

00:07:24.080 --> 00:07:24.920
<v Speaker 1>fully connected.

NOTE CONF {"raw":[100,100]}

00:07:25.800 --> 00:07:28.560
<v Speaker 1>And these are often just represented as lines.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:07:28.680 --> 00:07:32.600
<v Speaker 1>So the units are represented as little circles and the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:32.600 --> 00:07:35.480
<v Speaker 1>connections are the lines.

NOTE CONF {"raw":[100,100,100,100]}

00:07:35.600 --> 00:07:37.280
<v Speaker 1>Why are the connections important.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:37.560 --> 00:07:39.720
<v Speaker 1>Because they are associated with weights.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:39.960 --> 00:07:42.920
<v Speaker 1>And the weights are things that we can actually adjust.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:42.960 --> 00:07:44.880
<v Speaker 1>They're essentially the parameters of the model.

NOTE CONF {"raw":[90,100,100,100,100,100,100]}

00:07:45.880 --> 00:07:50.150
<v Speaker 1>We can learn the weights and all the knowledge in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:50.150 --> 00:07:52.230
<v Speaker 1>some sense is in the weights, because that's the only

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:52.230 --> 00:07:54.390
<v Speaker 1>thing that's learned in the network, right?

NOTE CONF {"raw":[100,100,97,100,100,100,100]}

00:07:54.430 --> 00:07:56.830
<v Speaker 1>So these arrows, they symbolise the connections.

NOTE CONF {"raw":[100,100,90,100,94,100,100]}

00:07:56.830 --> 00:08:00.350
<v Speaker 1>And each connection is associated with a weight with the

NOTE CONF {"raw":[100,100,100,100,100,100,60,100,100,94]}

00:08:00.350 --> 00:08:00.870
<v Speaker 1>number.

NOTE CONF {"raw":[100]}

00:08:02.470 --> 00:08:02.910
<v Speaker 1>Okay.

NOTE CONF {"raw":[71]}

00:08:03.030 --> 00:08:05.750
<v Speaker 1>But let's go back to the simple case of a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:05.750 --> 00:08:06.550
<v Speaker 1>single unit.

NOTE CONF {"raw":[100,100]}

00:08:08.350 --> 00:08:11.790
<v Speaker 1>So this idea of having a simple computational unit called

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:11.790 --> 00:08:14.070
<v Speaker 1>the perceptron is actually quite old, goes back to the

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100,100]}

00:08:14.070 --> 00:08:14.670
<v Speaker 1>50s.

NOTE CONF {"raw":[100]}

00:08:15.910 --> 00:08:18.750
<v Speaker 1>And it's the simplest kind of artificial neural network.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:08:18.830 --> 00:08:23.590
<v Speaker 1>And people realised quite early on in, in the 60s

NOTE CONF {"raw":[100,100,73,100,100,100,85,100,100,100]}

00:08:23.870 --> 00:08:25.630
<v Speaker 1>that it's quite limited.

NOTE CONF {"raw":[100,100,100,100]}

00:08:25.630 --> 00:08:27.150
<v Speaker 1>And there's a lot of things you can't do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:08:27.470 --> 00:08:30.710
<v Speaker 1>And we'll talk about that in more detail later in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:30.710 --> 00:08:31.390
<v Speaker 1>the lecture.

NOTE CONF {"raw":[100,100]}

00:08:32.229 --> 00:08:32.469
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:32.510 --> 00:08:36.590
<v Speaker 1>So this is the, the, the kind of diagram that

NOTE CONF {"raw":[100,100,100,83,92,100,100,100,100,100]}

00:08:36.590 --> 00:08:39.789
<v Speaker 1>we'll see also, for example, in the tutorial next week.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:40.270 --> 00:08:42.190
<v Speaker 1>And this is how to read this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:08:42.310 --> 00:08:44.350
<v Speaker 1>So we have our inputs here x.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:08:44.990 --> 00:08:48.090
<v Speaker 1>The inputs we just assume our numbers.

NOTE CONF {"raw":[100,100,100,100,98,55,100]}

00:08:48.570 --> 00:08:52.050
<v Speaker 1>And that also means that whatever we want to input,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:52.650 --> 00:08:56.930
<v Speaker 1>be it text, images, sounds, any sort of perception that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:56.930 --> 00:09:00.770
<v Speaker 1>goes into the network has to be numbers, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97]}

00:09:00.810 --> 00:09:02.850
<v Speaker 1>So everything is a vector.

NOTE CONF {"raw":[100,100,100,100,100]}

00:09:03.930 --> 00:09:06.410
<v Speaker 1>Um, images are represented as vectors.

NOTE CONF {"raw":[71,100,100,100,100,100]}

00:09:06.970 --> 00:09:12.810
<v Speaker 1>Words are represented as vectors through uh, specific encodings called

NOTE CONF {"raw":[100,100,100,100,100,100,80,100,100,100]}

00:09:12.810 --> 00:09:15.090
<v Speaker 1>embeddings that we'll talk about later.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:15.890 --> 00:09:17.810
<v Speaker 1>Uh, if you have audio input and so on and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:17.810 --> 00:09:18.130
<v Speaker 1>so forth.

NOTE CONF {"raw":[100,100]}

00:09:18.170 --> 00:09:22.850
<v Speaker 1>Everything needs to be input as a sequence of numbers

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:23.250 --> 00:09:24.490
<v Speaker 1>x1 to xn.

NOTE CONF {"raw":[100,100,100]}

00:09:26.370 --> 00:09:28.810
<v Speaker 1>And then each of these inputs is associated with a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,88]}

00:09:28.810 --> 00:09:29.170
<v Speaker 1>weight.

NOTE CONF {"raw":[100]}

00:09:29.770 --> 00:09:33.250
<v Speaker 1>As I said these are representing the synapses.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:09:33.810 --> 00:09:37.050
<v Speaker 1>And the weight basically dictates how important that part of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:37.050 --> 00:09:37.850
<v Speaker 1>the input is.

NOTE CONF {"raw":[100,100,100]}

00:09:38.570 --> 00:09:38.810
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:38.850 --> 00:09:41.330
<v Speaker 1>The weights again can be real numbers.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:09:42.610 --> 00:09:47.510
<v Speaker 1>Um, and then here in the quote unquote cell body.

NOTE CONF {"raw":[84,100,100,100,100,100,100,100,99,100]}

00:09:48.670 --> 00:09:50.510
<v Speaker 1>You have an output function.

NOTE CONF {"raw":[100,100,100,100,100]}

00:09:50.590 --> 00:09:52.670
<v Speaker 1>And this is what this little sigma is supposed to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:52.670 --> 00:09:53.310
<v Speaker 1>represent.

NOTE CONF {"raw":[100]}

00:09:53.670 --> 00:09:58.910
<v Speaker 1>So the output function for us is sorry input from

NOTE CONF {"raw":[100,100,100,100,100,100,100,99,96,35]}

00:09:59.030 --> 00:10:00.070
<v Speaker 1>the input function.

NOTE CONF {"raw":[58,100,100]}

00:10:00.070 --> 00:10:00.470
<v Speaker 1>Sorry.

NOTE CONF {"raw":[89]}

00:10:00.510 --> 00:10:03.030
<v Speaker 1>The input function is just a weighted sum.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:03.030 --> 00:10:04.430
<v Speaker 1>So we call this function mu.

NOTE CONF {"raw":[100,100,100,100,100,69]}

00:10:05.110 --> 00:10:06.310
<v Speaker 1>It applies to x.

NOTE CONF {"raw":[100,100,100,100]}

00:10:06.390 --> 00:10:08.190
<v Speaker 1>So these are all the x's here in the input.

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:10:08.550 --> 00:10:10.830
<v Speaker 1>And it just computes computes the weighted sum.

NOTE CONF {"raw":[100,100,100,76,100,100,100,100]}

00:10:10.830 --> 00:10:13.710
<v Speaker 1>So that is the product of y and x I.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,70,65]}

00:10:14.030 --> 00:10:17.870
<v Speaker 1>So a given input and a given weight summed over

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:17.870 --> 00:10:18.670
<v Speaker 1>all the inputs.

NOTE CONF {"raw":[100,100,100]}

00:10:19.830 --> 00:10:20.390
<v Speaker 1>That's it.

NOTE CONF {"raw":[100,100]}

00:10:20.390 --> 00:10:23.030
<v Speaker 1>So we're just assuming that all the inputs get added

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:23.030 --> 00:10:23.310
<v Speaker 1>up.

NOTE CONF {"raw":[100]}

00:10:25.830 --> 00:10:29.350
<v Speaker 1>And then we decide whether to fire whether to produce

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:29.350 --> 00:10:32.470
<v Speaker 1>an output or not using an activation function.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:32.470 --> 00:10:36.110
<v Speaker 1>So activation function which I'm writing as f here applies

NOTE CONF {"raw":[100,100,100,100,100,100,84,100,100,100]}

00:10:36.110 --> 00:10:37.150
<v Speaker 1>to the input function.

NOTE CONF {"raw":[100,100,100,100]}

00:10:37.190 --> 00:10:37.390
<v Speaker 1>Right.

NOTE CONF {"raw":[60]}

00:10:37.390 --> 00:10:38.750
<v Speaker 1>So this is our input function.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:39.110 --> 00:10:43.900
<v Speaker 1>And this is the activation function applies to the Uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,74]}

00:10:43.940 --> 00:10:45.820
<v Speaker 1>to the result of the input function.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:46.060 --> 00:10:48.700
<v Speaker 1>And then in this case, it just returns a one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:49.300 --> 00:10:54.260
<v Speaker 1>If the input is bigger than a threshold theta or

NOTE CONF {"raw":[100,100,100,100,100,100,94,100,100,100]}

00:10:54.420 --> 00:10:56.100
<v Speaker 1>zero in all other cases.

NOTE CONF {"raw":[100,100,100,100,100]}

00:10:56.700 --> 00:10:57.100
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:10:57.100 --> 00:10:59.540
<v Speaker 1>So this is just a simple threshold function.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:59.540 --> 00:11:00.380
<v Speaker 1>Step function.

NOTE CONF {"raw":[100,100]}

00:11:00.740 --> 00:11:00.980
<v Speaker 1>Right.

NOTE CONF {"raw":[93]}

00:11:01.020 --> 00:11:01.900
<v Speaker 1>If you draw it.

NOTE CONF {"raw":[100,100,100,100]}

00:11:01.900 --> 00:11:04.940
<v Speaker 1>And of course in this room there is no whiteboard.

NOTE CONF {"raw":[100,100,100,100,100,100,88,88,100,100]}

00:11:05.660 --> 00:11:07.980
<v Speaker 1>If you draw it it just looks like this right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,94]}

00:11:08.020 --> 00:11:13.100
<v Speaker 1>And we'll see other functions later on in the next

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:13.100 --> 00:11:13.940
<v Speaker 1>lecture actually.

NOTE CONF {"raw":[100,100]}

00:11:13.940 --> 00:11:17.140
<v Speaker 1>But here we just assume you take the inputs, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:17.180 --> 00:11:18.100
<v Speaker 1>sum them all up.

NOTE CONF {"raw":[100,100,100,100]}

00:11:18.420 --> 00:11:20.660
<v Speaker 1>If you reach a certain threshold then you produce an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:20.660 --> 00:11:21.100
<v Speaker 1>output.

NOTE CONF {"raw":[100]}

00:11:21.220 --> 00:11:23.660
<v Speaker 1>If they don't reach the threshold then you stay at

NOTE CONF {"raw":[100,100,100,100,64,100,100,100,100,100]}

00:11:23.660 --> 00:11:24.020
<v Speaker 1>zero.

NOTE CONF {"raw":[100]}

00:11:24.140 --> 00:11:27.500
<v Speaker 1>You basically produce no output okay.

NOTE CONF {"raw":[100,100,100,100,100,89]}

00:11:27.540 --> 00:11:33.060
<v Speaker 1>So this is super simple and not very powerful computationally

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:33.060 --> 00:11:33.860
<v Speaker 1>on its own.

NOTE CONF {"raw":[100,100,100]}

00:11:34.180 --> 00:11:38.060
<v Speaker 1>But if you combine lots of these units, then you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:38.060 --> 00:11:44.120
<v Speaker 1>can actually, um, you can Do everything that neural networks

NOTE CONF {"raw":[100,100,89,100,100,100,100,100,100,100]}

00:11:44.120 --> 00:11:44.560
<v Speaker 1>can do.

NOTE CONF {"raw":[100,100]}

00:11:45.520 --> 00:11:52.040
<v Speaker 1>So everything from ChatGPT to machine translation, image recognition, speech

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:11:52.040 --> 00:11:53.120
<v Speaker 1>to text and so on.

NOTE CONF {"raw":[100,100,100,100,100]}

00:11:53.640 --> 00:11:57.920
<v Speaker 1>This is the technology essentially behind all of these, behind

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:11:57.920 --> 00:11:59.160
<v Speaker 1>all of these applications.

NOTE CONF {"raw":[100,100,100,100]}

00:12:01.240 --> 00:12:03.280
<v Speaker 1>Organised in slightly more complicated ways.

NOTE CONF {"raw":[94,100,100,100,100,100]}

00:12:03.760 --> 00:12:05.560
<v Speaker 1>But the underlying idea is the same.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:05.720 --> 00:12:09.200
<v Speaker 1>Even the learning algorithm that we'll learn, that we'll talk

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:09.200 --> 00:12:13.560
<v Speaker 1>about tomorrow is the same for modern neural networks.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:15.080 --> 00:12:15.840
<v Speaker 1>Okay, great.

NOTE CONF {"raw":[100,100]}

00:12:15.840 --> 00:12:18.000
<v Speaker 1>So, uh, yeah.

NOTE CONF {"raw":[99,79,94]}

00:12:18.040 --> 00:12:21.720
<v Speaker 1>And here the activation, the output is very simple.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:21.720 --> 00:12:23.400
<v Speaker 1>It's just zero one.

NOTE CONF {"raw":[99,100,100,93]}

00:12:23.560 --> 00:12:25.600
<v Speaker 1>You can of course define another function here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:12:25.840 --> 00:12:28.760
<v Speaker 1>You could generate a negative output if you're below the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:28.760 --> 00:12:29.920
<v Speaker 1>threshold and so on.

NOTE CONF {"raw":[100,100,100,100]}

00:12:30.240 --> 00:12:32.720
<v Speaker 1>This is completely up to the to the design of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,57,100]}

00:12:32.760 --> 00:12:35.720
<v Speaker 1>the of the network inputs.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:35.720 --> 00:12:38.640
<v Speaker 1>As I've already mentioned in the here, we're assuming that

NOTE CONF {"raw":[100,100,100,100,90,56,100,98,100,100]}

00:12:38.640 --> 00:12:40.360
<v Speaker 1>in the in the range zero and one.

NOTE CONF {"raw":[98,94,100,100,100,100,100,100]}

00:12:40.500 --> 00:12:43.940
<v Speaker 1>So we're assuming a super simple case where everything is

NOTE CONF {"raw":[100,75,100,100,100,100,100,100,100,100]}

00:12:43.940 --> 00:12:44.500
<v Speaker 1>binary.

NOTE CONF {"raw":[100]}

00:12:44.700 --> 00:12:46.900
<v Speaker 1>All the inputs are binary, the outputs are binary.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:47.060 --> 00:12:49.540
<v Speaker 1>The weights can be an arbitrary real number.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:12:50.020 --> 00:12:53.700
<v Speaker 1>But just to make things easier and also to be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:53.700 --> 00:12:57.340
<v Speaker 1>able to compute some simple examples, I'm just assuming that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:57.340 --> 00:12:59.260
<v Speaker 1>the inputs are ones and zeros and the outputs are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:59.260 --> 00:13:00.100
<v Speaker 1>ones and zeros.

NOTE CONF {"raw":[100,100,100]}

00:13:00.780 --> 00:13:02.580
<v Speaker 1>This is not a necessary assumption.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:13:02.780 --> 00:13:04.300
<v Speaker 1>We don't have to make that assumption.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:04.300 --> 00:13:05.420
<v Speaker 1>It's just for simplicity.

NOTE CONF {"raw":[100,100,100,100]}

00:13:05.460 --> 00:13:08.060
<v Speaker 1>Now okay.

NOTE CONF {"raw":[100,100]}

00:13:08.100 --> 00:13:09.500
<v Speaker 1>So what can we do with this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:09.500 --> 00:13:12.460
<v Speaker 1>So let's actually work through a simple example.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:13.340 --> 00:13:14.700
<v Speaker 1>This is our perceptron.

NOTE CONF {"raw":[100,100,100,100]}

00:13:15.340 --> 00:13:18.820
<v Speaker 1>Same as here I'm assuming we only have two inputs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:19.060 --> 00:13:21.580
<v Speaker 1>And each of them have a weight of 0.5.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,50]}

00:13:21.860 --> 00:13:23.540
<v Speaker 1>And we have a threshold of one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:24.300 --> 00:13:26.820
<v Speaker 1>And now we want to show that this perceptron can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:26.820 --> 00:13:28.820
<v Speaker 1>compute simple logical functions.

NOTE CONF {"raw":[100,100,100,100]}

00:13:29.100 --> 00:13:34.420
<v Speaker 1>So logical functions in computer science are functions that take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:34.420 --> 00:13:35.180
<v Speaker 1>two inputs.

NOTE CONF {"raw":[100,100]}

00:13:35.460 --> 00:13:37.580
<v Speaker 1>The inputs are binary and the output is binary.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:13:37.580 --> 00:13:41.730
<v Speaker 1>So and for example, is a function that returns true,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:41.730 --> 00:13:44.570
<v Speaker 1>or one if both of the inputs are true, or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:44.570 --> 00:13:48.490
<v Speaker 1>one or is a function that returns true if one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:48.490 --> 00:13:50.330
<v Speaker 1>of the inputs is true, and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:50.690 --> 00:13:53.610
<v Speaker 1>So any programming language will have these functions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:53.970 --> 00:13:56.850
<v Speaker 1>So here this is our function table for the and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,93]}

00:13:57.250 --> 00:14:01.770
<v Speaker 1>we have two inputs and zero and zero output is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:01.770 --> 00:14:05.250
<v Speaker 1>zero zero and one output is also zero one and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:05.250 --> 00:14:06.170
<v Speaker 1>zero zero.

NOTE CONF {"raw":[100,100]}

00:14:06.170 --> 00:14:08.290
<v Speaker 1>And one and one output is one right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,80]}

00:14:08.330 --> 00:14:11.130
<v Speaker 1>So this function returns a one if and only the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:11.130 --> 00:14:12.210
<v Speaker 1>inputs are both one.

NOTE CONF {"raw":[100,100,100,100]}

00:14:12.970 --> 00:14:14.290
<v Speaker 1>Very simple logical function.

NOTE CONF {"raw":[100,100,100,100]}

00:14:14.290 --> 00:14:16.490
<v Speaker 1>And it would be really cute to be able to

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:14:16.530 --> 00:14:22.410
<v Speaker 1>show that this perceptron that we've just introduced is able

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:22.410 --> 00:14:23.530
<v Speaker 1>to model this function.

NOTE CONF {"raw":[100,100,100,100]}

00:14:23.810 --> 00:14:25.370
<v Speaker 1>So let's see if that's the case.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:14:25.450 --> 00:14:28.450
<v Speaker 1>And obviously I have given you the weights and I've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:28.450 --> 00:14:29.650
<v Speaker 1>given you the threshold.

NOTE CONF {"raw":[100,100,100,100]}

00:14:30.810 --> 00:14:34.050
<v Speaker 1>It's a very interesting question of how we get the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:34.050 --> 00:14:35.290
<v Speaker 1>threshold and the weights.

NOTE CONF {"raw":[100,100,100,100]}

00:14:35.850 --> 00:14:37.590
<v Speaker 1>And this is something we'll come to in the second

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:37.590 --> 00:14:39.150
<v Speaker 1>half of the of the lecture.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:14:39.870 --> 00:14:40.390
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:42.230 --> 00:14:46.870
<v Speaker 1>So if our input is bigger than the threshold and

NOTE CONF {"raw":[100,100,100,100,100,100,100,73,100,69]}

00:14:46.870 --> 00:14:49.190
<v Speaker 1>return one, otherwise we return zero.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:14:49.950 --> 00:14:53.590
<v Speaker 1>Let's assume the input is one zero and one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:14:53.670 --> 00:14:56.350
<v Speaker 1>Just like here zero and 1 or 1 and zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:56.390 --> 00:14:57.470
<v Speaker 1>The order doesn't really matter.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:57.470 --> 00:14:59.430
<v Speaker 1>So now we need to get an output of zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:00.670 --> 00:15:05.470
<v Speaker 1>We apply our little equation here right.

NOTE CONF {"raw":[100,100,100,100,100,100,92]}

00:15:05.510 --> 00:15:07.710
<v Speaker 1>We compute the weighted sum of the inputs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:09.270 --> 00:15:15.270
<v Speaker 1>So that means zero times 0.51 times 0.5.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:15.510 --> 00:15:17.270
<v Speaker 1>Sum this up is 0.5.

NOTE CONF {"raw":[100,100,100,100,96]}

00:15:17.950 --> 00:15:19.270
<v Speaker 1>We check against the threshold.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:19.270 --> 00:15:21.070
<v Speaker 1>Threshold is one so it's below the threshold.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:21.070 --> 00:15:23.430
<v Speaker 1>So the output is zero.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:23.670 --> 00:15:24.150
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:15:24.190 --> 00:15:26.830
<v Speaker 1>So that's good because it means that we've got these

NOTE CONF {"raw":[100,100,100,100,62,100,100,100,100,100]}

00:15:26.830 --> 00:15:27.750
<v Speaker 1>two lines right.

NOTE CONF {"raw":[100,100,100]}

00:15:28.990 --> 00:15:30.350
<v Speaker 1>Let's try the other case.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:31.190 --> 00:15:35.710
<v Speaker 1>Input is one and one right here at both inputs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:35.770 --> 00:15:36.850
<v Speaker 1>Now we have this case.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:36.970 --> 00:15:39.330
<v Speaker 1>We would like to get a one as an output.

NOTE CONF {"raw":[100,100,100,100,100,79,100,100,100,100]}

00:15:40.530 --> 00:15:44.010
<v Speaker 1>So it's 1.0.5 plus 1.0.5 is one.

NOTE CONF {"raw":[100,94,55,100,29,70,100]}

00:15:44.370 --> 00:15:47.010
<v Speaker 1>And if it's bigger or equal to the threshold threshold

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:47.010 --> 00:15:47.410
<v Speaker 1>is one.

NOTE CONF {"raw":[100,100]}

00:15:47.410 --> 00:15:48.610
<v Speaker 1>Then we output a one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:49.050 --> 00:15:51.690
<v Speaker 1>So we get this right as well the zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:15:51.730 --> 00:15:56.050
<v Speaker 1>You can easily verify yourself that the sum will be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:56.050 --> 00:15:58.130
<v Speaker 1>zero, and then the output will be zero as well.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:59.370 --> 00:16:00.690
<v Speaker 1>So here the output is one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:00.930 --> 00:16:03.090
<v Speaker 1>And I'm not going through the zero case.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:03.570 --> 00:16:04.010
<v Speaker 1>So.

NOTE CONF {"raw":[90]}

00:16:06.570 --> 00:16:09.650
<v Speaker 1>Here I've set up the perceptron so that it computes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:09.650 --> 00:16:10.690
<v Speaker 1>the logical function.

NOTE CONF {"raw":[100,100,100]}

00:16:10.690 --> 00:16:15.370
<v Speaker 1>And for us right it I assume everything is binary.

NOTE CONF {"raw":[100,100,100,54,93,100,100,100,100,100]}

00:16:15.370 --> 00:16:17.050
<v Speaker 1>So these are all the possible inputs.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:16:17.370 --> 00:16:18.490
<v Speaker 1>And these are the outputs.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:18.490 --> 00:16:20.410
<v Speaker 1>And they correspond to the logical and.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:16:22.690 --> 00:16:24.930
<v Speaker 1>Before I move on and I don't have any wool

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,91]}

00:16:24.930 --> 00:16:28.650
<v Speaker 1>club or anything but are there any questions anything that

NOTE CONF {"raw":[77,100,100,100,100,100,100,100,100,100]}

00:16:28.650 --> 00:16:31.090
<v Speaker 1>people would like to ask at this point.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:33.650 --> 00:16:34.760
<v Speaker 1>So far so good.

NOTE CONF {"raw":[100,100,100,100]}

00:16:35.680 --> 00:16:40.000
<v Speaker 1>So this is obviously a toy example with just two

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:16:40.040 --> 00:16:41.840
<v Speaker 1>inputs and a simple logical function.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:41.840 --> 00:16:44.000
<v Speaker 1>Everything binary and.

NOTE CONF {"raw":[100,100,82]}

00:16:44.280 --> 00:16:46.560
<v Speaker 1>But it seems to work for and you can easily

NOTE CONF {"raw":[100,100,100,100,100,93,100,100,100,100]}

00:16:46.560 --> 00:16:48.600
<v Speaker 1>show that it works for R as well, right?

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,92]}

00:16:48.640 --> 00:16:52.320
<v Speaker 1>The Or function is the same as as this one,

NOTE CONF {"raw":[100,73,100,100,100,100,80,100,100,100]}

00:16:52.320 --> 00:16:54.800
<v Speaker 1>except that here's a one and here's a one, right?

NOTE CONF {"raw":[100,100,80,89,100,100,96,99,100,95]}

00:16:54.840 --> 00:16:57.650
<v Speaker 1>Or is one if the input is zero 1 or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:57.650 --> 00:16:58.880
<v Speaker 1>1 0 or 1 one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:00.040 --> 00:17:02.320
<v Speaker 1>And so maybe this is general enough so that I

NOTE CONF {"raw":[100,100,100,100,100,91,100,100,100,100]}

00:17:02.600 --> 00:17:04.800
<v Speaker 1>can compute all logical functions.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:05.439 --> 00:17:09.319
<v Speaker 1>If I remember correctly, there's eight logical functions okay.

NOTE CONF {"raw":[96,96,100,100,91,100,100,100,67]}

00:17:10.520 --> 00:17:13.480
<v Speaker 1>Um what do people think?

NOTE CONF {"raw":[80,100,100,100,100]}

00:17:14.280 --> 00:17:15.880
<v Speaker 1>What about a function like XOR?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:17:16.319 --> 00:17:18.120
<v Speaker 1>XOR is the exclusive or.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:18.680 --> 00:17:20.280
<v Speaker 1>So that's this function here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:22.360 --> 00:17:26.360
<v Speaker 1>Where it is one only if one of the inputs

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:26.360 --> 00:17:26.760
<v Speaker 1>is one.

NOTE CONF {"raw":[100,100]}

00:17:26.760 --> 00:17:28.600
<v Speaker 1>So this is either or right.

NOTE CONF {"raw":[100,100,100,100,97,98]}

00:17:28.640 --> 00:17:30.440
<v Speaker 1>I'll go either to the theatre or to the cinema,

NOTE CONF {"raw":[100,100,100,100,100,55,100,100,100,100]}

00:17:30.440 --> 00:17:31.000
<v Speaker 1>not both.

NOTE CONF {"raw":[97,100]}

00:17:31.560 --> 00:17:35.020
<v Speaker 1>This is this logical function exclusive or do you think

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:35.020 --> 00:17:35.980
<v Speaker 1>we can model that too?

NOTE CONF {"raw":[100,100,100,100,82]}

00:17:37.100 --> 00:17:38.260
<v Speaker 1>It should be easy, right?

NOTE CONF {"raw":[60,100,100,100,96]}

00:17:40.020 --> 00:17:40.900
<v Speaker 1>Same architecture.

NOTE CONF {"raw":[100,100]}

00:17:40.940 --> 00:17:42.980
<v Speaker 1>Maybe we need to change the weights of the threshold.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:44.180 --> 00:17:47.020
<v Speaker 1>Turns out it's not possible with a perceptron.

NOTE CONF {"raw":[100,100,100,100,100,100,88,100]}

00:17:47.020 --> 00:17:48.820
<v Speaker 1>And we'll look at the example here.

NOTE CONF {"raw":[100,99,100,100,100,100,100]}

00:17:48.900 --> 00:17:53.340
<v Speaker 1>So here assuming weights of 0.5 and also a threshold

NOTE CONF {"raw":[100,98,100,100,100,90,100,100,100,100]}

00:17:53.340 --> 00:17:54.140
<v Speaker 1>of 0.5.

NOTE CONF {"raw":[100,90]}

00:17:54.660 --> 00:17:56.820
<v Speaker 1>And then if the input is 1 or 0.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:17:59.740 --> 00:18:01.620
<v Speaker 1>Our weighted sum is 0.5.

NOTE CONF {"raw":[100,100,100,100,90]}

00:18:02.180 --> 00:18:04.020
<v Speaker 1>So that means the output would be one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:04.500 --> 00:18:04.980
<v Speaker 1>Great.

NOTE CONF {"raw":[85]}

00:18:07.300 --> 00:18:10.820
<v Speaker 1>If the inputs are zeros then obviously the weighted sum

NOTE CONF {"raw":[100,100,100,100,95,100,100,100,100,100]}

00:18:10.820 --> 00:18:12.580
<v Speaker 1>is zero and the output is also zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:12.580 --> 00:18:15.220
<v Speaker 1>So this case is also correct.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:18:15.980 --> 00:18:21.300
<v Speaker 1>But if we have two ones then the weighted sum

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:21.300 --> 00:18:21.820
<v Speaker 1>is one.

NOTE CONF {"raw":[100,100]}

00:18:22.220 --> 00:18:24.020
<v Speaker 1>And this is bigger than our threshold.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:24.020 --> 00:18:26.500
<v Speaker 1>So the output is one whereas the correct output should

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:26.500 --> 00:18:27.020
<v Speaker 1>be zero.

NOTE CONF {"raw":[100,100]}

00:18:28.340 --> 00:18:31.160
<v Speaker 1>And you can easily show that no matter how you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:31.160 --> 00:18:32.480
<v Speaker 1>set your weights right.

NOTE CONF {"raw":[100,100,100,91]}

00:18:32.520 --> 00:18:34.000
<v Speaker 1>You have the weights to play with here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:34.000 --> 00:18:36.600
<v Speaker 1>You could choose different weights or you could choose a

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,100]}

00:18:36.600 --> 00:18:37.480
<v Speaker 1>different threshold.

NOTE CONF {"raw":[100,100]}

00:18:37.600 --> 00:18:40.400
<v Speaker 1>But no matter how you set those, you can never

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:40.440 --> 00:18:41.800
<v Speaker 1>get the XOR function.

NOTE CONF {"raw":[100,100,100,100]}

00:18:43.120 --> 00:18:47.960
<v Speaker 1>And so when the perceptron was first invented, this caused

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:47.960 --> 00:18:51.480
<v Speaker 1>a bit of a crisis that people discovered that, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:51.480 --> 00:18:54.440
<v Speaker 1>know, no matter how you set the parameters, the weights

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:54.440 --> 00:18:57.680
<v Speaker 1>in the threshold, you cannot actually model even a simple

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:57.680 --> 00:18:59.560
<v Speaker 1>logical function like XOR.

NOTE CONF {"raw":[100,100,100,100]}

00:19:00.640 --> 00:19:02.040
<v Speaker 1>Another question is why?

NOTE CONF {"raw":[74,100,100,100]}

00:19:02.640 --> 00:19:04.240
<v Speaker 1>So let's think about that a little bit.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:19:04.240 --> 00:19:09.640
<v Speaker 1>So this doesn't work and doesn't work either unfortunately.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:19:10.000 --> 00:19:17.080
<v Speaker 1>So um with a bit more mathematics.

NOTE CONF {"raw":[100,98,100,100,100,100,100]}

00:19:17.080 --> 00:19:20.800
<v Speaker 1>So people then went and analysed the perceptron and they

NOTE CONF {"raw":[100,100,100,100,100,76,100,100,100,100]}

00:19:20.800 --> 00:19:23.520
<v Speaker 1>figured out that there is a class of functions that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:23.520 --> 00:19:24.680
<v Speaker 1>the perceptron can learn.

NOTE CONF {"raw":[100,100,100,100]}

00:19:25.320 --> 00:19:27.960
<v Speaker 1>And this is actually a fairly limited class of function

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:28.280 --> 00:19:28.800
<v Speaker 1>functions.

NOTE CONF {"raw":[100]}

00:19:28.800 --> 00:19:32.790
<v Speaker 1>It's called the class of linearly separable functions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,98]}

00:19:33.150 --> 00:19:37.590
<v Speaker 1>So you can think about this like like follow like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97,100]}

00:19:37.590 --> 00:19:38.190
<v Speaker 1>the following.

NOTE CONF {"raw":[100,100]}

00:19:38.870 --> 00:19:40.750
<v Speaker 1>So if you draw your data.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:19:40.830 --> 00:19:43.710
<v Speaker 1>So here we have a very simple case of data.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:43.750 --> 00:19:43.950
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:19:43.990 --> 00:19:47.990
<v Speaker 1>We have four bits of input and the outputs associated

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,95,100]}

00:19:47.990 --> 00:19:48.390
<v Speaker 1>with that.

NOTE CONF {"raw":[100,100]}

00:19:48.390 --> 00:19:51.430
<v Speaker 1>But in general you can have a lot more data.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:52.150 --> 00:19:55.990
<v Speaker 1>And if we have two dimensions here dimension two and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:55.990 --> 00:19:58.310
<v Speaker 1>dimensions one on the x and y axis.

NOTE CONF {"raw":[96,100,100,100,100,100,100,100]}

00:19:58.870 --> 00:20:01.710
<v Speaker 1>And these correspond to our inputs right.

NOTE CONF {"raw":[100,100,100,100,100,100,98]}

00:20:01.750 --> 00:20:04.350
<v Speaker 1>So in general this can be natural can be real

NOTE CONF {"raw":[100,100,100,63,100,100,100,100,100,100]}

00:20:04.350 --> 00:20:04.630
<v Speaker 1>numbers.

NOTE CONF {"raw":[100]}

00:20:04.630 --> 00:20:05.870
<v Speaker 1>It doesn't have to be binary.

NOTE CONF {"raw":[54,100,100,100,100,100]}

00:20:07.590 --> 00:20:10.830
<v Speaker 1>And then we have the two possible outputs zeros and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:10.830 --> 00:20:13.070
<v Speaker 1>ones which are here just circles and pluses.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:20:14.030 --> 00:20:17.270
<v Speaker 1>And if these inputs and outputs they fall into little

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:17.630 --> 00:20:18.910
<v Speaker 1>clusters like this.

NOTE CONF {"raw":[100,100,100]}

00:20:19.110 --> 00:20:20.950
<v Speaker 1>And you can draw a line between them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:20:21.270 --> 00:20:23.510
<v Speaker 1>Then the perceptron is able to model them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:20:24.110 --> 00:20:26.710
<v Speaker 1>So it doesn't really matter whether the line is you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:26.710 --> 00:20:31.250
<v Speaker 1>know it's A vertical line or diagonal like this, or

NOTE CONF {"raw":[100,98,89,100,100,100,100,100,100,100]}

00:20:31.650 --> 00:20:32.570
<v Speaker 1>horizontal line.

NOTE CONF {"raw":[100,100]}

00:20:34.450 --> 00:20:37.210
<v Speaker 1>If there's a line that separates the ones in the

NOTE CONF {"raw":[100,95,100,100,100,100,100,100,95,90]}

00:20:37.250 --> 00:20:39.970
<v Speaker 1>and the zeros, or here the crosses and the and

NOTE CONF {"raw":[100,100,65,100,100,100,100,100,100,99]}

00:20:39.970 --> 00:20:44.930
<v Speaker 1>the circles, then this is called linearly separable, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,93]}

00:20:44.970 --> 00:20:47.050
<v Speaker 1>Because it's separable by a line.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:47.810 --> 00:20:51.730
<v Speaker 1>And a perceptron can learn this can learn to put

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:51.770 --> 00:20:56.730
<v Speaker 1>the ones on in one category and the the zeros

NOTE CONF {"raw":[100,100,68,100,100,100,100,91,100,91]}

00:20:56.730 --> 00:20:57.770
<v Speaker 1>in the other category.

NOTE CONF {"raw":[100,100,100,100]}

00:20:58.450 --> 00:21:02.770
<v Speaker 1>In general, this would be a hyperplane rather than a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:02.770 --> 00:21:03.370
<v Speaker 1>line, right?

NOTE CONF {"raw":[100,100]}

00:21:03.370 --> 00:21:05.050
<v Speaker 1>In two dimensions it's a line.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:05.490 --> 00:21:07.730
<v Speaker 1>In three dimensions it's a plane.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:08.330 --> 00:21:11.130
<v Speaker 1>But of course you can have higher dimensions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:21:11.290 --> 00:21:13.250
<v Speaker 1>There's actually no limit to the dimension.

NOTE CONF {"raw":[100,100,97,65,100,100,100]}

00:21:13.250 --> 00:21:15.290
<v Speaker 1>And this is then called a hyperplane.

NOTE CONF {"raw":[100,100,100,100,100,98,100]}

00:21:15.650 --> 00:21:18.730
<v Speaker 1>Once it's three, 4 or 5 dimensions it becomes really

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:18.730 --> 00:21:19.650
<v Speaker 1>hard to visualise.

NOTE CONF {"raw":[100,100,93]}

00:21:20.210 --> 00:21:21.970
<v Speaker 1>And these dimensions are the inputs.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:22.330 --> 00:21:23.610
<v Speaker 1>Right here we have two inputs.

NOTE CONF {"raw":[89,100,100,100,100,100]}

00:21:24.810 --> 00:21:26.400
<v Speaker 1>So it's two dimensional.

NOTE CONF {"raw":[100,100,100,100]}

00:21:27.160 --> 00:21:29.800
<v Speaker 1>Corresponding to the the two lines here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:29.840 --> 00:21:30.640
<v Speaker 1>Dimension one.

NOTE CONF {"raw":[100,100]}

00:21:30.880 --> 00:21:32.400
<v Speaker 1>Dimension one and dimension two.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:32.880 --> 00:21:35.440
<v Speaker 1>But if there were three inputs, then the space would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:35.440 --> 00:21:36.400
<v Speaker 1>be three dimensional.

NOTE CONF {"raw":[100,100,100]}

00:21:36.440 --> 00:21:38.640
<v Speaker 1>The four inputs would be four dimensional, and so on.

NOTE CONF {"raw":[100,100,100,79,100,100,100,100,100,100]}

00:21:39.360 --> 00:21:43.000
<v Speaker 1>And then you need a plane rather than just a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:43.000 --> 00:21:43.400
<v Speaker 1>line.

NOTE CONF {"raw":[100]}

00:21:44.080 --> 00:21:47.360
<v Speaker 1>But the same the same thing applies.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:47.560 --> 00:21:49.840
<v Speaker 1>If you can fit this plane, you can find this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:49.840 --> 00:21:51.960
<v Speaker 1>plane to separate the two classes.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:52.120 --> 00:21:53.960
<v Speaker 1>Then you can model it with a perceptron.

NOTE CONF {"raw":[100,100,100,100,100,100,78,100]}

00:21:54.840 --> 00:21:59.000
<v Speaker 1>And so why is this not possible with with XOR?

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:22:00.480 --> 00:22:01.680
<v Speaker 1>XOR is so simple.

NOTE CONF {"raw":[100,100,100,100]}

00:22:03.600 --> 00:22:05.040
<v Speaker 1>Anyone have an idea?

NOTE CONF {"raw":[100,100,100,100]}

00:22:07.480 --> 00:22:09.480
<v Speaker 1>Cannot separate the points by a line.

NOTE CONF {"raw":[100,100,83,100,100,92,100]}

00:22:09.720 --> 00:22:10.480
<v Speaker 1>Yeah, I don't know.

NOTE CONF {"raw":[96,100,100,100]}

00:22:11.920 --> 00:22:16.200
<v Speaker 0>Is it like there's no way to differentiate if the

NOTE CONF {"raw":[100,100,94,85,100,100,100,100,99,94]}

00:22:16.240 --> 00:22:19.840
<v Speaker 0>when it's above the activation function, like there's no it's

NOTE CONF {"raw":[100,100,66,100,100,100,100,89,78,77]}

00:22:19.840 --> 00:22:21.800
<v Speaker 0>differentiating with both or just not.

NOTE CONF {"raw":[46,98,100,100,100,37]}

00:22:23.000 --> 00:22:23.480
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:22:23.480 --> 00:22:25.700
<v Speaker 1>That is roughly the intuition you need.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:26.060 --> 00:22:28.780
<v Speaker 1>Another way of putting it you need a more complicated

NOTE CONF {"raw":[100,100,100,100,100,100,100,99,100,100]}

00:22:28.780 --> 00:22:29.620
<v Speaker 1>thing than a line.

NOTE CONF {"raw":[100,100,100,100]}

00:22:29.980 --> 00:22:32.180
<v Speaker 1>You need multiple lines, or you need a curve or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:32.180 --> 00:22:33.060
<v Speaker 1>something like that.

NOTE CONF {"raw":[100,100,100]}

00:22:33.420 --> 00:22:36.140
<v Speaker 1>So and we see this here, right?

NOTE CONF {"raw":[100,99,100,100,100,100,96]}

00:22:36.180 --> 00:22:37.940
<v Speaker 1>If we plot our XOR right.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:37.980 --> 00:22:40.620
<v Speaker 1>These are the two inputs x1 and x2 corresponding to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:40.660 --> 00:22:43.180
<v Speaker 1>the two dimensions here dimension one and dimension two.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:22:43.980 --> 00:22:48.380
<v Speaker 1>And then this is zero.

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:48.420 --> 00:22:51.500
<v Speaker 1>Zero has an output of zero one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:51.500 --> 00:22:53.860
<v Speaker 1>One has an output of zero as well.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:22:55.100 --> 00:22:59.540
<v Speaker 1>101 and one zero have an output of one, right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,96]}

00:22:59.580 --> 00:23:01.780
<v Speaker 1>This is just how the function is defined that we're

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:23:01.780 --> 00:23:02.580
<v Speaker 1>trying to model.

NOTE CONF {"raw":[100,100,100]}

00:23:03.660 --> 00:23:07.860
<v Speaker 1>And then of course you can easily see that this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:07.860 --> 00:23:09.100
<v Speaker 1>forms a cluster right.

NOTE CONF {"raw":[94,100,100,100]}

00:23:09.140 --> 00:23:10.020
<v Speaker 1>Those two points.

NOTE CONF {"raw":[100,100,100]}

00:23:10.340 --> 00:23:13.300
<v Speaker 1>But these two points you cannot really draw a cluster.

NOTE CONF {"raw":[100,100,100,100,100,99,100,100,100,100]}

00:23:14.980 --> 00:23:17.260
<v Speaker 1>I mean you could draw a complicated cluster like this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:17.580 --> 00:23:20.140
<v Speaker 1>like a U-shaped, but then you need more than one

NOTE CONF {"raw":[100,100,51,100,100,100,100,100,100,100]}

00:23:20.140 --> 00:23:21.260
<v Speaker 1>line to separate it.

NOTE CONF {"raw":[100,100,100,100]}

00:23:21.620 --> 00:23:25.440
<v Speaker 1>Or alternatively you draw a line here and a line

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:25.440 --> 00:23:29.120
<v Speaker 1>here, but you can't draw a single line that has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:29.240 --> 00:23:31.960
<v Speaker 1>these points on one side and those points on the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:31.960 --> 00:23:32.560
<v Speaker 1>other side.

NOTE CONF {"raw":[100,100]}

00:23:33.160 --> 00:23:34.560
<v Speaker 1>That is the intuition, right?

NOTE CONF {"raw":[95,96,100,100,93]}

00:23:34.600 --> 00:23:38.000
<v Speaker 1>So this is basically the simplest possible function that has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:38.000 --> 00:23:39.440
<v Speaker 1>this property.

NOTE CONF {"raw":[98,100]}

00:23:40.040 --> 00:23:43.400
<v Speaker 1>And so it's the simplest function where we cannot take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:23:44.240 --> 00:23:47.360
<v Speaker 1>these two points zero zero and one one and zero

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:47.400 --> 00:23:49.920
<v Speaker 1>one and one zero and separate them by a line.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:50.600 --> 00:23:50.920
<v Speaker 1>Right.

NOTE CONF {"raw":[98]}

00:23:50.960 --> 00:23:55.080
<v Speaker 1>For and we only need to separate this from those

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:23:55.080 --> 00:23:55.480
<v Speaker 1>three.

NOTE CONF {"raw":[100]}

00:23:55.680 --> 00:23:56.960
<v Speaker 1>And we draw the line here.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:57.120 --> 00:23:58.400
<v Speaker 1>So that would be really easy.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:58.600 --> 00:23:59.240
<v Speaker 1>For all.

NOTE CONF {"raw":[100,98]}

00:24:01.840 --> 00:24:05.040
<v Speaker 1>The we have one class that takes all these three

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:05.640 --> 00:24:06.680
<v Speaker 1>because they're all one.

NOTE CONF {"raw":[100,100,100,100]}

00:24:07.080 --> 00:24:08.960
<v Speaker 1>And one is this one is zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:08.960 --> 00:24:11.440
<v Speaker 1>So we draw the line here and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:24:11.520 --> 00:24:15.400
<v Speaker 1>So for the other logical functions it's possible the linearly

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:24:15.400 --> 00:24:15.920
<v Speaker 1>separable.

NOTE CONF {"raw":[100]}

00:24:15.920 --> 00:24:19.120
<v Speaker 1>So you can draw the line to separate the two

NOTE CONF {"raw":[100,100,100,100,77,100,100,100,100,100]}

00:24:19.120 --> 00:24:19.680
<v Speaker 1>classes.

NOTE CONF {"raw":[100]}

00:24:20.560 --> 00:24:21.790
<v Speaker 1>And what?

NOTE CONF {"raw":[100,100]}

00:24:22.190 --> 00:24:25.790
<v Speaker 1>This is really the only thing the perceptron can do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:25.830 --> 00:24:26.430
<v Speaker 1>It can.

NOTE CONF {"raw":[100,100]}

00:24:29.470 --> 00:24:33.990
<v Speaker 1>It can classify two classes or teaser part two classes

NOTE CONF {"raw":[100,100,100,100,100,100,56,56,100,100]}

00:24:34.190 --> 00:24:36.070
<v Speaker 1>if they can be separated by a line.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:36.710 --> 00:24:37.030
<v Speaker 1>Right?

NOTE CONF {"raw":[94]}

00:24:37.070 --> 00:24:39.830
<v Speaker 1>Which is perhaps not super surprising because everything here is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:39.830 --> 00:24:40.310
<v Speaker 1>linear.

NOTE CONF {"raw":[100]}

00:24:40.950 --> 00:24:41.230
<v Speaker 1>All right.

NOTE CONF {"raw":[64,96]}

00:24:41.270 --> 00:24:43.030
<v Speaker 1>Let's go back to our definition.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:44.830 --> 00:24:47.110
<v Speaker 1>This is just a weighted sum.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:47.270 --> 00:24:47.910
<v Speaker 1>It's linear.

NOTE CONF {"raw":[58,100]}

00:24:48.190 --> 00:24:50.390
<v Speaker 1>This is just a step function that's linear.

NOTE CONF {"raw":[100,100,100,100,100,100,96,100]}

00:24:51.550 --> 00:24:54.950
<v Speaker 1>So we cannot get any curves or anything complicated out

NOTE CONF {"raw":[100,100,81,100,100,100,100,100,100,100]}

00:24:54.950 --> 00:24:55.790
<v Speaker 1>of this model.

NOTE CONF {"raw":[100,100,100]}

00:24:56.910 --> 00:24:57.390
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:24:58.430 --> 00:25:03.310
<v Speaker 1>So and now let's let's think a little bit how

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:03.390 --> 00:25:08.270
<v Speaker 1>we could potentially fix this before we talk about learning.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:09.230 --> 00:25:15.390
<v Speaker 1>Um, if we're um, if we have this simple linear

NOTE CONF {"raw":[74,100,100,65,100,100,100,100,100,100]}

00:25:15.390 --> 00:25:22.010
<v Speaker 1>setup and we are making all these assumptions that it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,91]}

00:25:22.010 --> 00:25:25.610
<v Speaker 1>a linear sum, that is a threshold function that the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:25.610 --> 00:25:27.130
<v Speaker 1>inputs and outputs are binary.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:27.490 --> 00:25:29.770
<v Speaker 1>Which of these assumptions do we need to change?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:25:30.570 --> 00:25:34.370
<v Speaker 1>You think to overcome this problem that we can only

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:34.370 --> 00:25:36.250
<v Speaker 1>model linearly separable functions?

NOTE CONF {"raw":[100,100,100,100]}

00:25:38.890 --> 00:25:41.170
<v Speaker 1>Maybe more complicated activation function.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:42.290 --> 00:25:42.610
<v Speaker 1>Right.

NOTE CONF {"raw":[86]}

00:25:42.650 --> 00:25:46.970
<v Speaker 1>We could have, I don't know, a tangent or a

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,100,96]}

00:25:46.970 --> 00:25:49.650
<v Speaker 1>sine function or a quadratic function.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:25:50.170 --> 00:25:51.890
<v Speaker 1>Turns out that doesn't make a difference.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:25:52.090 --> 00:25:53.850
<v Speaker 1>It doesn't make the model more powerful.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:25:54.210 --> 00:25:57.530
<v Speaker 1>It makes it more elegant in certain ways, but it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:57.530 --> 00:26:01.170
<v Speaker 1>doesn't actually allow us to model anything we can't model.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:01.210 --> 00:26:02.210
<v Speaker 1>We can model now.

NOTE CONF {"raw":[100,100,100,100]}

00:26:03.810 --> 00:26:07.890
<v Speaker 1>What about allowing the inputs to be real numbers and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:07.890 --> 00:26:10.370
<v Speaker 1>the outputs to be real numbers, rather than just binary

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:10.370 --> 00:26:10.890
<v Speaker 1>numbers?

NOTE CONF {"raw":[100]}

00:26:11.850 --> 00:26:13.450
<v Speaker 1>Also doesn't make a difference.

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:14.770 --> 00:26:20.230
<v Speaker 1>What about we use lots of different, uh, lots of

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:26:20.230 --> 00:26:24.830
<v Speaker 1>these, um, simple units, and we network them together.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:26:26.230 --> 00:26:27.270
<v Speaker 1>Does that make a difference?

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:27.270 --> 00:26:28.590
<v Speaker 1>Does that make them more powerful?

NOTE CONF {"raw":[100,100,100,92,97,100]}

00:26:30.790 --> 00:26:31.310
<v Speaker 1>Yes.

NOTE CONF {"raw":[100]}

00:26:31.350 --> 00:26:31.670
<v Speaker 1>Why?

NOTE CONF {"raw":[100]}

00:26:33.790 --> 00:26:34.910
<v Speaker 1>What's the intuition?

NOTE CONF {"raw":[100,100,100]}

00:26:34.950 --> 00:26:36.350
<v Speaker 1>Very, very simple intuition.

NOTE CONF {"raw":[100,100,100,100]}

00:26:37.470 --> 00:26:37.910
<v Speaker 1>Yeah.

NOTE CONF {"raw":[98]}

00:26:38.350 --> 00:26:40.470
<v Speaker 0>You could just separate them into two groups and then

NOTE CONF {"raw":[100,85,100,100,100,100,100,100,100,100]}

00:26:40.470 --> 00:26:41.950
<v Speaker 0>separate the two groups again.

NOTE CONF {"raw":[100,94,100,100,100]}

00:26:42.870 --> 00:26:43.310
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:26:43.790 --> 00:26:46.870
<v Speaker 1>Or more generally, you can model a curve.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:46.910 --> 00:26:47.190
<v Speaker 1>Right.

NOTE CONF {"raw":[97]}

00:26:47.230 --> 00:26:50.230
<v Speaker 1>So instead of just having to rely, rely on a

NOTE CONF {"raw":[100,100,100,100,100,100,85,100,100,100]}

00:26:50.230 --> 00:26:54.790
<v Speaker 1>line to separate the two categories, multiple units give you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:54.790 --> 00:26:56.990
<v Speaker 1>a curve that is basically made up of lots of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:56.990 --> 00:26:57.710
<v Speaker 1>little lines.

NOTE CONF {"raw":[100,100]}

00:26:58.230 --> 00:26:58.430
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:26:58.470 --> 00:27:00.990
<v Speaker 1>So you can approximate a more complicated function.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:01.190 --> 00:27:04.870
<v Speaker 1>Each of the units models one segment of that as

NOTE CONF {"raw":[100,100,100,100,99,100,100,100,100,100]}

00:27:04.870 --> 00:27:05.350
<v Speaker 1>a line.

NOTE CONF {"raw":[100,100]}

00:27:05.670 --> 00:27:08.550
<v Speaker 1>So the more units you have, the smoother your your

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,91,100]}

00:27:08.590 --> 00:27:09.510
<v Speaker 1>curve becomes.

NOTE CONF {"raw":[100,100]}

00:27:09.830 --> 00:27:15.710
<v Speaker 1>And you can you can model quite complicated decision surfaces.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:15.710 --> 00:27:17.980
<v Speaker 1>Then these are then called decision services.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:27:18.420 --> 00:27:21.020
<v Speaker 1>What is a line or a hyperplane in a simple

NOTE CONF {"raw":[100,100,97,100,97,100,100,100,80,100]}

00:27:21.020 --> 00:27:21.460
<v Speaker 1>model?

NOTE CONF {"raw":[100]}

00:27:21.780 --> 00:27:23.500
<v Speaker 1>There's a there's another trick though.

NOTE CONF {"raw":[100,100,100,100,100,98]}

00:27:24.020 --> 00:27:30.340
<v Speaker 1>You need to, uh you need to, um, you need

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:27:30.340 --> 00:27:33.660
<v Speaker 1>to have a certain configuration of your neurones.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:34.180 --> 00:27:34.420
<v Speaker 1>Right?

NOTE CONF {"raw":[98]}

00:27:34.460 --> 00:27:37.540
<v Speaker 1>If you just have one neurone next to the other.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:37.580 --> 00:27:37.780
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:27:37.820 --> 00:27:40.820
<v Speaker 1>So the input is, is a is a layer of

NOTE CONF {"raw":[100,79,100,94,100,100,100,100,100,100]}

00:27:40.820 --> 00:27:41.860
<v Speaker 1>lots of different neurones.

NOTE CONF {"raw":[100,100,100,100]}

00:27:41.860 --> 00:27:42.780
<v Speaker 1>That's not enough.

NOTE CONF {"raw":[100,100,100]}

00:27:43.220 --> 00:27:45.380
<v Speaker 1>If you have two layers, that's also not enough.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:45.420 --> 00:27:47.140
<v Speaker 1>You need what's called a hidden layer.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:27:47.860 --> 00:27:50.700
<v Speaker 1>And once you have a hidden layer so you have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:50.700 --> 00:27:52.540
<v Speaker 1>an input layer, an output layer and a hidden layer

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:52.540 --> 00:27:53.260
<v Speaker 1>in between.

NOTE CONF {"raw":[100,100]}

00:27:53.700 --> 00:27:56.500
<v Speaker 1>So at least three layers in your network, then you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:56.500 --> 00:27:59.820
<v Speaker 1>actually have the the maximum possible power.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:28:00.140 --> 00:28:02.820
<v Speaker 1>In fact, you can show with a setup like this.

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:28:03.020 --> 00:28:06.420
<v Speaker 1>You can approximate arbitrary functions right.

NOTE CONF {"raw":[100,100,100,100,100,85]}

00:28:06.460 --> 00:28:09.100
<v Speaker 1>So you have an arbitrary you have a universal function

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:09.100 --> 00:28:12.860
<v Speaker 1>approximator once you do that, but with a single layer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:13.140 --> 00:28:17.360
<v Speaker 1>And no matter how complicated you make the units, you're

NOTE CONF {"raw":[100,100,100,100,100,100,100,91,100,100]}

00:28:17.360 --> 00:28:18.360
<v Speaker 1>not able to do it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:19.440 --> 00:28:21.080
<v Speaker 1>But we'll come to that next week.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:28:21.840 --> 00:28:25.840
<v Speaker 1>Uh, before we do that, um, let's talk about learning,

NOTE CONF {"raw":[67,100,100,100,100,68,100,100,100,100]}

00:28:26.320 --> 00:28:26.600
<v Speaker 1>right?

NOTE CONF {"raw":[70]}

00:28:26.640 --> 00:28:29.760
<v Speaker 1>So, so far, I have just sort of conjured up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:31.120 --> 00:28:32.040
<v Speaker 1>these weights here.

NOTE CONF {"raw":[100,100,100]}

00:28:32.320 --> 00:28:33.400
<v Speaker 1>And the threshold.

NOTE CONF {"raw":[100,100,100]}

00:28:34.160 --> 00:28:37.120
<v Speaker 1>In the general case, of course, we would like to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:37.920 --> 00:28:40.720
<v Speaker 1>not do that, in particular in a large network.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:40.720 --> 00:28:40.960
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:28:41.000 --> 00:28:44.040
<v Speaker 1>Where we might have tens, hundreds, thousands of neurones.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:45.000 --> 00:28:48.840
<v Speaker 1>If you've been following the literature on large language models.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:48.880 --> 00:28:49.120
<v Speaker 1>Right.

NOTE CONF {"raw":[99]}

00:28:49.160 --> 00:28:52.840
<v Speaker 1>Contemporary models, they have 200 billion parameters.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:28:53.000 --> 00:28:53.200
<v Speaker 1>Right.

NOTE CONF {"raw":[76]}

00:28:53.240 --> 00:28:55.520
<v Speaker 1>So that's 200 billion of these weights.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:28:56.320 --> 00:28:58.920
<v Speaker 1>No way we can guess those manually.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:28:58.960 --> 00:28:59.240
<v Speaker 1>Right?

NOTE CONF {"raw":[97]}

00:28:59.280 --> 00:29:03.040
<v Speaker 1>So we need a way of learning them of throwing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:03.040 --> 00:29:06.000
<v Speaker 1>data at the model and inferring these parameters.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:06.480 --> 00:29:08.240
<v Speaker 1>And that's what we're going to look at next.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:08.240 --> 00:29:11.680
<v Speaker 1>And again to keep things simple we'll just do this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:11.680 --> 00:29:12.680
<v Speaker 1>for the perceptron.

NOTE CONF {"raw":[100,100,100]}

00:29:13.080 --> 00:29:15.380
<v Speaker 1>And then tomorrow we'll talk about the general case.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:16.580 --> 00:29:18.580
<v Speaker 1>And now I just need to check my time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:19.860 --> 00:29:20.340
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:20.940 --> 00:29:21.580
<v Speaker 1>Ten minutes.

NOTE CONF {"raw":[100,100]}

00:29:21.780 --> 00:29:25.020
<v Speaker 1>So we're unfortunately not going to manage to finish this

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,100]}

00:29:25.020 --> 00:29:27.860
<v Speaker 1>today, but, uh, we'll continue on Friday.

NOTE CONF {"raw":[100,100,60,100,100,100,100]}

00:29:28.860 --> 00:29:29.220
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:29.260 --> 00:29:32.420
<v Speaker 1>So choosing these weights and thresholds, which we have just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:32.420 --> 00:29:34.940
<v Speaker 1>made up here, that is in general not easy.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:35.260 --> 00:29:38.420
<v Speaker 1>We want to learn them from examples, right from training

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:29:38.420 --> 00:29:41.900
<v Speaker 1>examples where we know the correct answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:29:42.420 --> 00:29:44.420
<v Speaker 1>And we use that to set our weights.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:44.420 --> 00:29:46.860
<v Speaker 1>And then on new examples that we haven't seen before.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:46.900 --> 00:29:48.820
<v Speaker 1>Hopefully we'll also get the correct answer.

NOTE CONF {"raw":[100,97,100,100,100,100,100]}

00:29:49.020 --> 00:29:50.460
<v Speaker 1>So we need a learning algorithm.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:29:50.460 --> 00:29:52.900
<v Speaker 1>And here's a YouTube video that illustrates it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:53.660 --> 00:29:55.340
<v Speaker 1>Um if you want to look at that.

NOTE CONF {"raw":[85,100,100,100,100,100,100,100]}

00:29:56.500 --> 00:30:01.540
<v Speaker 1>Um, so before we get there, here's a simple trick.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:02.500 --> 00:30:05.140
<v Speaker 1>Um, we said we need to learn the weights here

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:05.180 --> 00:30:07.300
<v Speaker 1>w and the threshold.

NOTE CONF {"raw":[100,100,100,100]}

00:30:07.700 --> 00:30:10.900
<v Speaker 1>The threshold is kind of inconvenient because it's a special

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:10.900 --> 00:30:11.300
<v Speaker 1>case.

NOTE CONF {"raw":[100]}

00:30:11.580 --> 00:30:12.410
<v Speaker 1>So what we can do.

NOTE CONF {"raw":[100,100,100,100,100]}

00:30:12.450 --> 00:30:14.050
<v Speaker 1>We can just turn it into a wait.

NOTE CONF {"raw":[100,100,100,100,100,100,100,50]}

00:30:15.810 --> 00:30:19.010
<v Speaker 1>So let's assume here we have another input.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:30:19.090 --> 00:30:23.250
<v Speaker 1>The input always has minus one, the value minus one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:23.570 --> 00:30:25.890
<v Speaker 1>And the weight is our threshold theta.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:30:26.610 --> 00:30:29.610
<v Speaker 1>And so we just treat this as another input.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:30.290 --> 00:30:35.770
<v Speaker 1>And then our our activation function becomes just one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:35.890 --> 00:30:39.250
<v Speaker 1>If the input is bigger than zero and zero otherwise.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:39.610 --> 00:30:39.810
<v Speaker 1>Right.

NOTE CONF {"raw":[95]}

00:30:39.850 --> 00:30:41.650
<v Speaker 1>So we don't have anything to adjust here in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97,100]}

00:30:41.650 --> 00:30:42.690
<v Speaker 1>activation function.

NOTE CONF {"raw":[100,100]}

00:30:42.850 --> 00:30:45.250
<v Speaker 1>And instead we are adjusting this weight.

NOTE CONF {"raw":[100,100,52,52,100,100,100]}

00:30:45.330 --> 00:30:49.090
<v Speaker 1>Theta which is one of our behaves in the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:49.090 --> 00:30:50.090
<v Speaker 1>way as our normal weights.

NOTE CONF {"raw":[100,100,100,100,100]}

00:30:50.090 --> 00:30:53.250
<v Speaker 1>So that's just a trick to say from now on

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:53.250 --> 00:30:58.170
<v Speaker 1>I will not talk about theta anymore basically, but it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:30:58.170 --> 00:31:00.930
<v Speaker 1>completely equivalent these two ways of doing things.

NOTE CONF {"raw":[100,100,94,100,100,100,100,100]}

00:31:01.850 --> 00:31:06.050
<v Speaker 1>Okay, so let's try to think what's happening before we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:06.650 --> 00:31:09.130
<v Speaker 1>try to think what a good learning algorithm would be.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:09.810 --> 00:31:13.750
<v Speaker 1>So we want to learn from from examples, right.

NOTE CONF {"raw":[100,100,100,100,100,87,100,100,89]}

00:31:13.790 --> 00:31:15.950
<v Speaker 1>Just like here we had all these examples.

NOTE CONF {"raw":[100,100,100,100,80,100,100,100]}

00:31:16.190 --> 00:31:19.710
<v Speaker 1>Let's assume we have a set of of examples like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:19.710 --> 00:31:20.070
<v Speaker 1>this.

NOTE CONF {"raw":[100]}

00:31:20.350 --> 00:31:23.190
<v Speaker 1>And we want to adjust our weights based on those

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:23.190 --> 00:31:23.870
<v Speaker 1>examples.

NOTE CONF {"raw":[100]}

00:31:24.070 --> 00:31:27.790
<v Speaker 1>So in the general case here let's assume we have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:27.790 --> 00:31:28.550
<v Speaker 1>four inputs.

NOTE CONF {"raw":[100,100]}

00:31:28.670 --> 00:31:30.190
<v Speaker 1>So our inputs look like this.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:30.390 --> 00:31:32.470
<v Speaker 1>Sequences of four zeros and ones.

NOTE CONF {"raw":[100,100,100,94,100,100]}

00:31:32.470 --> 00:31:34.070
<v Speaker 1>We're still assuming the input is binary.

NOTE CONF {"raw":[100,100,100,69,100,100,100]}

00:31:34.390 --> 00:31:37.870
<v Speaker 1>Let's assume we have six exemplars or training items or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:37.870 --> 00:31:39.470
<v Speaker 1>training examples like that.

NOTE CONF {"raw":[100,100,100,100]}

00:31:39.870 --> 00:31:43.430
<v Speaker 1>And we also know what the output is right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94]}

00:31:43.470 --> 00:31:45.630
<v Speaker 1>For this input the output is one for that input

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:45.630 --> 00:31:47.190
<v Speaker 1>the output is zero and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:47.670 --> 00:31:50.190
<v Speaker 1>So this is a supervised learning algorithm right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:31:50.230 --> 00:31:53.230
<v Speaker 1>That means we know the correct answer for our training

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:53.230 --> 00:31:53.670
<v Speaker 1>data.

NOTE CONF {"raw":[100]}

00:31:53.830 --> 00:31:55.950
<v Speaker 1>Later on we can test it on new examples where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:55.950 --> 00:31:56.950
<v Speaker 1>we don't know the answer.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:57.110 --> 00:31:59.870
<v Speaker 1>But for training we assume that we know the answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:00.870 --> 00:32:05.350
<v Speaker 1>And um, but we don't know the weights or the

NOTE CONF {"raw":[83,54,100,100,100,100,100,100,100,100]}

00:32:05.350 --> 00:32:05.790
<v Speaker 1>threshold.

NOTE CONF {"raw":[100]}

00:32:05.830 --> 00:32:05.990
<v Speaker 1>Right?

NOTE CONF {"raw":[96]}

00:32:06.030 --> 00:32:07.510
<v Speaker 1>That's what we're trying to adjust.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:07.830 --> 00:32:10.970
<v Speaker 1>So how about we compute the output of the network,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:11.170 --> 00:32:11.410
<v Speaker 1>right.

NOTE CONF {"raw":[97]}

00:32:11.450 --> 00:32:13.850
<v Speaker 1>Let's assume we initialise our weights in some way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:13.850 --> 00:32:15.290
<v Speaker 1>We can set them all to zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:32:15.530 --> 00:32:17.810
<v Speaker 1>We can set them to random values.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:32:17.970 --> 00:32:19.570
<v Speaker 1>But let's assume we have weights.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:19.890 --> 00:32:22.170
<v Speaker 1>And then we can compute the output right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:32:22.210 --> 00:32:28.010
<v Speaker 1>Using the formula that we have started with.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:32:30.050 --> 00:32:30.730
<v Speaker 1>Sorry.

NOTE CONF {"raw":[100]}

00:32:30.770 --> 00:32:34.730
<v Speaker 1>Here using our activation function our input function and our

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:34.730 --> 00:32:35.690
<v Speaker 1>activation function.

NOTE CONF {"raw":[100,100]}

00:32:35.690 --> 00:32:37.010
<v Speaker 1>So we compute the output.

NOTE CONF {"raw":[100,100,100,100,100]}

00:32:37.490 --> 00:32:39.850
<v Speaker 1>So we get a output which will not be very

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:39.850 --> 00:32:42.410
<v Speaker 1>good if we assume random weights to start with.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:43.770 --> 00:32:47.250
<v Speaker 1>But what we can do we can compare this output

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:47.570 --> 00:32:48.770
<v Speaker 1>to the correct output.

NOTE CONF {"raw":[100,100,100,100]}

00:32:48.930 --> 00:32:49.170
<v Speaker 1>Right.

NOTE CONF {"raw":[98]}

00:32:49.210 --> 00:32:51.610
<v Speaker 1>Remember for our training examples we know the target.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:51.610 --> 00:32:52.890
<v Speaker 1>We know the correct output.

NOTE CONF {"raw":[100,100,100,100,100]}

00:32:53.210 --> 00:32:54.770
<v Speaker 1>So here this is wrong.

NOTE CONF {"raw":[100,100,100,100,100]}

00:32:54.850 --> 00:32:55.810
<v Speaker 1>This one is right.

NOTE CONF {"raw":[100,100,100,100]}

00:32:55.850 --> 00:32:58.170
<v Speaker 1>So by chance let's say this one is wrong.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:58.170 --> 00:32:58.850
<v Speaker 1>This one is wrong.

NOTE CONF {"raw":[100,100,100,100]}

00:32:58.850 --> 00:32:59.490
<v Speaker 1>This one is wrong.

NOTE CONF {"raw":[100,100,100,100]}

00:32:59.490 --> 00:33:00.530
<v Speaker 1>This one is right again.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:01.290 --> 00:33:04.050
<v Speaker 1>And now it would be very handy if we had

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:04.050 --> 00:33:06.730
<v Speaker 1>a way of changing our weights so that the target

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,100]}

00:33:06.730 --> 00:33:09.800
<v Speaker 1>becomes more like the output becomes more like the target.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:10.720 --> 00:33:11.200
<v Speaker 1>Okay.

NOTE CONF {"raw":[69]}

00:33:11.720 --> 00:33:13.040
<v Speaker 1>And this is what we're going to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:33:13.120 --> 00:33:15.760
<v Speaker 1>So for each of these examples we're going to change

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:15.760 --> 00:33:19.160
<v Speaker 1>our weights so that the output with the current weights

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:19.280 --> 00:33:23.320
<v Speaker 1>becomes more like the target t for this particular example.

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100,100]}

00:33:24.760 --> 00:33:26.800
<v Speaker 1>And this is called the perceptron learning rule.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:33:27.360 --> 00:33:30.240
<v Speaker 1>And it's only slightly more complicated than what I've said.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,95,98]}

00:33:30.320 --> 00:33:33.760
<v Speaker 1>So we adjust the weights so that oh this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:33.760 --> 00:33:35.240
<v Speaker 1>the output for the current weights.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:35.640 --> 00:33:39.360
<v Speaker 1>Moves closer to T, the target, the desired or correct

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:39.360 --> 00:33:39.920
<v Speaker 1>output.

NOTE CONF {"raw":[100]}

00:33:41.080 --> 00:33:44.920
<v Speaker 1>And for a weight w we adjust it.

NOTE CONF {"raw":[100,100,68,100,96,70,48,48]}

00:33:44.920 --> 00:33:49.160
<v Speaker 1>So this little arrow means update the weights to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:49.400 --> 00:33:54.640
<v Speaker 1>from the previous value plus a difference delta w I

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,52,52]}

00:33:55.520 --> 00:33:55.800
<v Speaker 1>okay.

NOTE CONF {"raw":[98]}

00:33:55.840 --> 00:33:57.840
<v Speaker 1>And so how do we compute this difference.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:33:58.000 --> 00:34:01.920
<v Speaker 1>Delta we we take the difference between the target and

NOTE CONF {"raw":[100,63,100,100,100,100,100,100,100,100]}

00:34:01.920 --> 00:34:05.760
<v Speaker 1>the output and multiply it by a constant called eta

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:34:06.380 --> 00:34:11.020
<v Speaker 1>and by the input at that point she.

NOTE CONF {"raw":[100,100,100,100,100,100,100,90]}

00:34:12.300 --> 00:34:15.580
<v Speaker 1>Okay, so the intuition is if this difference is big,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:15.980 --> 00:34:17.540
<v Speaker 1>then our delta will be big.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:34:18.820 --> 00:34:21.780
<v Speaker 1>If this difference is small or maybe zero, then our

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:21.780 --> 00:34:23.179
<v Speaker 1>delta will be zero, right?

NOTE CONF {"raw":[100,100,100,100,99]}

00:34:23.220 --> 00:34:26.940
<v Speaker 1>If the target is the same as the output, like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:26.980 --> 00:34:30.899
<v Speaker 1>in this lucky case, for example, then we don't need

NOTE CONF {"raw":[100,100,94,100,100,100,100,100,100,100]}

00:34:30.899 --> 00:34:31.940
<v Speaker 1>to do an update, right?

NOTE CONF {"raw":[100,100,100,100,97]}

00:34:31.980 --> 00:34:32.820
<v Speaker 1>Everything is fine.

NOTE CONF {"raw":[100,100,100]}

00:34:33.020 --> 00:34:34.820
<v Speaker 1>We can move on to the next example.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:34:35.700 --> 00:34:36.060
<v Speaker 1>Right.

NOTE CONF {"raw":[95]}

00:34:36.100 --> 00:34:37.659
<v Speaker 1>And then what are the other parts.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:34:37.659 --> 00:34:40.220
<v Speaker 1>So here the difference this is the really the important

NOTE CONF {"raw":[100,100,58,100,100,100,88,100,100,100]}

00:34:40.220 --> 00:34:40.540
<v Speaker 1>bit.

NOTE CONF {"raw":[100]}

00:34:41.060 --> 00:34:44.820
<v Speaker 1>But the ETA is what's called the learning rate.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:34:44.820 --> 00:34:46.980
<v Speaker 1>This is a constant that you set.

NOTE CONF {"raw":[100,100,95,100,100,100,94]}

00:34:47.860 --> 00:34:49.980
<v Speaker 1>And it tells you basically how fast you change the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:49.980 --> 00:34:51.580
<v Speaker 1>weights, how fast you learn.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:52.860 --> 00:34:53.780
<v Speaker 1>This is the ETA.

NOTE CONF {"raw":[100,100,100,100]}

00:34:53.780 --> 00:34:55.820
<v Speaker 1>And then why is there the she.

NOTE CONF {"raw":[100,100,93,100,100,100,95]}

00:34:56.500 --> 00:34:57.540
<v Speaker 1>What do people think?

NOTE CONF {"raw":[100,100,100,100]}

00:34:57.780 --> 00:34:59.980
<v Speaker 1>Why does it make sense to also multiply by x

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:59.980 --> 00:35:04.280
<v Speaker 1>I x I is the input right at this point.

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:35:08.320 --> 00:35:13.160
<v Speaker 1>Right here it's all binary and but intuitively, if the

NOTE CONF {"raw":[30,91,100,100,100,93,100,100,100,100]}

00:35:13.160 --> 00:35:17.640
<v Speaker 1>input is very big, then we also want to make

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:17.640 --> 00:35:24.240
<v Speaker 1>a big change because the the difference here right is

NOTE CONF {"raw":[100,100,100,100,92,100,100,100,97,100]}

00:35:24.240 --> 00:35:25.760
<v Speaker 1>caused by the input of course.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:26.120 --> 00:35:27.840
<v Speaker 1>And if the input is big then there will be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:27.840 --> 00:35:28.720
<v Speaker 1>a bigger difference.

NOTE CONF {"raw":[100,100,100]}

00:35:28.720 --> 00:35:31.560
<v Speaker 1>So we also need to reduce or increase the weight

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:31.560 --> 00:35:31.840
<v Speaker 1>more.

NOTE CONF {"raw":[100]}

00:35:33.040 --> 00:35:36.440
<v Speaker 1>And as we'll see tomorrow, this has to do with

NOTE CONF {"raw":[100,100,99,100,100,100,100,100,100,100]}

00:35:36.480 --> 00:35:38.880
<v Speaker 1>how the error function is defined for the perceptron in

NOTE CONF {"raw":[100,100,97,100,100,100,100,100,100,100]}

00:35:38.880 --> 00:35:39.680
<v Speaker 1>the general case.

NOTE CONF {"raw":[100,100,100]}

00:35:40.120 --> 00:35:43.120
<v Speaker 1>But here we just assume that for big inputs we

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:35:43.120 --> 00:35:44.080
<v Speaker 1>want to make big changes.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:44.080 --> 00:35:47.800
<v Speaker 1>For small inputs we want to make small changes okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:47.840 --> 00:35:48.400
<v Speaker 1>And that's it.

NOTE CONF {"raw":[100,100,100]}

00:35:48.400 --> 00:35:51.640
<v Speaker 1>That's that's really that's all the that's the magic sauce.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,77]}

00:35:53.600 --> 00:35:56.840
<v Speaker 1>Um, let's look at an example and I hope I

NOTE CONF {"raw":[99,100,100,100,77,100,100,100,100,100]}

00:35:56.840 --> 00:35:57.640
<v Speaker 1>still have time.

NOTE CONF {"raw":[100,100,100]}

00:35:57.920 --> 00:35:58.440
<v Speaker 1>Sorry.

NOTE CONF {"raw":[100]}

00:35:59.200 --> 00:36:00.400
<v Speaker 1>This room doesn't have internet.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:00.400 --> 00:36:02.080
<v Speaker 1>Doesn't have a clock either.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:03.470 --> 00:36:07.150
<v Speaker 1>Let's go through this example and then, uh, I'll stop

NOTE CONF {"raw":[100,100,100,100,100,100,100,74,100,100]}

00:36:07.150 --> 00:36:08.950
<v Speaker 1>for today and we'll continue tomorrow.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:09.310 --> 00:36:09.550
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:36:09.590 --> 00:36:10.670
<v Speaker 1>So this is our learning rule.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:10.910 --> 00:36:12.030
<v Speaker 1>It's the same rule from here.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:13.550 --> 00:36:18.470
<v Speaker 1>Um, our update for we we take the current Y

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,29]}

00:36:18.470 --> 00:36:21.230
<v Speaker 1>and add a delta y.

NOTE CONF {"raw":[100,100,98,100,66]}

00:36:21.230 --> 00:36:24.230
<v Speaker 1>And this delta y is the difference between the target

NOTE CONF {"raw":[100,100,100,94,100,100,100,100,100,100]}

00:36:24.230 --> 00:36:27.230
<v Speaker 1>and the output times the input and times the learning

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:27.230 --> 00:36:27.510
<v Speaker 1>rate.

NOTE CONF {"raw":[100]}

00:36:27.550 --> 00:36:30.510
<v Speaker 1>Let's assume the output is one and the target is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:30.510 --> 00:36:30.830
<v Speaker 1>one.

NOTE CONF {"raw":[100]}

00:36:31.230 --> 00:36:33.950
<v Speaker 1>And in the second case the output is zero and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:33.950 --> 00:36:35.030
<v Speaker 1>the target is one.

NOTE CONF {"raw":[100,100,100,100]}

00:36:35.590 --> 00:36:38.910
<v Speaker 1>So here first case what should happen.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:39.470 --> 00:36:41.310
<v Speaker 1>What do people think output is one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:41.310 --> 00:36:42.070
<v Speaker 1>Target is one.

NOTE CONF {"raw":[100,100,100]}

00:36:43.150 --> 00:36:44.110
<v Speaker 1>Nothing should happen.

NOTE CONF {"raw":[100,100,100]}

00:36:44.110 --> 00:36:44.750
<v Speaker 1>Exactly.

NOTE CONF {"raw":[100]}

00:36:46.070 --> 00:36:48.030
<v Speaker 1>So let's see if that pans out.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:48.030 --> 00:36:50.910
<v Speaker 1>So t minus always one minus one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:51.350 --> 00:36:52.750
<v Speaker 1>So that is zero of course.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:52.750 --> 00:36:53.910
<v Speaker 1>So the whole term becomes zero.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:53.950 --> 00:36:57.670
<v Speaker 1>We don't care about eta and x I output the

NOTE CONF {"raw":[100,100,100,100,100,100,64,64,93,95]}

00:36:57.670 --> 00:36:58.550
<v Speaker 1>delta zero.

NOTE CONF {"raw":[100,100]}

00:36:58.550 --> 00:37:00.470
<v Speaker 1>So the update is no update.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:00.870 --> 00:37:02.650
<v Speaker 1>That means this example is correct.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:02.770 --> 00:37:05.130
<v Speaker 1>We don't want to change the weights here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:37:05.170 --> 00:37:06.010
<v Speaker 1>Of course it's incorrect.

NOTE CONF {"raw":[100,100,100,100]}

00:37:06.210 --> 00:37:07.970
<v Speaker 1>The output is zero and the target is one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:37:08.210 --> 00:37:11.490
<v Speaker 1>So we take target minus output.

NOTE CONF {"raw":[100,100,100,74,100,100]}

00:37:11.490 --> 00:37:12.250
<v Speaker 1>That's one.

NOTE CONF {"raw":[100,100]}

00:37:12.770 --> 00:37:17.610
<v Speaker 1>And then we multiply with eta and with x.

NOTE CONF {"raw":[100,100,100,100,100,98,100,100,97]}

00:37:17.730 --> 00:37:19.690
<v Speaker 1>So this is one.

NOTE CONF {"raw":[100,100,100,100]}

00:37:19.690 --> 00:37:22.450
<v Speaker 1>So the delta will be eta x.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:37:22.810 --> 00:37:24.890
<v Speaker 1>So depending on the learning rate let's say the learning

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:24.890 --> 00:37:27.890
<v Speaker 1>rate is 0.1 and the input is one.

NOTE CONF {"raw":[100,100,98,100,100,100,100,100]}

00:37:28.170 --> 00:37:32.210
<v Speaker 1>Then this would be a change of 0.50.1 okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,45,100]}

00:37:33.130 --> 00:37:36.210
<v Speaker 1>And then um yeah.

NOTE CONF {"raw":[100,100,94,88]}

00:37:36.210 --> 00:37:40.250
<v Speaker 1>So learning rate ETA is always positive and controls how

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:40.250 --> 00:37:41.170
<v Speaker 1>big the changes are.

NOTE CONF {"raw":[100,100,100,100]}

00:37:41.290 --> 00:37:44.410
<v Speaker 1>And if the input is zero and the weight is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:44.410 --> 00:37:46.490
<v Speaker 1>bigger than zero and the weight is bigger than zero,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:46.770 --> 00:37:51.930
<v Speaker 1>then we increase the weight so that w times x

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:51.930 --> 00:37:53.450
<v Speaker 1>becomes larger than theta right.

NOTE CONF {"raw":[100,100,100,100,91]}

00:37:53.490 --> 00:37:55.450
<v Speaker 1>Remember we're trying to generate an output.

NOTE CONF {"raw":[100,94,100,100,100,100,100]}

00:37:56.050 --> 00:37:59.370
<v Speaker 1>If they're smaller than zero both of them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:37:59.790 --> 00:38:01.990
<v Speaker 1>Then we reduce the weight.

NOTE CONF {"raw":[100,100,100,100,83]}

00:38:03.550 --> 00:38:05.630
<v Speaker 1>So we have assumed binary inputs.

NOTE CONF {"raw":[100,100,100,100,100,91]}

00:38:05.630 --> 00:38:07.350
<v Speaker 1>So x can't be smaller than zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:07.350 --> 00:38:09.030
<v Speaker 1>But the weight can be smaller than zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:38:09.830 --> 00:38:11.670
<v Speaker 1>And so the weight reduces.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:12.910 --> 00:38:16.470
<v Speaker 1>If they're both zero then sorry.

NOTE CONF {"raw":[100,100,100,100,100,97]}

00:38:16.510 --> 00:38:18.550
<v Speaker 1>If yeah if they're both zero then the output will

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:38:18.550 --> 00:38:19.390
<v Speaker 1>be zero as well.

NOTE CONF {"raw":[100,100,100,100]}

00:38:20.670 --> 00:38:21.030
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:38:21.070 --> 00:38:22.830
<v Speaker 1>And so that's really it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:22.950 --> 00:38:25.110
<v Speaker 1>And we just do this lots and lots of times

NOTE CONF {"raw":[100,100,100,100,75,100,100,100,100,100]}

00:38:25.150 --> 00:38:25.390
<v Speaker 1>right.

NOTE CONF {"raw":[96]}

00:38:25.430 --> 00:38:28.270
<v Speaker 1>So we do this for all our examples.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:38:28.270 --> 00:38:30.390
<v Speaker 1>So here we do this for all the six examples.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:30.990 --> 00:38:33.950
<v Speaker 1>Update our weights and then we do it again.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:38:34.510 --> 00:38:36.070
<v Speaker 1>And we get more weight updates.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:36.230 --> 00:38:36.390
<v Speaker 1>Right.

NOTE CONF {"raw":[94]}

00:38:36.430 --> 00:38:38.430
<v Speaker 1>Because we only make small changes.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:38.470 --> 00:38:43.630
<v Speaker 1>ETA is often a very small number 0.10.01 and so

NOTE CONF {"raw":[100,100,100,100,100,100,100,92,100,100]}

00:38:43.630 --> 00:38:43.830
<v Speaker 1>on.

NOTE CONF {"raw":[100]}

00:38:43.910 --> 00:38:46.590
<v Speaker 1>So we only make small changes to the weight each

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:46.590 --> 00:38:46.990
<v Speaker 1>time.

NOTE CONF {"raw":[100]}

00:38:47.830 --> 00:38:49.910
<v Speaker 1>And we do this again and again.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:50.350 --> 00:38:53.550
<v Speaker 1>Each pass through our set of examples is called an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:53.550 --> 00:38:53.950
<v Speaker 1>epoch.

NOTE CONF {"raw":[100]}

00:38:54.470 --> 00:38:58.860
<v Speaker 1>So we do lots and lots of epochs until there's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:58.860 --> 00:38:59.780
<v Speaker 1>no more changes.

NOTE CONF {"raw":[100,100,100]}

00:38:59.900 --> 00:39:00.660
<v Speaker 1>Then we stop.

NOTE CONF {"raw":[97,100,100]}

00:39:01.740 --> 00:39:01.980
<v Speaker 1>Okay.

NOTE CONF {"raw":[99]}

00:39:02.020 --> 00:39:05.940
<v Speaker 1>When the weights stop changing, then we can't learn anything

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:39:05.940 --> 00:39:06.420
<v Speaker 1>anymore.

NOTE CONF {"raw":[100]}

00:39:06.740 --> 00:39:09.340
<v Speaker 1>And hopefully we've learned the target function and we stop.

NOTE CONF {"raw":[100,100,100,87,100,100,100,100,100,100]}

00:39:09.940 --> 00:39:11.860
<v Speaker 1>And you will get an opportunity to work through this

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100,100]}

00:39:11.860 --> 00:39:13.180
<v Speaker 1>in the tutorial next week.

NOTE CONF {"raw":[100,85,100,100,100]}

00:39:13.380 --> 00:39:18.260
<v Speaker 1>Actually, I'm out of time, but are there any quick

NOTE CONF {"raw":[74,100,100,100,100,100,100,100,100,100]}

00:39:18.260 --> 00:39:18.900
<v Speaker 1>questions?

NOTE CONF {"raw":[100]}

00:39:18.940 --> 00:39:19.500
<v Speaker 1>Yes, please.

NOTE CONF {"raw":[100,100]}

00:39:20.740 --> 00:39:22.260
<v Speaker 2>How is the learning rate assignment?

NOTE CONF {"raw":[100,89,100,100,100,42]}

00:39:22.980 --> 00:39:23.340
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:39:23.380 --> 00:39:24.500
<v Speaker 1>No it's a good question.

NOTE CONF {"raw":[100,88,100,100,100]}

00:39:24.500 --> 00:39:26.220
<v Speaker 1>So the learning rate I didn't say anything about the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:26.220 --> 00:39:26.860
<v Speaker 1>learning rate.

NOTE CONF {"raw":[100,100]}

00:39:28.140 --> 00:39:31.940
<v Speaker 1>It's actually pretty complicated to decide the learning rate.

NOTE CONF {"raw":[100,100,100,100,100,98,100,100,100]}

00:39:31.940 --> 00:39:34.140
<v Speaker 1>And people often use variable learning rates.

NOTE CONF {"raw":[100,100,100,100,100,100,98]}

00:39:34.140 --> 00:39:37.300
<v Speaker 1>So you use a high learning rate at the beginning

NOTE CONF {"raw":[100,100,100,100,93,100,100,100,100,100]}

00:39:37.300 --> 00:39:39.020
<v Speaker 1>of for the first few epochs.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:39.020 --> 00:39:40.820
<v Speaker 1>And then you reduce it later on.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:39:41.540 --> 00:39:44.260
<v Speaker 1>There's whole schedules that you use and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:39:45.820 --> 00:39:48.820
<v Speaker 1>You want to use something fairly small in relation to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:48.860 --> 00:39:49.980
<v Speaker 1>your weights and your inputs.

NOTE CONF {"raw":[100,100,88,100,100]}

00:39:49.980 --> 00:39:53.500
<v Speaker 1>So something like 0.5 for this or maybe even 0.1

NOTE CONF {"raw":[100,100,100,92,100,100,100,100,100,90]}

00:39:53.700 --> 00:39:55.260
<v Speaker 1>for simple examples like this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:55.700 --> 00:39:58.800
<v Speaker 1>But yeah, it's basically empirically determined.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:59.120 --> 00:40:00.680
<v Speaker 1>There isn't any maths behind it.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:02.680 --> 00:40:04.160
<v Speaker 1>Okay, that's all we have time for.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:40:04.680 --> 00:40:05.280
<v Speaker 1>Thank you.

NOTE CONF {"raw":[100,100]}
