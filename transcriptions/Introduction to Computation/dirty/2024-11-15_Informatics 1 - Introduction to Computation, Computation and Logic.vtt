WEBVTT

00:00:43.890 --> 00:00:44.430
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:00:44.430 --> 00:00:45.660
<v Speaker 0>Good afternoon everyone.

NOTE CONF {"raw":[100,100,100]}

00:00:50.700 --> 00:00:55.740
<v Speaker 0>So yesterday we started talking about finite automata, finite state

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:55.740 --> 00:01:02.860
<v Speaker 0>machines and drew some diagrams and introduce some diagrammatic notation,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:02.980 --> 00:01:05.710
<v Speaker 0>and at some point introduced a few symbols.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:01:06.070 --> 00:01:09.160
<v Speaker 0>I'm about to throw a lot more symbols at you,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:09.160 --> 00:01:12.610
<v Speaker 0>because we're going to try to do something vaguely mathematical.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:12.610 --> 00:01:15.370
<v Speaker 0>And in order to do maths, we need symbols.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:01:17.110 --> 00:01:19.480
<v Speaker 0>Did anybody have questions from yesterday?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:01:19.480 --> 00:01:25.000
<v Speaker 0>Things they would like explained again or differently?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:01:26.530 --> 00:01:27.010
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:01:30.370 --> 00:01:33.070
<v Speaker 0>So could everybody else please be quiet so I can

NOTE CONF {"raw":[52,100,100,100,100,100,100,100,100,100]}

00:01:33.070 --> 00:01:34.330
<v Speaker 0>hear people speak here?

NOTE CONF {"raw":[100,100,100,90]}

00:01:41.260 --> 00:01:44.860
<v Speaker 0>Um, so the question about ways to think about this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:46.000 --> 00:01:48.340
<v Speaker 1>What about how long is it?

NOTE CONF {"raw":[95,100,100,100,95,99]}

00:01:49.060 --> 00:01:51.220
<v Speaker 0>Oh, how long can a sentence be in English?

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100]}

00:01:51.220 --> 00:01:52.510
<v Speaker 0>You mean in the digression?

NOTE CONF {"raw":[100,100,100,100,100]}

00:01:52.510 --> 00:01:53.020
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:01:54.130 --> 00:01:57.940
<v Speaker 1>Would it be acceptable to say somebody?

NOTE CONF {"raw":[100,100,100,100,100,100,83]}

00:02:00.520 --> 00:02:04.390
<v Speaker 0>Um, so that's a much more stringent definition that was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,52,100]}

00:02:04.390 --> 00:02:06.550
<v Speaker 0>being suggested by some people yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:02:07.570 --> 00:02:10.509
<v Speaker 0>Can a sentence last longer than anybody can pay attention

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:10.509 --> 00:02:11.140
<v Speaker 0>to it?

NOTE CONF {"raw":[100,100]}

00:02:11.680 --> 00:02:14.350
<v Speaker 0>Um, I mean, there are no right or wrong answers,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:14.350 --> 00:02:14.710
<v Speaker 0>are there?

NOTE CONF {"raw":[100,100]}

00:02:14.710 --> 00:02:17.080
<v Speaker 0>This is a matter of opinion about what you think

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:17.680 --> 00:02:19.330
<v Speaker 0>a reasonable definition is.

NOTE CONF {"raw":[100,100,100,100]}

00:02:20.650 --> 00:02:23.650
<v Speaker 0>Um, so the subtext behind all that stuff was really,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:23.650 --> 00:02:27.340
<v Speaker 0>what's the difference between doing mathematics, where we just define

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:27.340 --> 00:02:31.510
<v Speaker 0>things to be whatever we want and doing something more

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:31.510 --> 00:02:35.200
<v Speaker 0>human, where we want things that are vaguely sensible.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:36.280 --> 00:02:39.400
<v Speaker 0>You might say that the same applies to other things

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:39.400 --> 00:02:40.720
<v Speaker 0>in computing.

NOTE CONF {"raw":[100,100]}

00:02:42.640 --> 00:02:45.280
<v Speaker 0>Um, any questions about the automata stuff?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:48.010 --> 00:02:50.020
<v Speaker 0>Any notations that were unclear?

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:50.050 --> 00:02:50.740
<v Speaker 0>Good.

NOTE CONF {"raw":[100]}

00:02:52.480 --> 00:02:56.920
<v Speaker 0>Um, so yesterday I think we finished off with this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:56.930 --> 00:02:57.950
<v Speaker 0>little diagram.

NOTE CONF {"raw":[100,100]}

00:02:58.220 --> 00:03:00.770
<v Speaker 0>Now I want to get symbolic because I want to

NOTE CONF {"raw":[100,100,100,100,100,88,100,100,100,100]}

00:03:00.770 --> 00:03:03.860
<v Speaker 0>build that automaton from simpler automata.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:04.490 --> 00:03:06.170
<v Speaker 0>And in order to do that, I have to be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:06.170 --> 00:03:10.190
<v Speaker 0>able to define the operations I'm building on automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:03:11.090 --> 00:03:13.910
<v Speaker 0>And that means, inevitably, notation.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:13.910 --> 00:03:16.250
<v Speaker 0>So a lot of the notation I'm going to introduce

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:16.250 --> 00:03:20.390
<v Speaker 0>now is pretty standard throughout much of theoretical computer science

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:20.390 --> 00:03:21.950
<v Speaker 0>and indeed mathematics.

NOTE CONF {"raw":[100,100,100]}

00:03:22.340 --> 00:03:25.190
<v Speaker 0>So if this is the first time you've seen it,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:26.570 --> 00:03:29.300
<v Speaker 0>don't think of it as a complete waste.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:03:29.300 --> 00:03:30.710
<v Speaker 0>It's not just for this course.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:30.710 --> 00:03:32.690
<v Speaker 0>You will see these notations again.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:34.010 --> 00:03:38.120
<v Speaker 0>And you need to develop a facility in reading notations

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:38.120 --> 00:03:39.530
<v Speaker 0>and understanding.

NOTE CONF {"raw":[100,100]}

00:03:39.560 --> 00:03:43.460
<v Speaker 0>People should always define notations, but in practice they don't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:43.460 --> 00:03:48.380
<v Speaker 0>because very common notations are often taken as understood.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:03:48.380 --> 00:03:51.290
<v Speaker 0>Just as we don't define times and plus most of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:51.290 --> 00:03:51.920
<v Speaker 0>the time.

NOTE CONF {"raw":[100,100]}

00:03:53.720 --> 00:03:58.740
<v Speaker 0>Um, so suppose I've got a set sigma.

NOTE CONF {"raw":[81,100,100,100,100,100,100,100]}

00:03:58.740 --> 00:04:01.560
<v Speaker 0>So if you remember from yesterday, I was using sigma

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:01.560 --> 00:04:05.220
<v Speaker 0>to be the name of the input alphabet, the labels

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:05.220 --> 00:04:07.770
<v Speaker 0>that the machine reads from the outside world.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:09.480 --> 00:04:11.790
<v Speaker 0>So if I've got any set sigma, then when I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:11.790 --> 00:04:16.590
<v Speaker 0>write Sigma star, I mean the set of strings where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:16.590 --> 00:04:19.829
<v Speaker 0>the letters of the strings are that alphabet.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:20.160 --> 00:04:23.490
<v Speaker 0>And by strings here I mean strings, as you know,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:23.490 --> 00:04:24.810
<v Speaker 0>strings in Haskell.

NOTE CONF {"raw":[100,100,100]}

00:04:25.470 --> 00:04:28.110
<v Speaker 0>Um, I suppose in Haskell they're technically lists.

NOTE CONF {"raw":[55,100,100,100,100,100,100,100]}

00:04:28.110 --> 00:04:31.260
<v Speaker 0>In maths, we don't think of them as lists, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:31.260 --> 00:04:35.670
<v Speaker 0>a sequence of things in sigma is a string over

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:35.670 --> 00:04:36.180
<v Speaker 0>sigma.

NOTE CONF {"raw":[100]}

00:04:37.500 --> 00:04:40.830
<v Speaker 0>This little star here is called the cleaning star.

NOTE CONF {"raw":[100,100,100,100,100,100,100,48,100]}

00:04:40.860 --> 00:04:43.530
<v Speaker 0>You might remember that cleaner was the guy on my

NOTE CONF {"raw":[100,100,100,100,95,100,100,100,100,100]}

00:04:43.530 --> 00:04:44.640
<v Speaker 0>title slide.

NOTE CONF {"raw":[100,100]}

00:04:44.880 --> 00:04:49.410
<v Speaker 0>So this is one of many notations he introduced.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:04:51.450 --> 00:04:55.110
<v Speaker 0>Um, I need often to talk about the empty string,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:55.110 --> 00:04:59.610
<v Speaker 0>because it's the simplest string in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:02.250 --> 00:05:05.220
<v Speaker 0>You have multiple ways to write the empty string, but.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:07.470 --> 00:05:09.420
<v Speaker 0>A pair of double quotes would do it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:09.420 --> 00:05:12.030
<v Speaker 0>Or even just the empty list, because in Haskell, strings

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:12.030 --> 00:05:12.840
<v Speaker 0>are lists.

NOTE CONF {"raw":[100,100]}

00:05:14.400 --> 00:05:17.760
<v Speaker 0>Typically, in theoretical work we tend to use the letter

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:17.760 --> 00:05:21.540
<v Speaker 0>epsilon Greek epsilon for the empty string.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:21.960 --> 00:05:25.440
<v Speaker 0>I don't think there's any more profound reason for this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:25.440 --> 00:05:26.160
<v Speaker 0>than that.

NOTE CONF {"raw":[100,97]}

00:05:26.160 --> 00:05:28.590
<v Speaker 0>Epsilon begins with E, and so does empty.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:29.790 --> 00:05:32.880
<v Speaker 0>Um, an epsilon is used for little things a lot.

NOTE CONF {"raw":[62,99,100,100,100,100,100,100,100,100]}

00:05:34.890 --> 00:05:36.810
<v Speaker 0>Um, what do we do with strings?

NOTE CONF {"raw":[98,100,100,100,100,100,100]}

00:05:36.930 --> 00:05:39.600
<v Speaker 0>You've done a bunch of things with strings and indeed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:39.600 --> 00:05:41.010
<v Speaker 0>lists in Haskell.

NOTE CONF {"raw":[100,100,100]}

00:05:41.010 --> 00:05:43.650
<v Speaker 0>One of the things you've done with them is concatenate

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:43.650 --> 00:05:44.790
<v Speaker 0>two strings.

NOTE CONF {"raw":[100,100]}

00:05:45.300 --> 00:05:47.820
<v Speaker 0>This is something, of course we do in text processing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:47.820 --> 00:05:48.870
<v Speaker 0>all the time.

NOTE CONF {"raw":[100,100,100]}

00:05:50.040 --> 00:05:52.740
<v Speaker 0>There are several ways of concatenating strings.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:52.740 --> 00:05:54.910
<v Speaker 0>You might stick a letter on the beginning, or you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:54.910 --> 00:05:56.560
<v Speaker 0>might put two strings together.

NOTE CONF {"raw":[100,100,100,100,100]}

00:05:56.830 --> 00:06:00.400
<v Speaker 0>So if S is some string and I want to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:00.400 --> 00:06:03.460
<v Speaker 0>add a letter to the beginning, then I just write

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:03.460 --> 00:06:04.420
<v Speaker 0>x s.

NOTE CONF {"raw":[100,77]}

00:06:06.190 --> 00:06:10.990
<v Speaker 0>Um, I realise at this point that because we've also

NOTE CONF {"raw":[100,100,82,100,100,100,100,100,100,100]}

00:06:10.990 --> 00:06:13.930
<v Speaker 0>been teaching you Haskell with the notation that Haskell avoids,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,84]}

00:06:13.930 --> 00:06:16.480
<v Speaker 0>like this can get confusing.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:16.690 --> 00:06:17.830
<v Speaker 0>This is maths.

NOTE CONF {"raw":[100,100,80]}

00:06:17.830 --> 00:06:20.860
<v Speaker 0>So this is two separate variables x and s.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:06:21.010 --> 00:06:23.290
<v Speaker 0>This is not x is as you would write in

NOTE CONF {"raw":[100,100,100,45,45,100,100,100,100,100]}

00:06:23.290 --> 00:06:24.010
<v Speaker 0>Haskell.

NOTE CONF {"raw":[100]}

00:06:24.460 --> 00:06:24.700
<v Speaker 0>Okay.

NOTE CONF {"raw":[91]}

00:06:24.700 --> 00:06:27.490
<v Speaker 0>So when I'm doing maths variables are single letters.

NOTE CONF {"raw":[100,100,100,100,100,100,47,100,100]}

00:06:27.490 --> 00:06:30.610
<v Speaker 0>And unless they aren't and it will be obvious if

NOTE CONF {"raw":[98,71,100,100,100,100,100,100,100,100]}

00:06:30.610 --> 00:06:31.240
<v Speaker 0>they aren't.

NOTE CONF {"raw":[100,100]}

00:06:32.050 --> 00:06:34.120
<v Speaker 0>So if I write x s I mean the letter

NOTE CONF {"raw":[100,100,100,100,100,72,100,100,100,100]}

00:06:34.120 --> 00:06:37.030
<v Speaker 0>s followed by the letters in the string s.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,95]}

00:06:37.030 --> 00:06:40.300
<v Speaker 0>I could put s on the end as well.

NOTE CONF {"raw":[52,100,100,100,100,100,100,100,100]}

00:06:40.300 --> 00:06:41.050
<v Speaker 0>These are strings.

NOTE CONF {"raw":[100,100,100]}

00:06:41.050 --> 00:06:41.830
<v Speaker 0>They're not lists.

NOTE CONF {"raw":[100,100,100]}

00:06:41.830 --> 00:06:42.850
<v Speaker 0>There's no cons.

NOTE CONF {"raw":[100,100,100]}

00:06:42.850 --> 00:06:45.490
<v Speaker 0>I don't have to worry about colons and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:47.800 --> 00:06:52.540
<v Speaker 0>Then I want to talk about the transition function.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:06:52.690 --> 00:06:56.440
<v Speaker 0>So yesterday I said that we could describe the arrows

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:56.440 --> 00:06:59.020
<v Speaker 0>in a finite automaton by a function.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:59.350 --> 00:07:02.740
<v Speaker 0>And the function was called delta because transitions are changes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:02.740 --> 00:07:05.020
<v Speaker 0>and delta means changes in calculus.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:05.620 --> 00:07:09.520
<v Speaker 0>And the transition function takes the state you're at and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:09.520 --> 00:07:12.160
<v Speaker 0>the letter you're seeing and tells you where to go

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:12.160 --> 00:07:12.850
<v Speaker 0>next.

NOTE CONF {"raw":[100]}

00:07:14.860 --> 00:07:18.640
<v Speaker 0>It is often useful to talk about what happens when

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:18.640 --> 00:07:20.590
<v Speaker 0>you read several letters.

NOTE CONF {"raw":[100,100,100,100]}

00:07:20.590 --> 00:07:22.960
<v Speaker 0>So this function tells you what to do when you've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,97]}

00:07:22.960 --> 00:07:24.010
<v Speaker 0>read one letter.

NOTE CONF {"raw":[100,100,100]}

00:07:24.160 --> 00:07:28.960
<v Speaker 0>We can define a function called Delta star, which tells

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:28.960 --> 00:07:32.170
<v Speaker 0>you where you end up after reading several letters.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:07:33.340 --> 00:07:37.690
<v Speaker 0>So Delta Star takes the state you're currently in, takes

NOTE CONF {"raw":[100,100,100,100,100,100,85,100,100,100]}

00:07:37.690 --> 00:07:41.470
<v Speaker 0>a string of input letters, and tells you what state

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:41.470 --> 00:07:44.950
<v Speaker 0>you'll end up in after reading the string of input

NOTE CONF {"raw":[77,100,100,100,100,100,100,100,100,100]}

00:07:44.950 --> 00:07:45.640
<v Speaker 0>letters.

NOTE CONF {"raw":[100]}

00:07:47.050 --> 00:07:51.140
<v Speaker 0>That's easily defined by recursion if you're all familiar with

NOTE CONF {"raw":[100,100,100,100,100,91,100,100,100,100]}

00:07:51.140 --> 00:07:52.250
<v Speaker 0>recursion now.

NOTE CONF {"raw":[100,95]}

00:07:52.640 --> 00:07:53.930
<v Speaker 0>How do we define it?

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:53.960 --> 00:07:56.150
<v Speaker 0>Well, if we're in a state and we read the

NOTE CONF {"raw":[100,100,100,100,90,100,100,100,100,100]}

00:07:56.150 --> 00:07:58.670
<v Speaker 0>empty string, in other words, we haven't done anything at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:58.670 --> 00:08:03.170
<v Speaker 0>all yet, then we stay where we are and this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:03.170 --> 00:08:05.420
<v Speaker 0>is staying where we are not moving to where we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:05.420 --> 00:08:05.780
<v Speaker 0>are.

NOTE CONF {"raw":[100]}

00:08:07.100 --> 00:08:12.620
<v Speaker 0>If we're in a state and we read a letter

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:12.620 --> 00:08:16.610
<v Speaker 0>X, and then we have some more input to read,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:16.790 --> 00:08:19.700
<v Speaker 0>then we just move to the state that X tells

NOTE CONF {"raw":[100,100,100,76,99,100,100,100,100,100]}

00:08:19.700 --> 00:08:20.570
<v Speaker 0>us to move to.

NOTE CONF {"raw":[100,100,100,100]}

00:08:20.570 --> 00:08:25.220
<v Speaker 0>So that's delta q x go from q two the

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,52,100]}

00:08:25.220 --> 00:08:26.960
<v Speaker 0>state that x takes us to.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:08:27.170 --> 00:08:30.770
<v Speaker 0>And then we recursively apply the string transition function to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:30.770 --> 00:08:32.060
<v Speaker 0>the remaining input.

NOTE CONF {"raw":[100,100,100]}

00:08:33.409 --> 00:08:36.530
<v Speaker 0>So this should be nice and familiar to you.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:08:36.560 --> 00:08:39.110
<v Speaker 0>You could implement this in Haskell very easily indeed.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:08:39.110 --> 00:08:41.450
<v Speaker 0>You will implement it in Haskell very easily.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:08:41.450 --> 00:08:43.250
<v Speaker 0>Some of you probably already have.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:08:44.300 --> 00:08:47.210
<v Speaker 0>Um, but it's a piece of notation that we use

NOTE CONF {"raw":[72,100,100,100,100,100,100,100,100,100]}

00:08:47.210 --> 00:08:52.200
<v Speaker 0>in order to argue about finite automata and ultimately do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:52.200 --> 00:08:53.400
<v Speaker 0>proofs about them.

NOTE CONF {"raw":[100,100,100]}

00:08:56.070 --> 00:08:59.670
<v Speaker 0>Um, any questions about these definitions so far?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:08:59.700 --> 00:09:02.880
<v Speaker 0>Is there any notation in there that I haven't explained?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:05.640 --> 00:09:07.650
<v Speaker 0>We're getting to another bit of the course where there's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:07.650 --> 00:09:10.230
<v Speaker 0>a risk of me using a notation, because I know

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,100]}

00:09:10.230 --> 00:09:13.530
<v Speaker 0>it and have forgotten that you might not have seen

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:13.530 --> 00:09:13.680
<v Speaker 0>it.

NOTE CONF {"raw":[100]}

00:09:13.680 --> 00:09:16.950
<v Speaker 0>So please shout whenever there's anything unexplained.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:09:18.810 --> 00:09:24.540
<v Speaker 0>For example, I'm betting that I've used something in this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:24.540 --> 00:09:27.930
<v Speaker 0>definition that you haven't seen before.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:28.290 --> 00:09:29.940
<v Speaker 0>Probably haven't seen before.

NOTE CONF {"raw":[100,100,100,100]}

00:09:31.050 --> 00:09:33.300
<v Speaker 0>Any unknown symbols to you there?

NOTE CONF {"raw":[82,100,100,100,100,100]}

00:09:39.750 --> 00:09:40.110
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:09:44.160 --> 00:09:44.820
<v Speaker 0>This thing.

NOTE CONF {"raw":[100,100]}

00:09:46.590 --> 00:09:47.070
<v Speaker 0>Right.

NOTE CONF {"raw":[98]}

00:09:47.250 --> 00:09:47.970
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:09:47.970 --> 00:09:50.850
<v Speaker 0>so how many of you have seen that used before?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:52.470 --> 00:09:53.040
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:09:53.160 --> 00:09:55.710
<v Speaker 0>And for the rest of you, is it completely obvious

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:55.710 --> 00:09:56.640
<v Speaker 0>what it means?

NOTE CONF {"raw":[100,100,100]}

00:09:58.650 --> 00:09:59.430
<v Speaker 0>Yes.

NOTE CONF {"raw":[100]}

00:09:59.610 --> 00:10:00.240
<v Speaker 0>Some.

NOTE CONF {"raw":[100]}

00:10:00.240 --> 00:10:00.870
<v Speaker 0>No.

NOTE CONF {"raw":[100]}

00:10:01.200 --> 00:10:03.630
<v Speaker 0>Um, well, I could be being perverse and using it

NOTE CONF {"raw":[92,100,100,100,100,100,100,87,100,100]}

00:10:03.630 --> 00:10:06.450
<v Speaker 0>in a way that's different, but all I'm really doing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,73]}

00:10:06.450 --> 00:10:07.740
<v Speaker 0>is being lazy.

NOTE CONF {"raw":[100,100,100]}

00:10:07.740 --> 00:10:10.080
<v Speaker 0>I told you that mathematicians are lazy.

NOTE CONF {"raw":[100,100,100,100,100,95,100]}

00:10:10.710 --> 00:10:14.010
<v Speaker 0>Um, laziness is one of the most desirable aspects in

NOTE CONF {"raw":[66,100,100,100,100,100,100,100,100,100]}

00:10:14.010 --> 00:10:14.970
<v Speaker 0>a mathematician.

NOTE CONF {"raw":[100,100]}

00:10:16.890 --> 00:10:20.130
<v Speaker 0>Um, it's a backwards membership sign, and all it means

NOTE CONF {"raw":[91,100,100,100,100,100,100,100,100,100]}

00:10:20.130 --> 00:10:22.140
<v Speaker 0>is membership written the other way round.

NOTE CONF {"raw":[100,100,88,100,100,100,76]}

00:10:22.140 --> 00:10:24.570
<v Speaker 0>So what I mean here is that I want to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:24.570 --> 00:10:28.530
<v Speaker 0>talk about some s, and this s is a member

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:28.530 --> 00:10:29.970
<v Speaker 0>of Sigma Star.

NOTE CONF {"raw":[100,100,100]}

00:10:31.020 --> 00:10:33.480
<v Speaker 0>Remember Sigma star is the set of strings.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:35.280 --> 00:10:38.220
<v Speaker 0>Um, why am I using backwards membership?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:38.220 --> 00:10:40.410
<v Speaker 0>Let me explain how to be lazy.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:41.010 --> 00:10:43.710
<v Speaker 0>If I didn't do it, I would have to write.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:10:57.880 --> 00:11:03.220
<v Speaker 0>So I have saved myself one s and one.

NOTE CONF {"raw":[100,100,100,100,100,99,99,100,100]}

00:11:03.220 --> 00:11:07.000
<v Speaker 0>And that's clearly worth introducing a new symbol for, isn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:07.000 --> 00:11:07.180
<v Speaker 0>it?

NOTE CONF {"raw":[100]}

00:11:08.440 --> 00:11:11.350
<v Speaker 0>Well, no, but you will see this kind of notation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:11.350 --> 00:11:14.440
<v Speaker 0>thrown around, so I thought I'd put it in here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:15.550 --> 00:11:19.120
<v Speaker 0>So if s is a string of letters in the

NOTE CONF {"raw":[100,100,98,100,100,100,100,100,100,100]}

00:11:19.120 --> 00:11:24.850
<v Speaker 0>input alphabet, the trace is what we see the automaton

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:24.850 --> 00:11:26.980
<v Speaker 0>doing when it reads the string.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:28.270 --> 00:11:30.490
<v Speaker 0>So in particular we look at the set of states

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:30.490 --> 00:11:32.920
<v Speaker 0>and we see it goes from the initial state which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:32.920 --> 00:11:34.240
<v Speaker 0>remember is q0.

NOTE CONF {"raw":[100,100,84]}

00:11:34.600 --> 00:11:37.120
<v Speaker 0>Then it goes to some other state because it reads

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:37.120 --> 00:11:39.910
<v Speaker 0>a one and goes to q1, it reads A2 goes

NOTE CONF {"raw":[58,58,100,100,100,94,100,100,100,100]}

00:11:39.910 --> 00:11:41.320
<v Speaker 0>to Q2 and so on.

NOTE CONF {"raw":[100,76,100,100,100]}

00:11:41.860 --> 00:11:46.850
<v Speaker 0>And this sequence of states is the trace like the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:46.850 --> 00:11:49.700
<v Speaker 0>execution execution trace of a program?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:49.730 --> 00:11:52.310
<v Speaker 0>If any of you have yet found out how to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:52.310 --> 00:11:56.870
<v Speaker 0>debug Haskell, you will be watching traces of function evaluation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:56.870 --> 00:12:01.100
<v Speaker 0>So trace is the word commonly used to describe the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:01.100 --> 00:12:03.470
<v Speaker 0>way that a machine or a program or a function

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:03.470 --> 00:12:07.220
<v Speaker 0>behaves as it evolves step by step.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:08.810 --> 00:12:12.140
<v Speaker 0>So everybody happy with the definition of trace.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:12:16.250 --> 00:12:22.970
<v Speaker 0>This is the definition that we use in order to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:22.970 --> 00:12:25.340
<v Speaker 0>do whatever it is we're trying to do with finite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:25.340 --> 00:12:26.180
<v Speaker 0>automata.

NOTE CONF {"raw":[100]}

00:12:26.180 --> 00:12:30.110
<v Speaker 0>What we're mostly using them for is to decide whether

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:30.110 --> 00:12:32.420
<v Speaker 0>a string is in a particular language.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:34.310 --> 00:12:36.170
<v Speaker 0>And in order to do that, we need to talk

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:36.170 --> 00:12:39.230
<v Speaker 0>about the strings that the automaton accepts.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:39.650 --> 00:12:43.220
<v Speaker 0>Remember, automata have final states or accepting states which are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:43.220 --> 00:12:45.860
<v Speaker 0>good and any other state is bad.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:46.040 --> 00:12:48.050
<v Speaker 0>And you read a string, you end up in a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:48.050 --> 00:12:49.640
<v Speaker 0>good state or a bad state.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:50.390 --> 00:12:55.100
<v Speaker 0>The language accepted by an automaton M, which we write

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:55.100 --> 00:12:59.420
<v Speaker 0>L of M, is the strings that take you to

NOTE CONF {"raw":[100,94,100,100,100,100,100,100,100,100]}

00:12:59.420 --> 00:13:00.470
<v Speaker 0>a good state.

NOTE CONF {"raw":[100,100,100]}

00:13:00.470 --> 00:13:02.900
<v Speaker 0>And again, remember this notation from yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:02.930 --> 00:13:06.140
<v Speaker 0>F is the string of good states, final states accepting

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,100,100]}

00:13:06.140 --> 00:13:07.970
<v Speaker 0>states, whatever you want to call them.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:08.390 --> 00:13:11.300
<v Speaker 0>So when is the language accepted exactly?

NOTE CONF {"raw":[100,100,100,70,100,100,100]}

00:13:11.300 --> 00:13:16.340
<v Speaker 0>If the string transition function from the initial state reading

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:16.340 --> 00:13:20.210
<v Speaker 0>the string takes you into the set of final states.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:22.880 --> 00:13:23.840
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:13:24.860 --> 00:13:26.540
<v Speaker 0>Any questions on that definition.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:27.590 --> 00:13:31.070
<v Speaker 0>So these definitions are core to the next two weeks.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:34.370 --> 00:13:37.220
<v Speaker 0>I want to say a little bit more about laziness

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:37.220 --> 00:13:38.630
<v Speaker 0>on the side.

NOTE CONF {"raw":[100,100,100]}

00:13:39.590 --> 00:13:42.950
<v Speaker 0>Um, it gets extremely boring right?

NOTE CONF {"raw":[83,100,100,100,100,87]}

00:13:42.950 --> 00:13:43.350
<v Speaker 0>Right.

NOTE CONF {"raw":[62]}

00:13:43.380 --> 00:13:43.980
<v Speaker 0>Boring.

NOTE CONF {"raw":[95]}

00:13:43.980 --> 00:13:46.830
<v Speaker 0>Writing down at the start of every definition.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:46.830 --> 00:13:49.320
<v Speaker 0>Let em be a machine with a set of states

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:49.320 --> 00:13:50.700
<v Speaker 0>Q and an input alphabet.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:50.700 --> 00:13:52.140
<v Speaker 0>Sigma and a transition function.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:52.140 --> 00:13:55.410
<v Speaker 0>Delta and initial state q nought and final states f.

NOTE CONF {"raw":[100,97,100,100,100,98,100,100,97,100]}

00:13:56.250 --> 00:14:00.540
<v Speaker 0>So if I talk about em, you can assume that

NOTE CONF {"raw":[100,100,100,100,100,71,100,100,100,100]}

00:14:00.540 --> 00:14:03.900
<v Speaker 0>it is q sigma delta q nought f.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:04.140 --> 00:14:07.200
<v Speaker 0>And if I stick things on top of letters like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:07.200 --> 00:14:11.160
<v Speaker 0>primes or hats or anything else, you can assume, unless

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:11.160 --> 00:14:14.730
<v Speaker 0>I say otherwise, that its set of states is going

NOTE CONF {"raw":[100,100,100,100,96,100,100,100,100,100]}

00:14:14.730 --> 00:14:17.250
<v Speaker 0>to be Q dashed and its input alphabet is going

NOTE CONF {"raw":[100,100,100,99,100,95,100,100,100,100]}

00:14:17.250 --> 00:14:19.260
<v Speaker 0>to be sigma dashed, and so on and so on

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:19.260 --> 00:14:20.010
<v Speaker 0>and so on.

NOTE CONF {"raw":[100,100,100]}

00:14:21.780 --> 00:14:26.820
<v Speaker 0>Um, mathematicians use many ways of extending symbols, primes.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:14:27.060 --> 00:14:29.880
<v Speaker 0>This is called double prime or double dashed.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:30.420 --> 00:14:32.460
<v Speaker 0>Sometimes we use numbers.

NOTE CONF {"raw":[100,100,100,100]}

00:14:33.150 --> 00:14:37.740
<v Speaker 0>We can use various fancy accents or complexes, whatever.

NOTE CONF {"raw":[100,100,100,100,100,100,81,82,100]}

00:14:38.430 --> 00:14:41.400
<v Speaker 0>But if I decorate an Em with something, you can

NOTE CONF {"raw":[100,100,100,96,96,62,100,100,100,100]}

00:14:41.400 --> 00:14:44.940
<v Speaker 0>generally assume that everything else in the machine gets decorated.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:45.000 --> 00:14:47.100
<v Speaker 0>Unless I say it isn't.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:48.090 --> 00:14:52.020
<v Speaker 0>So we'll see that fairly shortly when we start defining

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:52.020 --> 00:14:54.300
<v Speaker 0>some constructions on automata.

NOTE CONF {"raw":[100,100,100,100]}

00:14:55.620 --> 00:15:00.300
<v Speaker 0>So final chance to ask any clarifications about notation and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:00.300 --> 00:15:04.110
<v Speaker 0>definitions before I start using them.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:15:08.040 --> 00:15:08.520
<v Speaker 0>Nope.

NOTE CONF {"raw":[97]}

00:15:09.390 --> 00:15:13.500
<v Speaker 0>Okay, so why do I want to do this?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:15:15.540 --> 00:15:21.450
<v Speaker 0>Languages accepted by machines are an interesting class of languages.

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:15:22.620 --> 00:15:25.800
<v Speaker 0>It turns out that they are particularly well structured and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:25.800 --> 00:15:28.920
<v Speaker 0>we can combine them in nice ways.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:29.370 --> 00:15:33.090
<v Speaker 0>So it's useful to have a convenient word to describe

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:33.390 --> 00:15:38.640
<v Speaker 0>the class of languages that is accepted by finite automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:39.870 --> 00:15:42.760
<v Speaker 0>And we're going to use the term regular for this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:42.760 --> 00:15:44.050
<v Speaker 0>if you come.

NOTE CONF {"raw":[100,100,100]}

00:15:44.740 --> 00:15:48.130
<v Speaker 0>Anybody come up through the French education system?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:50.230 --> 00:15:50.740
<v Speaker 0>No.

NOTE CONF {"raw":[97]}

00:15:51.340 --> 00:15:52.120
<v Speaker 0>Yes.

NOTE CONF {"raw":[100]}

00:15:52.150 --> 00:15:55.870
<v Speaker 0>So the French in general prefer to use rational rather

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:15:55.870 --> 00:15:58.870
<v Speaker 0>than regular for reasons that I've never quite understood.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:15:59.800 --> 00:16:03.250
<v Speaker 0>And you may see both, but most in most English

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:03.250 --> 00:16:05.800
<v Speaker 0>speaking maths we talk about regular languages.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:16:07.390 --> 00:16:11.530
<v Speaker 0>And for the moment we'll say that a language is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:11.530 --> 00:16:12.310
<v Speaker 0>regular.

NOTE CONF {"raw":[100]}

00:16:12.310 --> 00:16:16.420
<v Speaker 0>If we can build a finite automaton that accepts it,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:16.420 --> 00:16:22.450
<v Speaker 0>in the sense that this definition of acceptance gives regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:22.450 --> 00:16:26.260
<v Speaker 0>languages a nice because they're easy to analyse, and we

NOTE CONF {"raw":[85,100,100,100,100,100,100,56,100,100]}

00:16:26.260 --> 00:16:31.690
<v Speaker 0>can construct regular languages from other regular languages in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:31.690 --> 00:16:33.550
<v Speaker 0>way that we're about to do.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:34.570 --> 00:16:41.360
<v Speaker 0>So if an automaton recognises a regular language, then if

NOTE CONF {"raw":[100,100,100,100,79,78,80,100,100,100]}

00:16:41.360 --> 00:16:45.620
<v Speaker 0>we have two automaton two automata, we can think about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:45.620 --> 00:16:48.530
<v Speaker 0>combining them in various ways and seeing if we can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:48.530 --> 00:16:50.930
<v Speaker 0>construct more interesting languages.

NOTE CONF {"raw":[100,100,100,100]}

00:16:52.400 --> 00:16:56.330
<v Speaker 0>So there are a bunch of ways things we might

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:56.330 --> 00:16:57.680
<v Speaker 0>do to a language.

NOTE CONF {"raw":[100,100,100,100]}

00:16:57.920 --> 00:17:01.820
<v Speaker 0>One rather obvious thing we might do with a language

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:01.820 --> 00:17:05.839
<v Speaker 0>is say, actually, this is the language of bad things.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:06.680 --> 00:17:09.319
<v Speaker 0>So sometimes it's easier to talk about which things are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:09.319 --> 00:17:11.689
<v Speaker 0>bad than to talk about which things are good.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:17:11.839 --> 00:17:14.390
<v Speaker 0>So maybe it's easy to define the bad strings.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:17:14.390 --> 00:17:17.660
<v Speaker 0>And then can we build a machine that define describes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:17.660 --> 00:17:19.250
<v Speaker 0>the good things instead?

NOTE CONF {"raw":[100,100,100,100]}

00:17:20.810 --> 00:17:23.750
<v Speaker 0>This is complementing the automaton.

NOTE CONF {"raw":[100,100,67,100,100]}

00:17:24.260 --> 00:17:26.689
<v Speaker 0>If we can build a machine that accepts a particular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:26.689 --> 00:17:31.130
<v Speaker 0>language L, how do we build a machine that accepts

NOTE CONF {"raw":[100,86,100,100,100,100,100,100,100,100]}

00:17:31.130 --> 00:17:32.810
<v Speaker 0>the complement of L.

NOTE CONF {"raw":[100,92,100,100]}

00:17:33.740 --> 00:17:36.890
<v Speaker 0>Um, and I know from previous years that not everybody

NOTE CONF {"raw":[91,100,100,100,100,100,100,100,100,100]}

00:17:36.890 --> 00:17:38.870
<v Speaker 0>has seen all of these definitions.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:17:41.450 --> 00:17:43.730
<v Speaker 0>If you want to talk about the difference of two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:43.730 --> 00:17:45.020
<v Speaker 0>sets, that is the thing.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:45.020 --> 00:17:48.470
<v Speaker 0>That is things that are in A but are not

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:48.470 --> 00:17:53.840
<v Speaker 0>in B, there are a couple of common notations you've

NOTE CONF {"raw":[100,95,100,100,100,100,100,100,100,100]}

00:17:53.840 --> 00:17:54.500
<v Speaker 0>used.

NOTE CONF {"raw":[100]}

00:17:54.620 --> 00:17:59.000
<v Speaker 0>Just out of idle curiosity, who is already used to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:59.000 --> 00:18:00.530
<v Speaker 0>seeing minus for that?

NOTE CONF {"raw":[100,81,100,100]}

00:18:02.390 --> 00:18:05.180
<v Speaker 0>Very few who is already used to seeing backslash for

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,100]}

00:18:05.180 --> 00:18:05.750
<v Speaker 0>that?

NOTE CONF {"raw":[100]}

00:18:06.350 --> 00:18:07.370
<v Speaker 0>Slightly more.

NOTE CONF {"raw":[100,100]}

00:18:07.700 --> 00:18:10.280
<v Speaker 0>I'm sure the rest of you have seen notations for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:10.280 --> 00:18:11.360
<v Speaker 0>set difference.

NOTE CONF {"raw":[100,100]}

00:18:12.050 --> 00:18:13.580
<v Speaker 0>Is there another notation?

NOTE CONF {"raw":[100,100,100,100]}

00:18:17.360 --> 00:18:18.500
<v Speaker 0>There probably are.

NOTE CONF {"raw":[52,100,100]}

00:18:19.130 --> 00:18:20.420
<v Speaker 0>You will see both.

NOTE CONF {"raw":[100,100,100,100]}

00:18:21.920 --> 00:18:25.760
<v Speaker 0>I tend to prefer minus because backslash is just an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:25.760 --> 00:18:26.600
<v Speaker 0>ugly symbol.

NOTE CONF {"raw":[100,100]}

00:18:26.600 --> 00:18:29.510
<v Speaker 0>And besides it's used a lot in programming for various

NOTE CONF {"raw":[100,100,98,100,100,100,100,100,100,100]}

00:18:29.510 --> 00:18:30.140
<v Speaker 0>things.

NOTE CONF {"raw":[100]}

00:18:31.190 --> 00:18:35.000
<v Speaker 0>Um, so by a minus B I mean things that

NOTE CONF {"raw":[92,100,100,100,100,100,100,100,100,100]}

00:18:35.000 --> 00:18:37.170
<v Speaker 0>are in A and not in B.

NOTE CONF {"raw":[100,100,100,100,100,100,71]}

00:18:40.320 --> 00:18:43.620
<v Speaker 0>So if I have an automaton to accept a language,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:43.620 --> 00:18:48.330
<v Speaker 0>how do I build an automaton that accepts the complement

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,67]}

00:18:48.330 --> 00:18:49.170
<v Speaker 0>language?

NOTE CONF {"raw":[100]}

00:18:50.460 --> 00:18:51.870
<v Speaker 0>It's not very hard.

NOTE CONF {"raw":[100,100,100,100]}

00:18:52.890 --> 00:18:55.950
<v Speaker 0>Without looking at the rest of the slide, can you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:55.950 --> 00:18:57.270
<v Speaker 0>see how to do it?

NOTE CONF {"raw":[100,100,100,100,100]}

00:19:05.490 --> 00:19:06.000
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:19:07.530 --> 00:19:09.960
<v Speaker 0>The complement.

NOTE CONF {"raw":[68,100]}

00:19:09.960 --> 00:19:10.380
<v Speaker 1>Of.

NOTE CONF {"raw":[100]}

00:19:14.640 --> 00:19:16.020
<v Speaker 0>Complement of L so I.

NOTE CONF {"raw":[100,100,100,100,83]}

00:19:17.940 --> 00:19:18.240
<v Speaker 1>Um.

NOTE CONF {"raw":[81]}

00:19:18.720 --> 00:19:19.140
<v Speaker 1>Sigma.

NOTE CONF {"raw":[70]}

00:19:21.690 --> 00:19:24.240
<v Speaker 0>Um, I can't do anything to Sigma because the input

NOTE CONF {"raw":[100,100,100,100,100,77,100,100,100,100]}

00:19:24.240 --> 00:19:25.560
<v Speaker 0>alphabet is the same.

NOTE CONF {"raw":[100,100,100,100]}

00:19:26.400 --> 00:19:28.890
<v Speaker 0>I have to change something in the machine.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:19:36.010 --> 00:19:36.520
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:19:41.950 --> 00:19:45.280
<v Speaker 1>I just want to be accepted and not accepted.

NOTE CONF {"raw":[89,49,43,50,51,100,100,100,100]}

00:19:45.910 --> 00:19:48.850
<v Speaker 0>Swap the accepting and non accepting states.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:19:50.380 --> 00:19:50.830
<v Speaker 1>Yeah.

NOTE CONF {"raw":[98]}

00:19:51.760 --> 00:19:52.210
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:19:52.210 --> 00:19:55.750
<v Speaker 0>So how does the complement work.

NOTE CONF {"raw":[100,100,100,100,79,100]}

00:19:56.590 --> 00:20:00.250
<v Speaker 0>A string is in the complement if it is not

NOTE CONF {"raw":[100,100,100,100,100,60,100,100,100,100]}

00:20:00.250 --> 00:20:01.780
<v Speaker 0>in the original language.

NOTE CONF {"raw":[100,100,100,100]}

00:20:02.500 --> 00:20:05.290
<v Speaker 0>So when it's a string accepted by an automaton when

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:05.290 --> 00:20:06.730
<v Speaker 0>it hits a good state.

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:07.120 --> 00:20:08.590
<v Speaker 0>When is it rejected.

NOTE CONF {"raw":[100,100,100,100]}

00:20:08.590 --> 00:20:09.970
<v Speaker 0>When it hits a bad state.

NOTE CONF {"raw":[100,100,100,97,100,100]}

00:20:09.970 --> 00:20:11.920
<v Speaker 0>So if I swap the good states and the bad

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:11.920 --> 00:20:15.070
<v Speaker 0>states, I accept the compliment language.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:16.960 --> 00:20:17.500
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:20:19.840 --> 00:20:25.480
<v Speaker 0>Um, so here I have a demonstration of abusive notation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,78,100]}

00:20:25.480 --> 00:20:25.960
<v Speaker 0>again.

NOTE CONF {"raw":[100]}

00:20:25.960 --> 00:20:29.260
<v Speaker 0>So here is a machine with the standard letters q,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:29.260 --> 00:20:31.570
<v Speaker 0>sigma, delta, q nought f nought.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:31.750 --> 00:20:35.230
<v Speaker 0>If I want to accept the complement of the language,

NOTE CONF {"raw":[100,100,100,100,100,100,99,100,100,100]}

00:20:35.230 --> 00:20:39.760
<v Speaker 0>then all I have to do is make good states

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:39.760 --> 00:20:43.000
<v Speaker 0>bad and bad states good, which I can do by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:43.000 --> 00:20:47.140
<v Speaker 0>saying that the good states of this m bar are

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,98,100]}

00:20:47.140 --> 00:20:50.950
<v Speaker 0>the bad states of the original automaton Q minus F

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:51.970 --> 00:20:52.780
<v Speaker 0>good states.

NOTE CONF {"raw":[100,100]}

00:20:52.780 --> 00:20:55.120
<v Speaker 0>All states are bad states.

NOTE CONF {"raw":[100,100,74,100,100]}

00:20:57.040 --> 00:20:59.140
<v Speaker 0>Um, there is a catch here.

NOTE CONF {"raw":[90,100,100,100,100,100]}

00:20:59.140 --> 00:21:02.320
<v Speaker 0>So I told you yesterday when I introduced the black

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:02.320 --> 00:21:06.100
<v Speaker 0>hole convention that you need to remember that it's there.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:07.600 --> 00:21:10.240
<v Speaker 0>The black hole convention said that we often don't draw

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:10.240 --> 00:21:12.310
<v Speaker 0>states where it's obvious what happens.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:12.310 --> 00:21:15.820
<v Speaker 0>But of course, if I take an automaton with a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:15.820 --> 00:21:18.700
<v Speaker 0>black hole state and I complement it, then the black

NOTE CONF {"raw":[100,100,100,100,100,55,100,100,100,100]}

00:21:18.700 --> 00:21:20.980
<v Speaker 0>hole state becomes an accepting state.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:20.980 --> 00:21:23.830
<v Speaker 0>So it appears in the automaton and has to be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:23.830 --> 00:21:24.940
<v Speaker 0>drawn as such.

NOTE CONF {"raw":[100,100,100]}

00:21:26.260 --> 00:21:30.460
<v Speaker 0>So while space saving conventions are a good thing, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:30.460 --> 00:21:34.010
<v Speaker 0>have to remember where they've been used and undo them

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:34.010 --> 00:21:35.090
<v Speaker 0>if necessary.

NOTE CONF {"raw":[100,100]}

00:21:38.390 --> 00:21:40.490
<v Speaker 0>So does this make sense?

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:43.130 --> 00:21:46.040
<v Speaker 0>Anybody not see what I'm doing here?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:57.530 --> 00:21:59.360
<v Speaker 0>What if you were doing this in Haskell?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:21:59.360 --> 00:22:01.490
<v Speaker 0>What would the bar represent?

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:08.630 --> 00:22:08.990
<v Speaker 1>Not.

NOTE CONF {"raw":[67]}

00:22:10.070 --> 00:22:11.810
<v Speaker 0>I mean, it means complement.

NOTE CONF {"raw":[100,100,100,100,89]}

00:22:11.810 --> 00:22:12.560
<v Speaker 0>So.

NOTE CONF {"raw":[100]}

00:22:12.770 --> 00:22:16.100
<v Speaker 0>But if you're implementing this in Haskell, as you will,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:16.610 --> 00:22:19.070
<v Speaker 0>what type of thing would bar be?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:29.210 --> 00:22:30.710
<v Speaker 0>So what I'm doing here is asking you to think

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:30.710 --> 00:22:34.340
<v Speaker 0>about mathematical notation in a more programming like way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:22:34.430 --> 00:22:37.040
<v Speaker 0>So mathematicians just write m bar.

NOTE CONF {"raw":[100,100,100,100,98,98]}

00:22:37.340 --> 00:22:40.760
<v Speaker 0>But if I were programming this stuff up, what would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:40.760 --> 00:22:41.570
<v Speaker 0>I be doing?

NOTE CONF {"raw":[100,100,100]}

00:22:42.470 --> 00:22:42.830
<v Speaker 0>Yeah.

NOTE CONF {"raw":[94]}

00:22:48.110 --> 00:22:50.810
<v Speaker 0>So if I were programming this, I'd be applying a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:50.810 --> 00:22:53.840
<v Speaker 0>function called Complement my automaton or something.

NOTE CONF {"raw":[100,100,83,100,100,100,100]}

00:22:54.920 --> 00:22:55.340
<v Speaker 0>Oh.

NOTE CONF {"raw":[52]}

00:22:56.720 --> 00:23:03.020
<v Speaker 0>So, um, if you prefer to think about programming than

NOTE CONF {"raw":[91,79,100,100,100,100,100,100,100,100]}

00:23:03.020 --> 00:23:06.140
<v Speaker 0>maths, you can go quite a long way by translating

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:06.140 --> 00:23:08.960
<v Speaker 0>mathematician style notation into functions.

NOTE CONF {"raw":[70,100,100,100,100]}

00:23:09.050 --> 00:23:11.750
<v Speaker 0>So the bar here, you can think of as an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:11.750 --> 00:23:16.070
<v Speaker 0>operator that is taking an automaton M and giving you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:16.070 --> 00:23:19.190
<v Speaker 0>back another automaton that is the complement of it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:23:20.210 --> 00:23:23.030
<v Speaker 0>And this definition of m bar on the right is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:23.030 --> 00:23:25.070
<v Speaker 0>what you would you would write as the right hand

NOTE CONF {"raw":[100,88,79,100,100,100,100,100,100,100]}

00:23:25.070 --> 00:23:28.100
<v Speaker 0>side of your function definition in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:23:30.510 --> 00:23:31.860
<v Speaker 0>So what have I just done?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:31.860 --> 00:23:36.810
<v Speaker 0>I've taken on automaton and built another automaton that returns

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:36.810 --> 00:23:38.220
<v Speaker 0>the compliment language.

NOTE CONF {"raw":[100,68,100]}

00:23:38.640 --> 00:23:40.350
<v Speaker 0>This tells me something.

NOTE CONF {"raw":[100,100,100,100]}

00:23:41.130 --> 00:23:44.340
<v Speaker 0>And here I'm going to introduce some more terminology, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:44.340 --> 00:23:45.690
<v Speaker 0>is probably new to you.

NOTE CONF {"raw":[100,100,100,100,100]}

00:23:46.050 --> 00:23:48.420
<v Speaker 0>This tells me something quite important.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:48.600 --> 00:23:51.540
<v Speaker 0>It tells me that the set of regular languages is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:51.540 --> 00:23:53.280
<v Speaker 0>closed under complement.

NOTE CONF {"raw":[100,100,83]}

00:23:55.650 --> 00:23:58.620
<v Speaker 0>Have you any idea what closed under means?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:23:59.400 --> 00:24:00.540
<v Speaker 0>Some do.

NOTE CONF {"raw":[100,100]}

00:24:00.570 --> 00:24:02.250
<v Speaker 0>Some have seen it before.

NOTE CONF {"raw":[100,100,100,100,100]}

00:24:02.400 --> 00:24:04.320
<v Speaker 0>Who's never seen this before?

NOTE CONF {"raw":[95,100,100,100,100]}

00:24:07.620 --> 00:24:07.950
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:24:07.950 --> 00:24:10.800
<v Speaker 0>That leaves a very large number of you where I'm

NOTE CONF {"raw":[100,91,100,100,100,100,100,88,100,100]}

00:24:10.800 --> 00:24:13.200
<v Speaker 0>very surprised if you've seen it before, because it doesn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:13.200 --> 00:24:15.900
<v Speaker 0>usually pop up until university maths.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:17.940 --> 00:24:20.370
<v Speaker 0>Um, I don't think it comes in linear algebra.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:24:22.470 --> 00:24:24.420
<v Speaker 0>What do I mean when I say that the set

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:24.420 --> 00:24:27.300
<v Speaker 0>of regular languages is closed under complement?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:27.330 --> 00:24:29.200
<v Speaker 0>Well, all I mean is that if I take a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,92]}

00:24:29.200 --> 00:24:32.260
<v Speaker 0>regular language and compliment it, then it is still regular.

NOTE CONF {"raw":[92,100,100,72,100,100,100,100,100,100]}

00:24:32.710 --> 00:24:38.230
<v Speaker 0>So this term closed under is used a lot in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:38.230 --> 00:24:40.120
<v Speaker 0>building mathematical things.

NOTE CONF {"raw":[100,100,100]}

00:24:40.780 --> 00:24:44.740
<v Speaker 0>It means I have a big set of nice things,

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:24:44.860 --> 00:24:48.910
<v Speaker 0>and I do something to it, which takes me back

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:48.910 --> 00:24:50.830
<v Speaker 0>into the set of nice things.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:50.920 --> 00:24:53.410
<v Speaker 0>So in this case, my nice things.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:56.380 --> 00:24:59.260
<v Speaker 0>Are regular languages, and if I take a language and

NOTE CONF {"raw":[97,80,100,100,100,100,100,100,100,100]}

00:24:59.260 --> 00:25:02.200
<v Speaker 0>compliment it, then I still get a regular language.

NOTE CONF {"raw":[64,100,100,100,100,100,97,97,100]}

00:25:02.800 --> 00:25:04.570
<v Speaker 0>Why do I get a regular language?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:25:04.570 --> 00:25:07.780
<v Speaker 0>Because I've been able to build an automaton that accepts

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:07.780 --> 00:25:08.200
<v Speaker 0>it.

NOTE CONF {"raw":[100]}

00:25:09.670 --> 00:25:14.560
<v Speaker 0>So that's good because complimenting languages is something one does

NOTE CONF {"raw":[100,100,100,100,57,100,100,100,100,100]}

00:25:14.560 --> 00:25:15.610
<v Speaker 0>all the time.

NOTE CONF {"raw":[100,100,100]}

00:25:17.920 --> 00:25:22.540
<v Speaker 0>But we can't go very far just by taking languages

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:22.540 --> 00:25:25.660
<v Speaker 0>and complimenting them and complimenting them back again, because the

NOTE CONF {"raw":[100,68,100,100,78,100,100,100,100,100]}

00:25:25.660 --> 00:25:27.670
<v Speaker 0>complement of the complement is the original.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:25:28.600 --> 00:25:31.780
<v Speaker 0>And actually, if you look at this construction, this construction

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:32.110 --> 00:25:34.630
<v Speaker 0>also has the property that if you do it twice,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:34.630 --> 00:25:38.260
<v Speaker 0>you get back to where you started, which is not

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:38.260 --> 00:25:41.200
<v Speaker 0>always the case with complementing constructions.

NOTE CONF {"raw":[100,100,100,100,80,100]}

00:25:44.740 --> 00:25:46.270
<v Speaker 0>What else can we do?

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:46.750 --> 00:25:51.850
<v Speaker 0>So yesterday we talked about an automaton that recognised a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,91,100]}

00:25:51.850 --> 00:25:54.280
<v Speaker 0>moderately complicated set of languages.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:54.280 --> 00:25:57.250
<v Speaker 0>That was the set of strings of zeros and ones

NOTE CONF {"raw":[100,100,100,100,100,100,100,90,100,100]}

00:25:57.250 --> 00:25:59.620
<v Speaker 0>where there were an even number of ones and an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:59.620 --> 00:26:00.940
<v Speaker 0>odd number of zeros.

NOTE CONF {"raw":[100,100,100,82]}

00:26:00.940 --> 00:26:02.650
<v Speaker 0>Or was it the other way round?

NOTE CONF {"raw":[100,100,100,100,100,100,50]}

00:26:03.670 --> 00:26:06.190
<v Speaker 0>Um, and I asked, do you think whether there was

NOTE CONF {"raw":[100,100,100,72,38,91,100,100,100,100]}

00:26:06.190 --> 00:26:09.220
<v Speaker 0>a way of structuring that in some way?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:10.660 --> 00:26:11.740
<v Speaker 0>Well, there are a couple of ways.

NOTE CONF {"raw":[92,100,100,100,100,100,100]}

00:26:11.740 --> 00:26:14.170
<v Speaker 0>We'll see one now and another next week.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:14.380 --> 00:26:19.240
<v Speaker 0>But I want to introduce now another construction on automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:22.930 --> 00:26:28.400
<v Speaker 0>This is maybe not so Obviously not so immediately.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:26:29.150 --> 00:26:32.780
<v Speaker 0>Obviously an interesting thing to do if I've got two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:32.780 --> 00:26:35.240
<v Speaker 0>languages and I'm going to call them L and L

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:35.240 --> 00:26:40.910
<v Speaker 0>Prime, and they're regular languages, meaning I can construct them,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:41.600 --> 00:26:44.990
<v Speaker 0>I can build them, build automata to recognise them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,61,100]}

00:26:45.290 --> 00:26:50.360
<v Speaker 0>Can I build a language that accepts the intersection of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:50.360 --> 00:26:51.740
<v Speaker 0>the two languages?

NOTE CONF {"raw":[100,100,100]}

00:26:53.120 --> 00:26:56.300
<v Speaker 0>So the intersection of the languages, that means a string

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,89,100]}

00:26:56.300 --> 00:26:57.950
<v Speaker 0>that is in both languages.

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:58.400 --> 00:26:59.990
<v Speaker 0>Why do we want to do this?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:27:00.020 --> 00:27:02.930
<v Speaker 0>Well, actually in practice we don't want to do it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:02.930 --> 00:27:03.740
<v Speaker 0>very often.

NOTE CONF {"raw":[100,100]}

00:27:03.740 --> 00:27:08.090
<v Speaker 0>In everyday programming with regular languages, you don't often use

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:08.090 --> 00:27:09.710
<v Speaker 0>the intersection operator.

NOTE CONF {"raw":[100,100,100]}

00:27:10.310 --> 00:27:14.030
<v Speaker 0>And there's also a good practical reason, which we will

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:27:14.030 --> 00:27:16.460
<v Speaker 0>see maybe next week why we don't do that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:17.990 --> 00:27:21.260
<v Speaker 0>But if you can think of a reason, a situation

NOTE CONF {"raw":[100,100,100,100,100,100,81,79,98,100]}

00:27:21.260 --> 00:27:23.870
<v Speaker 0>where you might want it, you have two good properties

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:23.870 --> 00:27:24.620
<v Speaker 0>of languages.

NOTE CONF {"raw":[100,100]}

00:27:24.620 --> 00:27:28.500
<v Speaker 0>You need your languages to satisfy this property to be

NOTE CONF {"raw":[100,100,100,100,98,100,100,100,100,100]}

00:27:28.500 --> 00:27:31.080
<v Speaker 0>good, and you also want them to satisfy this property

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:31.080 --> 00:27:31.740
<v Speaker 0>to be good.

NOTE CONF {"raw":[100,100,100]}

00:27:31.740 --> 00:27:34.560
<v Speaker 0>You would like a single thing to check both properties

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:34.560 --> 00:27:40.110
<v Speaker 0>simultaneously, and that gives you the intersection of the two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:40.110 --> 00:27:41.040
<v Speaker 0>languages.

NOTE CONF {"raw":[100]}

00:27:43.020 --> 00:27:45.660
<v Speaker 0>It's a little bit harder to see how to take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:45.660 --> 00:27:50.070
<v Speaker 0>two automata for two different languages, and plug them together

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:50.070 --> 00:27:54.450
<v Speaker 0>to accept something that is in the intersection, but not

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:54.450 --> 00:27:55.380
<v Speaker 0>very hard.

NOTE CONF {"raw":[100,100]}

00:27:56.340 --> 00:28:00.780
<v Speaker 0>Um, how are we doing for time, 20 minutes and

NOTE CONF {"raw":[79,100,100,100,100,100,100,100,100,100]}

00:28:00.780 --> 00:28:01.890
<v Speaker 0>two slides?

NOTE CONF {"raw":[100,100]}

00:28:03.510 --> 00:28:05.430
<v Speaker 0>Maybe I should let you think about it a bit.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:06.510 --> 00:28:07.710
<v Speaker 0>Can you think about.

NOTE CONF {"raw":[100,100,100,100]}

00:28:09.870 --> 00:28:17.130
<v Speaker 0>How you might connect two automata together so that a

NOTE CONF {"raw":[100,100,100,100,95,100,100,100,100,100]}

00:28:17.130 --> 00:28:20.580
<v Speaker 0>string has to pass through both of them, and be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:20.580 --> 00:28:24.240
<v Speaker 0>good in both of them in order to be counted

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:24.240 --> 00:28:25.440
<v Speaker 0>as a good string.

NOTE CONF {"raw":[100,100,100,100]}

00:29:02.160 --> 00:29:03.750
<v Speaker 0>Any ideas coming up?

NOTE CONF {"raw":[100,100,100,100]}

00:29:13.440 --> 00:29:15.450
<v Speaker 0>If I give you a string, and I ask you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:15.450 --> 00:29:18.270
<v Speaker 0>to tell me whether it's accepted by this one, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:18.270 --> 00:29:19.650
<v Speaker 0>also by this one.

NOTE CONF {"raw":[100,100,100,100]}

00:29:20.670 --> 00:29:22.200
<v Speaker 0>There are several things you could do.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:29:22.210 --> 00:29:24.940
<v Speaker 0>What's one one easy thing you could do?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:27.850 --> 00:29:28.300
<v Speaker 0>Yeah.

NOTE CONF {"raw":[94]}

00:29:32.320 --> 00:29:34.900
<v Speaker 0>So I could say run it through this one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:35.530 --> 00:29:38.170
<v Speaker 0>If it fails there, then it fails.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:29:38.410 --> 00:29:40.300
<v Speaker 0>Otherwise, run it through this one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:29:41.050 --> 00:29:43.240
<v Speaker 0>If it comes out the other end with good, then

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:43.240 --> 00:29:44.500
<v Speaker 0>it's passed through both.

NOTE CONF {"raw":[98,100,100,100]}

00:29:45.460 --> 00:29:48.580
<v Speaker 0>Um, that's one way.

NOTE CONF {"raw":[100,100,100,100]}

00:29:48.580 --> 00:29:53.740
<v Speaker 0>It's slightly unpretty, but it works.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:29:57.820 --> 00:29:59.590
<v Speaker 0>Wouldn't it be nice if we could kind of run

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:59.590 --> 00:30:02.500
<v Speaker 0>the two machines together, rather than one after the other?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:03.820 --> 00:30:09.400
<v Speaker 0>So what we're going to do is find a way

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:09.400 --> 00:30:15.610
<v Speaker 0>to take a string and feed it effectively to both

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:15.610 --> 00:30:21.350
<v Speaker 0>automata at the same time, and that's not actually Very

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:21.350 --> 00:30:21.980
<v Speaker 0>hard.

NOTE CONF {"raw":[100]}

00:30:22.580 --> 00:30:27.590
<v Speaker 0>We just have to define a rather large automaton that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:28.040 --> 00:30:32.090
<v Speaker 0>codes up the states of both automata at once.

NOTE CONF {"raw":[100,100,100,100,100,100,61,100,100]}

00:30:33.530 --> 00:30:36.110
<v Speaker 0>So I'll give you the formalism first, and then I'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:36.110 --> 00:30:37.190
<v Speaker 0>give you the picture.

NOTE CONF {"raw":[100,100,100,100]}

00:30:38.060 --> 00:30:43.430
<v Speaker 0>So what we have here is automaton one m which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:43.430 --> 00:30:49.790
<v Speaker 0>is q sigma blah blah, and automaton M dashed which

NOTE CONF {"raw":[100,100,100,89,89,100,100,100,100,100]}

00:30:49.790 --> 00:30:50.630
<v Speaker 0>has dashes.

NOTE CONF {"raw":[100,100]}

00:30:50.660 --> 00:30:55.040
<v Speaker 0>However, these two automata have the same input alphabet, so

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,62,100]}

00:30:55.040 --> 00:30:57.650
<v Speaker 0>they both have input alphabet sigma because they're looking at

NOTE CONF {"raw":[100,100,100,100,100,100,100,96,100,100]}

00:30:57.650 --> 00:31:00.740
<v Speaker 0>the same set of input strings.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:02.330 --> 00:31:03.680
<v Speaker 0>Here's a definition.

NOTE CONF {"raw":[100,100,100]}

00:31:03.680 --> 00:31:06.050
<v Speaker 0>This is a definition of what the product of two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:06.050 --> 00:31:08.510
<v Speaker 0>automata, or to be precise, it's the definition of the

NOTE CONF {"raw":[100,100,100,100,100,91,100,100,100,100]}

00:31:08.510 --> 00:31:11.390
<v Speaker 0>product of two deterministic finite automata.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:11.540 --> 00:31:15.980
<v Speaker 0>Remember I said yesterday we were dealing with deterministic machines

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:15.980 --> 00:31:16.970
<v Speaker 0>Dfas.

NOTE CONF {"raw":[100]}

00:31:17.420 --> 00:31:19.730
<v Speaker 0>We'll get a little more complex next week.

NOTE CONF {"raw":[74,100,100,100,100,100,100,100]}

00:31:21.830 --> 00:31:23.780
<v Speaker 0>What is the product of two automata?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:23.780 --> 00:31:24.410
<v Speaker 0>Automata?

NOTE CONF {"raw":[100]}

00:31:24.440 --> 00:31:27.680
<v Speaker 0>Well, the set of states is the product of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:27.680 --> 00:31:29.000
<v Speaker 0>set of states.

NOTE CONF {"raw":[100,100,100]}

00:31:31.010 --> 00:31:33.800
<v Speaker 0>So q cross, q prime.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:34.250 --> 00:31:38.810
<v Speaker 0>Now I think actually after my tutorial yesterday, are you

NOTE CONF {"raw":[82,100,100,100,100,100,100,100,100,100]}

00:31:38.810 --> 00:31:43.730
<v Speaker 0>all by now familiar with the use of times to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:43.730 --> 00:31:46.460
<v Speaker 0>represent the Cartesian product of two sets?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:49.880 --> 00:31:50.900
<v Speaker 0>Who is not?

NOTE CONF {"raw":[100,100,100]}

00:31:51.200 --> 00:31:55.070
<v Speaker 0>So some people are definitely a bit dodgy.

NOTE CONF {"raw":[100,100,100,100,100,99,100,100]}

00:31:56.000 --> 00:31:58.370
<v Speaker 0>Who is sure that they're unsure?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:00.140 --> 00:32:00.620
<v Speaker 0>Right.

NOTE CONF {"raw":[98]}

00:32:00.830 --> 00:32:03.830
<v Speaker 0>So we have some notation that needs explaining.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:32:07.280 --> 00:32:09.740
<v Speaker 0>Um, this stuff is in the basic set theory that

NOTE CONF {"raw":[92,100,100,100,100,100,100,100,100,100]}

00:32:09.740 --> 00:32:12.080
<v Speaker 0>we ask you to read before starting the course, I'm

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:12.080 --> 00:32:15.890
<v Speaker 0>pretty sure, but it doesn't hurt to refine it.

NOTE CONF {"raw":[100,100,97,88,100,100,100,100,100]}

00:32:16.130 --> 00:32:17.510
<v Speaker 0>So if I've got a set.

NOTE CONF {"raw":[100,100,72,100,100,100]}

00:32:20.580 --> 00:32:25.260
<v Speaker 0>A and A set B the Cartesian product.

NOTE CONF {"raw":[100,100,92,99,100,100,100,100]}

00:32:25.260 --> 00:32:29.910
<v Speaker 0>So that's Cartesian after Descartes is simply the set of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:29.910 --> 00:32:30.840
<v Speaker 0>pairs.

NOTE CONF {"raw":[100]}

00:32:44.490 --> 00:32:46.200
<v Speaker 0>The set of pairs of things.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:46.530 --> 00:32:49.560
<v Speaker 0>First element from the first set and second element from

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:49.560 --> 00:32:50.490
<v Speaker 0>the second set.

NOTE CONF {"raw":[100,100,100]}

00:32:51.660 --> 00:32:54.600
<v Speaker 0>So in other words, you're just looking at one element

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:54.600 --> 00:32:58.620
<v Speaker 0>in each set and that is your new state.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:58.620 --> 00:33:02.880
<v Speaker 0>So here what I'm saying is that the state of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:02.880 --> 00:33:07.200
<v Speaker 0>the product automaton is a state in this one, together

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:07.200 --> 00:33:09.000
<v Speaker 0>with a state in this one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:10.590 --> 00:33:13.680
<v Speaker 0>You'll see that diagrammatically shortly.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:14.250 --> 00:33:16.650
<v Speaker 0>The input alphabet is the same because we're trying to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:16.650 --> 00:33:17.970
<v Speaker 0>recognise the language.

NOTE CONF {"raw":[89,100,100]}

00:33:18.330 --> 00:33:20.730
<v Speaker 0>Then there's going to be a transition function, which I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:20.730 --> 00:33:23.040
<v Speaker 0>have to define on the next line.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:24.810 --> 00:33:26.940
<v Speaker 0>What's the initial state of a product?

NOTE CONF {"raw":[100,100,100,100,100,91,100]}

00:33:27.150 --> 00:33:29.490
<v Speaker 0>Well, if I'm taking two automata and I want to

NOTE CONF {"raw":[100,100,100,100,93,100,100,100,100,100]}

00:33:29.490 --> 00:33:32.520
<v Speaker 0>run them together, the initial state should be the initial

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:32.520 --> 00:33:34.230
<v Speaker 0>state of the two halves.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:34.710 --> 00:33:35.910
<v Speaker 0>I start at the beginning.

NOTE CONF {"raw":[52,100,100,100,100]}

00:33:37.680 --> 00:33:39.720
<v Speaker 0>What are the accepting states?

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:39.720 --> 00:33:41.220
<v Speaker 0>What are the good states?

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:41.400 --> 00:33:44.490
<v Speaker 0>Well, my aim here is to accept the language that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:44.490 --> 00:33:48.480
<v Speaker 0>is the intersection of the strings.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:48.480 --> 00:33:51.060
<v Speaker 0>So I want good states to be ones that are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:51.060 --> 00:33:53.670
<v Speaker 0>good in both halves of the construction.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:54.120 --> 00:33:57.900
<v Speaker 0>So an accepting state is a good state in M

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,96]}

00:33:57.900 --> 00:34:00.030
<v Speaker 0>and a good state in M dashed.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:34:01.830 --> 00:34:04.140
<v Speaker 0>What does the transition function do?

NOTE CONF {"raw":[100,99,100,100,100,100]}

00:34:04.230 --> 00:34:08.550
<v Speaker 0>Well, the transition function is supposed to take a state

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:08.550 --> 00:34:11.010
<v Speaker 0>in one and a state in the other, and tell

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:11.010 --> 00:34:13.139
<v Speaker 0>you where to go when you read an input.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:34:14.250 --> 00:34:15.690
<v Speaker 0>That's straightforward, right?

NOTE CONF {"raw":[100,100,100]}

00:34:15.690 --> 00:34:19.419
<v Speaker 0>Because if I read an input a here in this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:19.419 --> 00:34:21.669
<v Speaker 0>automaton, I see where I go with an A in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:21.669 --> 00:34:23.679
<v Speaker 0>this automaton, I see where I go with an A,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:23.679 --> 00:34:25.179
<v Speaker 0>and that's where I end up.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:34:25.510 --> 00:34:27.340
<v Speaker 0>So that's what this says.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:27.340 --> 00:34:29.679
<v Speaker 0>If I'm in state Q in the left and Q

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:29.679 --> 00:34:32.500
<v Speaker 0>dash in the right, and I read an A, then

NOTE CONF {"raw":[56,100,100,100,100,100,100,100,100,100]}

00:34:32.500 --> 00:34:36.580
<v Speaker 0>I run the left hand one to get to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:36.580 --> 00:34:38.889
<v Speaker 0>new state there, and I run the right hand one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:38.889 --> 00:34:40.540
<v Speaker 0>to get to the new state there.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:34:42.760 --> 00:34:45.520
<v Speaker 0>So what does this look like pictorially?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:34:48.070 --> 00:34:53.560
<v Speaker 0>Here is a product automaton.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:53.830 --> 00:34:56.110
<v Speaker 0>So this is the thing we saw yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:34:57.850 --> 00:34:59.980
<v Speaker 0>These are two simpler automata.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:00.550 --> 00:35:03.490
<v Speaker 0>If you look at this thing on the left, what

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:03.490 --> 00:35:04.270
<v Speaker 0>does it do?

NOTE CONF {"raw":[100,100,100]}

00:35:04.300 --> 00:35:05.230
<v Speaker 0>The thing in red.

NOTE CONF {"raw":[100,100,100,100]}

00:35:05.920 --> 00:35:11.200
<v Speaker 0>This is an automaton that reads zeros and flips back

NOTE CONF {"raw":[100,100,100,100,100,100,84,100,100,100]}

00:35:11.200 --> 00:35:14.620
<v Speaker 0>and forward between zeros even and zeros.

NOTE CONF {"raw":[100,100,100,100,100,100,96]}

00:35:14.620 --> 00:35:17.300
<v Speaker 0>aud and it does nothing at all.

NOTE CONF {"raw":[49,100,100,100,100,100,100]}

00:35:17.300 --> 00:35:20.090
<v Speaker 0>It reads the ones, but just stays where it is.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:20.270 --> 00:35:23.300
<v Speaker 0>So this is an automaton that just counts the zeros

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,87]}

00:35:23.300 --> 00:35:24.530
<v Speaker 0>in the input string.

NOTE CONF {"raw":[100,100,100,100]}

00:35:26.510 --> 00:35:29.540
<v Speaker 0>And it's good when there's an even number of zeros.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,96]}

00:35:30.830 --> 00:35:35.810
<v Speaker 0>The blue thing here is another very simple automaton.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:35:36.980 --> 00:35:39.470
<v Speaker 0>It counts the ones in the input strings, so it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:39.470 --> 00:35:42.380
<v Speaker 0>flips back and forward between an even number of ones

NOTE CONF {"raw":[100,100,100,54,100,100,100,100,100,100]}

00:35:42.380 --> 00:35:44.000
<v Speaker 0>and an odd number of ones.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:44.240 --> 00:35:46.340
<v Speaker 0>It doesn't care about the zeros.

NOTE CONF {"raw":[100,100,100,100,100,89]}

00:35:48.530 --> 00:35:51.800
<v Speaker 0>And this is good when the number of ones is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:51.800 --> 00:35:52.370
<v Speaker 0>odd.

NOTE CONF {"raw":[100]}

00:35:53.090 --> 00:35:56.990
<v Speaker 0>So if we have a string that is satisfied by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:56.990 --> 00:35:59.030
<v Speaker 0>both of these things, we have a string which has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:59.030 --> 00:36:01.970
<v Speaker 0>an even number of zeros and an even number of

NOTE CONF {"raw":[100,100,100,100,94,100,100,100,100,100]}

00:36:01.970 --> 00:36:05.300
<v Speaker 0>odds, which is the thing we tried to build yesterday

NOTE CONF {"raw":[98,100,100,100,100,100,99,100,100,100]}

00:36:05.300 --> 00:36:06.320
<v Speaker 0>from scratch.

NOTE CONF {"raw":[100,100]}

00:36:07.700 --> 00:36:12.380
<v Speaker 0>But if you look at what goes on here and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:12.380 --> 00:36:15.020
<v Speaker 0>you construct the automaton, so let's do it bit by

NOTE CONF {"raw":[100,100,100,100,100,67,100,100,100,100]}

00:36:15.020 --> 00:36:17.960
<v Speaker 0>bit for two states here.

NOTE CONF {"raw":[100,62,100,100,100]}

00:36:17.960 --> 00:36:19.280
<v Speaker 0>There are two states here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:19.280 --> 00:36:21.740
<v Speaker 0>So they are going to be two times two for

NOTE CONF {"raw":[100,86,86,100,100,100,100,100,100,71]}

00:36:21.740 --> 00:36:22.910
<v Speaker 0>states over here.

NOTE CONF {"raw":[100,100,100]}

00:36:23.060 --> 00:36:24.260
<v Speaker 0>What are the states.

NOTE CONF {"raw":[100,100,100,100]}

00:36:24.260 --> 00:36:27.170
<v Speaker 0>They are simply the pairs of the states in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:27.170 --> 00:36:28.190
<v Speaker 0>two halves.

NOTE CONF {"raw":[100,100]}

00:36:28.340 --> 00:36:33.140
<v Speaker 0>So E0 and e1 gives us a state here E0

NOTE CONF {"raw":[100,100,100,100,100,100,94,100,100,84]}

00:36:33.140 --> 00:36:37.970
<v Speaker 0>and O1 gives us a state there 0010001.

NOTE CONF {"raw":[100,94,100,100,99,100,77,64]}

00:36:37.970 --> 00:36:40.820
<v Speaker 0>So we now have states on the right hand side

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:40.820 --> 00:36:44.720
<v Speaker 0>which are combinations of states on the left of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:44.720 --> 00:36:46.460
<v Speaker 0>halves here.

NOTE CONF {"raw":[100,100]}

00:36:47.960 --> 00:36:50.390
<v Speaker 0>If you then look at the transition function it does

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:50.390 --> 00:36:51.530
<v Speaker 0>the obvious thing.

NOTE CONF {"raw":[100,100,100]}

00:36:51.530 --> 00:36:57.080
<v Speaker 0>So here the transition function for one on the e

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:57.290 --> 00:36:59.840
<v Speaker 0>on the zero half, it takes us from even to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:59.840 --> 00:37:00.530
<v Speaker 0>even.

NOTE CONF {"raw":[100]}

00:37:00.680 --> 00:37:03.980
<v Speaker 0>And on the one half it takes us from even

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:03.980 --> 00:37:04.700
<v Speaker 0>to odd.

NOTE CONF {"raw":[100,100]}

00:37:05.930 --> 00:37:09.170
<v Speaker 0>And this is what that definition does for those two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:09.170 --> 00:37:10.280
<v Speaker 0>constructions.

NOTE CONF {"raw":[100]}

00:37:12.570 --> 00:37:15.330
<v Speaker 0>If you think about how this thing runs, the product

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:15.330 --> 00:37:22.020
<v Speaker 0>automaton is essentially running these two machines in parallel.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:37:22.140 --> 00:37:26.160
<v Speaker 0>So the initial state of the two machines, if you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:26.160 --> 00:37:29.460
<v Speaker 0>had them running separately, just feeding them the same input

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:37:29.460 --> 00:37:30.570
<v Speaker 0>would be like this.

NOTE CONF {"raw":[100,100,100,100]}

00:37:31.020 --> 00:37:33.510
<v Speaker 0>This gives you the initial state of the product.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:37:35.130 --> 00:37:41.310
<v Speaker 0>I read some input, read the zero say in the

NOTE CONF {"raw":[100,100,100,100,100,87,100,96,100,100]}

00:37:41.310 --> 00:37:43.830
<v Speaker 0>left hand in the broken down automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:37:43.860 --> 00:37:45.750
<v Speaker 0>Then I see this one move and I see this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:45.750 --> 00:37:48.030
<v Speaker 0>one go back to where it is.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:37:48.030 --> 00:37:53.250
<v Speaker 0>And that corresponds to the movement here in the product

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:53.250 --> 00:37:54.120
<v Speaker 0>automaton.

NOTE CONF {"raw":[100]}

00:37:54.510 --> 00:37:56.700
<v Speaker 0>And everything keeps working like that.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:56.700 --> 00:37:58.500
<v Speaker 0>So how far am I going to do this?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:37:58.530 --> 00:37:59.820
<v Speaker 0>It gets a bit boring, doesn't it?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:03.000 --> 00:38:03.450
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:38:07.560 --> 00:38:13.120
<v Speaker 0>This was quite a nice construction.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:13.720 --> 00:38:16.750
<v Speaker 0>Um, there were a couple of ways one could think

NOTE CONF {"raw":[100,100,87,100,100,100,100,100,100,100]}

00:38:16.750 --> 00:38:17.500
<v Speaker 0>about doing it.

NOTE CONF {"raw":[100,100,100]}

00:38:17.500 --> 00:38:21.490
<v Speaker 0>So before I talk about the on the fly stuff,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:21.490 --> 00:38:22.720
<v Speaker 0>do you see what I'm doing there?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:22.720 --> 00:38:25.990
<v Speaker 0>When I just connect the automaton together, run them in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:25.990 --> 00:38:29.050
<v Speaker 0>parallel, feeding the input both at the same time?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:38:34.540 --> 00:38:37.510
<v Speaker 0>That's a fairly intuitive construction.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:37.750 --> 00:38:40.210
<v Speaker 0>You should ask yourself about black hole states.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:38:41.770 --> 00:38:48.910
<v Speaker 0>Um, one thing that you might wonder is, do I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:48.910 --> 00:38:50.740
<v Speaker 0>need to build the whole thing?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:51.160 --> 00:38:54.190
<v Speaker 0>So this thing is a mathematical definition.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:54.400 --> 00:38:58.480
<v Speaker 0>It defines an entire product or automaton with every conceivable

NOTE CONF {"raw":[100,100,100,100,100,82,100,100,100,100]}

00:38:58.480 --> 00:38:59.470
<v Speaker 0>state in it.

NOTE CONF {"raw":[100,100,100]}

00:39:01.180 --> 00:39:04.990
<v Speaker 0>Every possible combination of states in the two halves.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:39:06.100 --> 00:39:10.030
<v Speaker 0>And sometimes it might be more efficient to start at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:10.030 --> 00:39:13.180
<v Speaker 0>the beginning state and just build the states up as

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:13.180 --> 00:39:14.050
<v Speaker 0>you need them.

NOTE CONF {"raw":[100,100,100]}

00:39:14.050 --> 00:39:19.450
<v Speaker 0>So if I were building this in an incremental way,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:19.900 --> 00:39:23.470
<v Speaker 0>then I would start here and say, well, look, I've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:23.470 --> 00:39:26.800
<v Speaker 0>got E and E0, so I've got E0 and E1,

NOTE CONF {"raw":[100,100,100,58,100,100,100,75,100,100]}

00:39:27.760 --> 00:39:31.870
<v Speaker 0>I do a transition, something happens.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:31.930 --> 00:39:34.360
<v Speaker 0>Now I find myself in a state which must be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:34.360 --> 00:39:36.610
<v Speaker 0>called zero, zero and E1.

NOTE CONF {"raw":[100,60,86,100,98]}

00:39:36.790 --> 00:39:38.830
<v Speaker 0>So I know that's in the automaton.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:39:39.910 --> 00:39:42.400
<v Speaker 0>And as I run through I will add states to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:42.400 --> 00:39:43.420
<v Speaker 0>my construction.

NOTE CONF {"raw":[100,100]}

00:39:43.420 --> 00:39:46.780
<v Speaker 0>The reason this is sometimes useful is because sometimes automata

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:46.780 --> 00:39:49.360
<v Speaker 0>have a lot of states that are never actually reached.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:49.780 --> 00:39:55.450
<v Speaker 0>And it if your product automaton has the property that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:55.450 --> 00:39:57.430
<v Speaker 0>most of the states are never reached, it can save

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:57.430 --> 00:40:00.250
<v Speaker 0>a lot of space because.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:00.250 --> 00:40:01.450
<v Speaker 0>Quick question.

NOTE CONF {"raw":[100,100]}

00:40:01.450 --> 00:40:07.930
<v Speaker 0>If M and M have size n, what's the size

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:07.930 --> 00:40:09.350
<v Speaker 0>of the product automaton.

NOTE CONF {"raw":[100,100,100,100]}

00:40:15.320 --> 00:40:20.840
<v Speaker 0>N squared n times n because Cartesian product has n

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:20.840 --> 00:40:27.080
<v Speaker 0>times n possible pairs of states, and generally that's bad.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:27.080 --> 00:40:31.130
<v Speaker 0>So if we can, we want to try to avoid

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:31.130 --> 00:40:34.220
<v Speaker 0>making automata big.

NOTE CONF {"raw":[100,100,100]}

00:40:34.220 --> 00:40:36.530
<v Speaker 0>This is actually why we don't tend to use the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:36.530 --> 00:40:40.700
<v Speaker 0>intersection operator very much in practice, because intersecting automaton makes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:40.700 --> 00:40:41.450
<v Speaker 0>them bigger.

NOTE CONF {"raw":[100,100]}

00:40:43.070 --> 00:40:46.520
<v Speaker 0>Also, often it's not clear why we want to do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:46.520 --> 00:40:46.730
<v Speaker 0>it.

NOTE CONF {"raw":[100]}

00:40:46.730 --> 00:40:51.080
<v Speaker 0>It's relatively rare to have an application where you say,

NOTE CONF {"raw":[100,100,100,100,100,84,100,100,100,100]}

00:40:51.080 --> 00:40:53.900
<v Speaker 0>I want a string to be in two languages, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:53.900 --> 00:40:54.770
<v Speaker 0>it does happen.

NOTE CONF {"raw":[100,100,100]}

00:40:59.600 --> 00:41:00.050
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:41:02.930 --> 00:41:09.410
<v Speaker 0>We've talked now about building Strings that are accepted by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:09.410 --> 00:41:11.570
<v Speaker 0>both automata at the same time.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:12.140 --> 00:41:14.780
<v Speaker 0>What's the other obvious thing we could ask about?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:41:14.780 --> 00:41:18.470
<v Speaker 0>Two automata or two languages.

NOTE CONF {"raw":[100,100,100,100,100]}

00:41:23.720 --> 00:41:24.140
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:41:26.420 --> 00:41:26.930
<v Speaker 0>Say again.

NOTE CONF {"raw":[64,95]}

00:41:28.760 --> 00:41:31.040
<v Speaker 0>So I can't quite hear.

NOTE CONF {"raw":[100,60,100,100,100]}

00:41:34.550 --> 00:41:39.710
<v Speaker 0>You say you need to shout louder for me to

NOTE CONF {"raw":[86,98,100,100,92,100,100,100,100,100]}

00:41:39.710 --> 00:41:40.250
<v Speaker 0>hear them.

NOTE CONF {"raw":[100,89]}

00:41:43.880 --> 00:41:44.270
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:41:49.010 --> 00:41:54.110
<v Speaker 0>In this university, a PhD thesis can be written in

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:41:54.110 --> 00:41:55.670
<v Speaker 0>either English or Gaelic.

NOTE CONF {"raw":[100,100,100,100]}

00:41:57.560 --> 00:42:01.190
<v Speaker 0>So possibly I might want to consider strings that are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:01.190 --> 00:42:03.200
<v Speaker 0>in the union of two languages.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:06.480 --> 00:42:06.930
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:42:07.290 --> 00:42:13.800
<v Speaker 0>So another thing we might ask is given an input,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:15.360 --> 00:42:18.030
<v Speaker 0>is it in one language or the other?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:18.060 --> 00:42:20.550
<v Speaker 0>Now this is something that is actually used much more

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:20.550 --> 00:42:21.510
<v Speaker 0>in practice.

NOTE CONF {"raw":[100,100]}

00:42:21.510 --> 00:42:24.030
<v Speaker 0>Because if you think about trying to describe a programming

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:24.030 --> 00:42:27.750
<v Speaker 0>language, programming languages have lots of constructions in them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:42:28.140 --> 00:42:30.480
<v Speaker 0>Each one gives you a valid construction.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:42:30.480 --> 00:42:33.480
<v Speaker 0>So a function definition, a list, a function application or

NOTE CONF {"raw":[100,100,100,100,100,100,87,100,100,100]}

00:42:33.480 --> 00:42:39.060
<v Speaker 0>whatever, and a string of characters is a good part

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:39.060 --> 00:42:40.320
<v Speaker 0>of the programming language.

NOTE CONF {"raw":[100,100,100,100]}

00:42:40.320 --> 00:42:43.980
<v Speaker 0>If it's a good function definition or a function application

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:43.980 --> 00:42:46.260
<v Speaker 0>or expression or whatever your language has.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:42:46.650 --> 00:42:52.140
<v Speaker 0>So building up regular expressions by taking the union of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:52.230 --> 00:42:55.140
<v Speaker 0>things is something that we do all the time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:42:56.910 --> 00:43:01.740
<v Speaker 0>Um, I've just accidentally used the term regular expression, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:01.740 --> 00:43:03.810
<v Speaker 0>I was trying not to use yet.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:43:04.960 --> 00:43:07.960
<v Speaker 0>How many people already use regular expressions?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:43:10.720 --> 00:43:12.910
<v Speaker 0>Okay, so the rest of you.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:13.330 --> 00:43:17.320
<v Speaker 0>Next week we will talk about regular expressions here, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:17.320 --> 00:43:19.630
<v Speaker 0>then go away and find out about them because they

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:19.630 --> 00:43:20.860
<v Speaker 0>are incredibly useful.

NOTE CONF {"raw":[100,100,100]}

00:43:20.860 --> 00:43:23.530
<v Speaker 0>If you have a decent search facility that allows you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:23.530 --> 00:43:29.440
<v Speaker 0>to specify regular expressions, and if you do things like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:29.440 --> 00:43:35.950
<v Speaker 0>searching for email, matching a particular property, then looking for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:35.950 --> 00:43:39.220
<v Speaker 0>things that are the union of two things is something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:39.220 --> 00:43:40.150
<v Speaker 0>I do a lot.

NOTE CONF {"raw":[100,100,100,100]}

00:43:40.150 --> 00:43:43.270
<v Speaker 0>For example, I need to search my mail frequently to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:43.270 --> 00:43:46.000
<v Speaker 0>find something I might have forgotten, and I can remember

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:46.000 --> 00:43:48.250
<v Speaker 0>that it may have been from one of three people

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:48.250 --> 00:43:50.170
<v Speaker 0>because they were the people involved.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:50.170 --> 00:43:52.720
<v Speaker 0>So I want to search my mail for mail that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:52.720 --> 00:43:55.330
<v Speaker 0>is from Joe Bloggs.

NOTE CONF {"raw":[100,100,100,100]}

00:43:55.480 --> 00:44:03.880
<v Speaker 0>Don John Doe or Ann Ferguson say So because I

NOTE CONF {"raw":[100,100,100,100,79,96,86,100,100,100]}

00:44:03.880 --> 00:44:07.120
<v Speaker 0>use a civilised mail client, I can do things like

NOTE CONF {"raw":[100,100,67,63,100,100,100,100,100,100]}

00:44:07.120 --> 00:44:07.450
<v Speaker 0>that.

NOTE CONF {"raw":[100]}

00:44:07.450 --> 00:44:12.670
<v Speaker 0>I can use regular languages to describe the male that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:12.670 --> 00:44:13.690
<v Speaker 0>I want to search.

NOTE CONF {"raw":[100,100,100,100]}

00:44:13.690 --> 00:44:17.020
<v Speaker 0>And I can say, show me all the males from

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:17.020 --> 00:44:19.540
<v Speaker 0>this person or this person or this person.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:44:20.680 --> 00:44:25.390
<v Speaker 0>And because regular regular languages allow you a lot of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:25.390 --> 00:44:27.610
<v Speaker 0>slop, I can do more sophisticated things.

NOTE CONF {"raw":[79,100,100,100,100,100,100]}

00:44:27.610 --> 00:44:29.290
<v Speaker 0>Even if I can't remember their names.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:44:29.290 --> 00:44:31.240
<v Speaker 0>It doesn't matter as long as I can remember part

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:31.240 --> 00:44:32.230
<v Speaker 0>of their names.

NOTE CONF {"raw":[100,100,100]}

00:44:32.980 --> 00:44:38.590
<v Speaker 0>Um, so if you are doing things on any reasonable

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:44:39.040 --> 00:44:42.190
<v Speaker 0>information system, it should provide you with a way of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:42.190 --> 00:44:43.750
<v Speaker 0>doing wildcard searches.

NOTE CONF {"raw":[100,98,100]}

00:44:43.750 --> 00:44:46.420
<v Speaker 0>If I say wildcard search, does that mean something to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:46.420 --> 00:44:47.230
<v Speaker 0>more people?

NOTE CONF {"raw":[100,100]}

00:44:48.430 --> 00:44:49.090
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:44:49.300 --> 00:44:53.200
<v Speaker 0>So that's also implemented by means of regular languages.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:44:54.850 --> 00:44:58.480
<v Speaker 0>So this is one of the basic things looking for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:58.480 --> 00:45:00.190
<v Speaker 0>the union of two languages.

NOTE CONF {"raw":[100,100,100,100,100]}

00:45:00.460 --> 00:45:03.830
<v Speaker 0>And the curious thing is that the construction is almost

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:03.830 --> 00:45:09.200
<v Speaker 0>identical, which is a bit odd because we would expect

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:09.680 --> 00:45:12.020
<v Speaker 0>some kind of sum to be rather different from some

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,100]}

00:45:12.020 --> 00:45:13.070
<v Speaker 0>kind of product.

NOTE CONF {"raw":[100,100,100]}

00:45:13.640 --> 00:45:17.060
<v Speaker 0>But in this case of deterministic automata, I'm going to

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100,100]}

00:45:17.060 --> 00:45:19.640
<v Speaker 0>define this slightly complicated looking beast.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:45:20.900 --> 00:45:25.340
<v Speaker 0>So m and m prime are as before.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:25.340 --> 00:45:26.990
<v Speaker 0>They are two automata.

NOTE CONF {"raw":[100,100,100,100]}

00:45:27.350 --> 00:45:30.950
<v Speaker 0>And I'm going to define a sum m plus deterministic

NOTE CONF {"raw":[100,99,100,100,100,100,100,100,100,100]}

00:45:30.950 --> 00:45:35.960
<v Speaker 0>of m prime almost exactly the same as before.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:45:36.950 --> 00:45:39.530
<v Speaker 0>So I'm running the two automata in parallel.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:39.530 --> 00:45:40.460
<v Speaker 0>This is the same.

NOTE CONF {"raw":[100,100,100,100]}

00:45:40.460 --> 00:45:41.120
<v Speaker 0>This is the same.

NOTE CONF {"raw":[100,100,100,100]}

00:45:41.120 --> 00:45:41.750
<v Speaker 0>This is the same.

NOTE CONF {"raw":[100,100,100,100]}

00:45:41.750 --> 00:45:42.770
<v Speaker 0>This is the same.

NOTE CONF {"raw":[100,100,100,100]}

00:45:42.860 --> 00:45:46.250
<v Speaker 0>The only difference is that I'm just changing the accepting

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:45:46.250 --> 00:45:47.030
<v Speaker 0>states.

NOTE CONF {"raw":[100]}

00:45:47.330 --> 00:45:50.270
<v Speaker 0>So when I build the product automaton, I said the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:50.270 --> 00:45:52.760
<v Speaker 0>accepting states are the ones that are good in both

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:52.760 --> 00:45:53.660
<v Speaker 0>automata.

NOTE CONF {"raw":[100]}

00:45:53.810 --> 00:45:56.480
<v Speaker 0>And now I'm simply saying that the accepting states are

NOTE CONF {"raw":[100,100,97,100,100,100,100,100,100,100]}

00:45:56.480 --> 00:45:59.150
<v Speaker 0>the ones that are good in either automaton.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:59.840 --> 00:46:01.470
<v Speaker 0>So what does this say?

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:01.470 --> 00:46:02.310
<v Speaker 0>This says.

NOTE CONF {"raw":[100,100]}

00:46:02.460 --> 00:46:05.250
<v Speaker 0>A state is good if it's any old state on

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:46:05.250 --> 00:46:08.340
<v Speaker 0>the left and a good state on the right, or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,69]}

00:46:08.340 --> 00:46:11.880
<v Speaker 0>alternatively, it's a good state on the left and any

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:11.880 --> 00:46:13.200
<v Speaker 0>old state on the right.

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:13.560 --> 00:46:18.210
<v Speaker 0>So this is exactly the same construction as before, just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:18.210 --> 00:46:20.430
<v Speaker 0>with a different set of accepting states.

NOTE CONF {"raw":[100,96,100,100,100,100,100]}

00:46:20.880 --> 00:46:25.020
<v Speaker 0>And that means that a string is accepted by this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:25.020 --> 00:46:26.100
<v Speaker 0>construct.

NOTE CONF {"raw":[100]}

00:46:26.400 --> 00:46:27.060
<v Speaker 0>Exactly.

NOTE CONF {"raw":[100]}

00:46:27.060 --> 00:46:30.450
<v Speaker 0>If it's accepted by either one or the other of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:30.450 --> 00:46:32.550
<v Speaker 0>the two halves, or both, of course.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:36.120 --> 00:46:36.510
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:46:39.060 --> 00:46:46.260
<v Speaker 0>I should at this point see how many people will

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:46.260 --> 00:46:47.940
<v Speaker 0>get something out of this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:48.660 --> 00:46:52.080
<v Speaker 0>Um, I wrote here all the states on the left

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:52.080 --> 00:46:54.870
<v Speaker 0>times, the good states on the right, all the good

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:54.870 --> 00:46:57.180
<v Speaker 0>states on the left, times the good state.

NOTE CONF {"raw":[100,100,100,100,100,100,100,47]}

00:46:57.180 --> 00:46:59.340
<v Speaker 0>Such times, all the states on the right.

NOTE CONF {"raw":[44,100,100,100,100,100,100,100]}

00:47:00.360 --> 00:47:05.610
<v Speaker 0>Another way of writing that is to say take all

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:05.610 --> 00:47:08.100
<v Speaker 0>the good, good states on the left.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:08.100 --> 00:47:10.530
<v Speaker 0>So I take all the good, all, take all the

NOTE CONF {"raw":[100,100,100,100,100,69,98,100,100,100]}

00:47:10.530 --> 00:47:14.490
<v Speaker 0>states in both automata, and subtract off the states that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:14.490 --> 00:47:16.080
<v Speaker 0>are bad in both of them.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:16.860 --> 00:47:19.860
<v Speaker 0>Now, which states are bad in both halves of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:19.860 --> 00:47:20.790
<v Speaker 0>construction?

NOTE CONF {"raw":[100]}

00:47:21.000 --> 00:47:23.550
<v Speaker 0>The state is bad in both halves.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:23.550 --> 00:47:26.250
<v Speaker 0>If it's in the bad states in the left half,

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:47:26.250 --> 00:47:29.010
<v Speaker 0>and the bad states in the right half.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:47:29.550 --> 00:47:32.220
<v Speaker 0>Now, if I take this slightly awkward notation and use

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:32.220 --> 00:47:36.600
<v Speaker 0>both complement as I have been using, I could write

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100,100]}

00:47:36.600 --> 00:47:41.550
<v Speaker 0>that as the bar of f bar times f bar

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:41.550 --> 00:47:42.660
<v Speaker 0>f prime bar.

NOTE CONF {"raw":[100,100,100]}

00:47:44.430 --> 00:47:48.570
<v Speaker 0>Um, does that remind you of anything at all?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:47:52.770 --> 00:47:54.930
<v Speaker 0>I think I heard somebody say something.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:58.090 --> 00:47:58.630
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:48:00.850 --> 00:48:03.640
<v Speaker 0>So I definitely heard somebody say something in that time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,52,100,100]}

00:48:04.150 --> 00:48:07.600
<v Speaker 0>Um, I remember the, the not of the and is

NOTE CONF {"raw":[100,67,100,100,100,89,100,100,63,100]}

00:48:07.600 --> 00:48:09.970
<v Speaker 0>the or of the knots and so on.

NOTE CONF {"raw":[100,100,100,100,51,100,100,100]}

00:48:10.570 --> 00:48:14.170
<v Speaker 0>So we've got a relationship here of negation between some

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:14.170 --> 00:48:15.040
<v Speaker 0>and product.

NOTE CONF {"raw":[100,100]}

00:48:15.310 --> 00:48:18.820
<v Speaker 0>The sum of two automata has a set of final

NOTE CONF {"raw":[100,95,100,100,100,100,100,100,100,100]}

00:48:18.820 --> 00:48:24.910
<v Speaker 0>states, which is the complement of the product of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:24.910 --> 00:48:26.410
<v Speaker 0>complement of the states.

NOTE CONF {"raw":[100,100,100,100]}

00:48:27.490 --> 00:48:33.820
<v Speaker 0>So that's not a coincidence because union intersection are or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,38,100]}

00:48:33.820 --> 00:48:37.510
<v Speaker 0>an and and so there's some Demogorgon like stuff going

NOTE CONF {"raw":[93,100,100,100,100,100,82,100,100,100]}

00:48:37.510 --> 00:48:40.510
<v Speaker 0>on here or in the the word that I use

NOTE CONF {"raw":[100,100,100,100,94,100,100,100,100,100]}

00:48:40.510 --> 00:48:41.230
<v Speaker 0>a lot.

NOTE CONF {"raw":[100,100]}

00:48:42.790 --> 00:48:43.630
<v Speaker 0>Duality.

NOTE CONF {"raw":[100]}

00:48:45.250 --> 00:48:47.770
<v Speaker 0>So what have I done in the course of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:47.770 --> 00:48:49.990
<v Speaker 0>last half hour?

NOTE CONF {"raw":[100,100,100]}

00:48:50.020 --> 00:48:53.470
<v Speaker 0>We've built up automata from smaller automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:48:55.000 --> 00:48:58.090
<v Speaker 0>And this has told us that if I take regular,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:58.090 --> 00:49:02.530
<v Speaker 0>regular languages and do things to them, they stay regular.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:02.530 --> 00:49:05.710
<v Speaker 0>For some things that I can do, I can take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:05.710 --> 00:49:08.530
<v Speaker 0>a language, I can complement it, and it's still a

NOTE CONF {"raw":[100,100,100,100,52,100,100,100,100,100]}

00:49:08.530 --> 00:49:09.640
<v Speaker 0>regular language.

NOTE CONF {"raw":[100,100]}

00:49:09.700 --> 00:49:15.160
<v Speaker 0>I can take two regular language, two regular languages intersect

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:15.160 --> 00:49:18.280
<v Speaker 0>them, and that's a regular language, because I can build

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:18.280 --> 00:49:21.130
<v Speaker 0>an automaton that accepts it, and I can take two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:21.130 --> 00:49:23.530
<v Speaker 0>languages and take their union.

NOTE CONF {"raw":[100,100,100,100,100]}

00:49:23.530 --> 00:49:26.140
<v Speaker 0>And that's still a regular language, because I can build

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:26.140 --> 00:49:28.870
<v Speaker 0>this automaton that accepts it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:49:29.680 --> 00:49:33.790
<v Speaker 0>That's quite a useful and powerful set of things to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:33.790 --> 00:49:35.740
<v Speaker 0>be able to do to a language, because it's the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,100]}

00:49:35.740 --> 00:49:36.850
<v Speaker 0>logical operations.

NOTE CONF {"raw":[100,100]}

00:49:36.850 --> 00:49:37.750
<v Speaker 0>It's not.

NOTE CONF {"raw":[100,100]}

00:49:37.750 --> 00:49:42.940
<v Speaker 0>And an or so that means I can manipulate languages

NOTE CONF {"raw":[100,63,100,100,100,100,100,100,100,100]}

00:49:43.060 --> 00:49:46.900
<v Speaker 0>with logical operators and be confident that I can build

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:46.900 --> 00:49:50.530
<v Speaker 0>automata to recognise them if I want to, which is

NOTE CONF {"raw":[100,100,96,100,100,100,100,100,100,100]}

00:49:50.530 --> 00:49:54.670
<v Speaker 0>how such search facilities in civilised databases and the like

NOTE CONF {"raw":[100,72,100,100,100,93,100,100,100,100]}

00:49:54.670 --> 00:49:55.270
<v Speaker 0>work.

NOTE CONF {"raw":[100]}

00:49:56.960 --> 00:49:57.320
<v Speaker 0>Um.

NOTE CONF {"raw":[97]}

00:49:57.680 --> 00:49:58.760
<v Speaker 0>Again.

NOTE CONF {"raw":[89]}

00:49:59.030 --> 00:50:01.370
<v Speaker 0>Think about what you should do with the black hole

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:01.370 --> 00:50:02.180
<v Speaker 0>states.

NOTE CONF {"raw":[100]}

00:50:03.440 --> 00:50:07.940
<v Speaker 0>So next week we will go on and generalise this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:07.940 --> 00:50:08.870
<v Speaker 0>a bit further.

NOTE CONF {"raw":[100,100,100]}

00:50:08.870 --> 00:50:12.890
<v Speaker 0>I've been talking about deterministic automata, so I should tell

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:12.890 --> 00:50:16.370
<v Speaker 0>you what nondeterministic automata are.

NOTE CONF {"raw":[100,100,50,100,100]}

00:50:17.000 --> 00:50:18.680
<v Speaker 0>They are a very weird thing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:50:18.680 --> 00:50:21.320
<v Speaker 0>So I'll spend some time next week talking about the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:21.320 --> 00:50:22.250
<v Speaker 0>weirdness of them.

NOTE CONF {"raw":[100,100,100]}

00:50:22.250 --> 00:50:24.500
<v Speaker 0>But they're also a very useful thing.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:24.500 --> 00:50:26.750
<v Speaker 0>They're one of those things that we can invent as

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:26.750 --> 00:50:30.050
<v Speaker 0>mathematicians, even though they have no physical reality.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:50:30.050 --> 00:50:34.940
<v Speaker 0>And they make using these regular languages much, much easier,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:34.940 --> 00:50:36.560
<v Speaker 0>as you will see.

NOTE CONF {"raw":[100,100,100,100]}

00:50:36.770 --> 00:50:40.670
<v Speaker 0>So please, before next week, go over this stuff and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:40.670 --> 00:50:44.630
<v Speaker 0>come back on Thursday with any questions you have, because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:44.630 --> 00:50:46.880
<v Speaker 0>we need to get the questions sorted out before going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:46.880 --> 00:50:52.520
<v Speaker 0>on and finishing what is actually the final compulsory topic

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:52.520 --> 00:50:53.720
<v Speaker 0>of the course?

NOTE CONF {"raw":[100,100,100]}

00:50:54.720 --> 00:50:57.360
<v Speaker 0>There are some non compulsory stuff in week 11 for

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:50:57.360 --> 00:50:58.680
<v Speaker 0>anybody who want it.

NOTE CONF {"raw":[100,100,35,55]}

00:50:59.460 --> 00:51:02.970
<v Speaker 0>Okay so it's 3:00 now it's one minute past.

NOTE CONF {"raw":[100,100,100,100,87,100,100,100,95]}

00:51:03.420 --> 00:51:04.050
<v Speaker 0>Beg your pardon.

NOTE CONF {"raw":[100,100,100]}
