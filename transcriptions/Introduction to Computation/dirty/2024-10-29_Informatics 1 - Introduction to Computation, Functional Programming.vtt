WEBVTT

00:00:00.150 --> 00:00:01.800
<v Unknown>That was me.

NOTE CONF {"raw":[100,100,99]}

00:00:01.800 --> 00:00:04.140
<v Unknown>His last.

NOTE CONF {"raw":[33,16]}

00:00:05.370 --> 00:00:12.030
<v Unknown>Me a song last that is gonna say that was

NOTE CONF {"raw":[100,100,100,32,92,100,47,60,97,80]}

00:00:12.390 --> 00:00:20.040
<v Unknown>behind every song she sang on a date.

NOTE CONF {"raw":[90,99,100,100,98,100,74,41]}

00:00:20.430 --> 00:00:23.670
<v Unknown>Oh, you wanna see?

NOTE CONF {"raw":[100,90,67,100]}

00:00:24.330 --> 00:00:29.010
<v Unknown>She's fine.

NOTE CONF {"raw":[98,50]}

00:00:34.500 --> 00:00:35.220
<v Speaker 0>The bad news is.

NOTE CONF {"raw":[100,100,100,100]}

00:00:35.820 --> 00:00:36.750
<v Speaker 1>So.

NOTE CONF {"raw":[84]}

00:00:36.990 --> 00:00:37.440
<v Speaker 1>Uh.

NOTE CONF {"raw":[100]}

00:00:37.440 --> 00:00:38.160
<v Speaker 1>Good afternoon.

NOTE CONF {"raw":[100,100]}

00:00:38.160 --> 00:00:40.920
<v Speaker 1>That was the theme from Outlander TV series.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:00:40.920 --> 00:00:43.620
<v Speaker 1>I thought since we're in Scotland, we should have at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:43.620 --> 00:00:47.160
<v Speaker 1>least one song involving bagpipes and kilts and things.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:00:47.160 --> 00:00:48.990
<v Speaker 1>So that was that, was it?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:00:49.260 --> 00:00:50.550
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[100,100]}

00:00:50.550 --> 00:00:55.260
<v Speaker 1>Before the lecture starts, we have, uh, uh, announcements from,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:55.260 --> 00:00:58.980
<v Speaker 1>uh, from Casper and Kotlin cloud print.

NOTE CONF {"raw":[100,100,72,100,100,63,51]}

00:00:59.010 --> 00:01:00.960
<v Speaker 1>Yeah about that.

NOTE CONF {"raw":[96,100,100]}

00:01:01.710 --> 00:01:02.250
<v Speaker 2>Hi everyone.

NOTE CONF {"raw":[100,100]}

00:01:02.250 --> 00:01:02.940
<v Speaker 2>My name is Casper.

NOTE CONF {"raw":[100,100,100,58]}

00:01:02.940 --> 00:01:05.220
<v Speaker 2>I am your first year rep for Comstock this year.

NOTE CONF {"raw":[100,100,100,100,100,100,100,75,100,100]}

00:01:05.550 --> 00:01:07.650
<v Speaker 2>I'm just here to talk to you guys about Comstock

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:07.650 --> 00:01:08.340
<v Speaker 2>in general.

NOTE CONF {"raw":[100,100]}

00:01:08.640 --> 00:01:10.470
<v Speaker 2>Um, I assume many of you here are in for

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,85,57]}

00:01:10.530 --> 00:01:10.980
<v Speaker 2>accidents.

NOTE CONF {"raw":[81]}

00:01:10.980 --> 00:01:12.390
<v Speaker 2>If you're not, there's no worries.

NOTE CONF {"raw":[100,100,100,98,100,100]}

00:01:12.600 --> 00:01:14.850
<v Speaker 2>We want to get as many people involved with Comstock

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:14.850 --> 00:01:15.510
<v Speaker 2>as possible.

NOTE CONF {"raw":[100,100]}

00:01:15.510 --> 00:01:16.830
<v Speaker 2>It's a great society.

NOTE CONF {"raw":[100,100,100,100]}

00:01:16.830 --> 00:01:18.120
<v Speaker 2>There's a lot of events going on.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:01:18.120 --> 00:01:20.460
<v Speaker 2>We have Hackenberg coming on, which is sort of a

NOTE CONF {"raw":[100,100,92,100,100,100,100,100,100,100]}

00:01:20.460 --> 00:01:21.180
<v Speaker 2>hackathon.

NOTE CONF {"raw":[100]}

00:01:21.180 --> 00:01:24.630
<v Speaker 2>We have we have ponied and we have the ball

NOTE CONF {"raw":[100,100,100,100,26,100,100,100,100,91]}

00:01:24.630 --> 00:01:25.950
<v Speaker 2>during other parts of the year.

NOTE CONF {"raw":[100,61,100,100,100,100]}

00:01:25.950 --> 00:01:28.200
<v Speaker 2>So things like the Informatics ball, they're not actually organised

NOTE CONF {"raw":[100,100,100,65,93,96,79,100,100,100]}

00:01:28.200 --> 00:01:31.170
<v Speaker 2>by the School of Informatics, but they're organised by Comstock.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:31.320 --> 00:01:33.030
<v Speaker 2>So just in general, what I'm here to tell you

NOTE CONF {"raw":[100,100,100,100,72,100,100,100,100,100]}

00:01:33.030 --> 00:01:35.220
<v Speaker 2>guys about is just if you haven't already, please get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:35.220 --> 00:01:35.970
<v Speaker 2>involved with Comstock.

NOTE CONF {"raw":[100,100,100]}

00:01:35.970 --> 00:01:37.500
<v Speaker 2>There's a lot of fun events coming up.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:01:37.770 --> 00:01:38.910
<v Speaker 2>Um, first events weekly.

NOTE CONF {"raw":[95,90,100,100]}

00:01:38.910 --> 00:01:40.740
<v Speaker 2>If you have discord, join our discord server.

NOTE CONF {"raw":[100,100,100,100,100,100,100,98]}

00:01:40.740 --> 00:01:41.610
<v Speaker 2>About QR code.

NOTE CONF {"raw":[79,100,98]}

00:01:42.210 --> 00:01:44.100
<v Speaker 2>Um, and yeah, if any of you guys are coming

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:44.100 --> 00:01:46.500
<v Speaker 2>to the Comstock Halloween party tonight, I'll see you there.

NOTE CONF {"raw":[100,93,100,100,100,97,100,100,100,100]}

00:01:47.190 --> 00:01:48.750
<v Speaker 2>I'll now pass on to Cochran, who will talk to

NOTE CONF {"raw":[100,100,100,100,100,44,100,100,100,100]}

00:01:48.750 --> 00:01:49.830
<v Speaker 2>you about Leipzig.

NOTE CONF {"raw":[100,100,100]}

00:01:53.460 --> 00:01:53.700
<v Speaker 3>Okay.

NOTE CONF {"raw":[100]}

00:01:53.700 --> 00:01:54.150
<v Speaker 3>So.

NOTE CONF {"raw":[100]}

00:01:54.150 --> 00:01:55.080
<v Speaker 3>Hello, everybody.

NOTE CONF {"raw":[100,100]}

00:01:55.140 --> 00:01:57.420
<v Speaker 3>Uh, I'm coldren I'm running Leipzig this year.

NOTE CONF {"raw":[58,100,71,100,100,100,100,100]}

00:01:57.660 --> 00:02:00.190
<v Speaker 3>Um, So this is Leipzig.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:00.190 --> 00:02:02.200
<v Speaker 3>That's the QR code for joining our discord server if

NOTE CONF {"raw":[100,75,100,100,100,100,100,100,100,100]}

00:02:02.200 --> 00:02:02.710
<v Speaker 3>you want.

NOTE CONF {"raw":[100,100]}

00:02:03.190 --> 00:02:04.450
<v Speaker 3>Um, what are we.

NOTE CONF {"raw":[100,100,100,100]}

00:02:05.200 --> 00:02:05.380
<v Speaker 3>Oh.

NOTE CONF {"raw":[100]}

00:02:05.380 --> 00:02:05.710
<v Speaker 3>Thank you.

NOTE CONF {"raw":[100,100]}

00:02:06.820 --> 00:02:10.450
<v Speaker 3>Um, so we are a society that is interested in

NOTE CONF {"raw":[52,100,100,100,100,100,100,100,100,100]}

00:02:10.450 --> 00:02:13.270
<v Speaker 3>theoretical computer science and how we can apply theory to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:13.270 --> 00:02:13.960
<v Speaker 3>practice.

NOTE CONF {"raw":[100]}

00:02:14.290 --> 00:02:16.600
<v Speaker 3>Um, so really, we're just a bunch of people who

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:16.600 --> 00:02:21.760
<v Speaker 3>are really curious about everything theoretical and especially programming languages.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:22.540 --> 00:02:24.640
<v Speaker 3>Now you guys are doing this course.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:24.880 --> 00:02:26.860
<v Speaker 3>Uh, in this course, there's a lot of talk about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:26.860 --> 00:02:27.580
<v Speaker 3>Haskell.

NOTE CONF {"raw":[100]}

00:02:27.640 --> 00:02:30.940
<v Speaker 3>There's a lot of talk about types and, uh, functional

NOTE CONF {"raw":[100,100,100,76,100,100,100,100,100,100]}

00:02:30.940 --> 00:02:31.630
<v Speaker 3>programming.

NOTE CONF {"raw":[100]}

00:02:32.080 --> 00:02:33.880
<v Speaker 3>Um, and I remember when I was doing this course,

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:02:33.880 --> 00:02:37.270
<v Speaker 3>I had these questions of, you know, there seems to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:37.270 --> 00:02:41.320
<v Speaker 3>be something, um, very deep and interesting here, um, about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:41.320 --> 00:02:44.020
<v Speaker 3>these functions, about these types, and that there is you

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:02:44.020 --> 00:02:47.410
<v Speaker 3>can construct programming languages with all sorts of type systems.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:02:47.860 --> 00:02:50.620
<v Speaker 3>Um, and some of these well, all of these are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:50.770 --> 00:02:51.760
<v Speaker 3>interesting in their own right.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:51.760 --> 00:02:54.100
<v Speaker 3>But some of these, for instance, can be used to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:54.340 --> 00:02:55.990
<v Speaker 3>encode improve math statements.

NOTE CONF {"raw":[100,75,96,100]}

00:02:56.320 --> 00:02:59.110
<v Speaker 3>Um, or do some other cool, interesting things.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:02:59.950 --> 00:03:02.200
<v Speaker 3>Um, here is practically what we do.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:03:02.770 --> 00:03:05.950
<v Speaker 3>So every Monday we have a workshop on the lean

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:05.950 --> 00:03:06.520
<v Speaker 3>theorem prover.

NOTE CONF {"raw":[100,100]}

00:03:06.520 --> 00:03:08.710
<v Speaker 3>So this is the one of the languages which allows

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:08.710 --> 00:03:10.960
<v Speaker 3>you to prove math in your programming language.

NOTE CONF {"raw":[100,100,100,98,100,100,100,100]}

00:03:11.650 --> 00:03:13.780
<v Speaker 3>Uh, we also have free pizza every Monday for that.

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:03:13.780 --> 00:03:16.570
<v Speaker 3>So if that's a pretty good reason to come along.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:17.110 --> 00:03:20.320
<v Speaker 3>Um, we have we're also very curious about trying to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:20.320 --> 00:03:22.120
<v Speaker 3>build our own language interpreter.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:22.570 --> 00:03:25.330
<v Speaker 3>Uh, we've called it Maker Lisp, but in fact, it's

NOTE CONF {"raw":[86,100,100,100,55,100,100,100,100,100]}

00:03:25.330 --> 00:03:26.050
<v Speaker 3>not a lisp.

NOTE CONF {"raw":[100,100,100]}

00:03:26.320 --> 00:03:27.160
<v Speaker 3>That's a secret.

NOTE CONF {"raw":[94,100,100]}

00:03:27.670 --> 00:03:30.430
<v Speaker 3>Uh, it has a Lisp syntax.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:30.430 --> 00:03:32.320
<v Speaker 3>So you write it as a Lisp, but it's more

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:32.320 --> 00:03:34.540
<v Speaker 3>of a of an ML language because we are planning

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:03:34.570 --> 00:03:35.620
<v Speaker 3>to add some types to it.

NOTE CONF {"raw":[100,100,100,98,100,100]}

00:03:36.310 --> 00:03:39.160
<v Speaker 3>Um, we give academic talks.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:39.160 --> 00:03:40.870
<v Speaker 3>The first one is going to be next week on

NOTE CONF {"raw":[100,100,91,91,100,100,100,100,100,100]}

00:03:40.870 --> 00:03:41.560
<v Speaker 3>Thursday.

NOTE CONF {"raw":[100]}

00:03:41.740 --> 00:03:43.570
<v Speaker 3>Uh, but more details on that on this code.

NOTE CONF {"raw":[82,100,100,100,100,100,100,55,51]}

00:03:44.110 --> 00:03:46.540
<v Speaker 3>And finally we go to the pub every Sunday where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:46.540 --> 00:03:49.450
<v Speaker 3>you can meet all sorts of people interested in types,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:49.450 --> 00:03:51.640
<v Speaker 3>programming languages and theory in general.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:52.120 --> 00:03:54.910
<v Speaker 3>Uh, there are free nuts at the pub, but if

NOTE CONF {"raw":[100,100,100,97,93,100,100,100,100,100]}

00:03:54.910 --> 00:03:57.350
<v Speaker 3>you have a nut allergy, You're also welcome to come.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:57.650 --> 00:03:59.360
<v Speaker 3>It's not something that should stop you.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:00.020 --> 00:04:02.240
<v Speaker 3>Um, so yeah, that's a QR code for that.

NOTE CONF {"raw":[100,89,100,100,100,100,100,50,75]}

00:04:02.240 --> 00:04:02.930
<v Speaker 3>And thank you.

NOTE CONF {"raw":[100,100,100]}

00:04:03.710 --> 00:04:03.980
<v Speaker 1>Hey.

NOTE CONF {"raw":[69]}

00:04:04.190 --> 00:04:04.880
<v Speaker 1>Thanks.

NOTE CONF {"raw":[100]}

00:04:05.180 --> 00:04:05.390
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:04:07.520 --> 00:04:07.850
<v Speaker 1>It's.

NOTE CONF {"raw":[52]}

00:04:12.440 --> 00:04:12.800
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:12.800 --> 00:04:13.610
<v Speaker 1>Thanks for that.

NOTE CONF {"raw":[100,100,100]}

00:04:13.700 --> 00:04:14.330
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:04:16.790 --> 00:04:17.150
<v Speaker 1>Of course.

NOTE CONF {"raw":[100,100]}

00:04:17.150 --> 00:04:18.769
<v Speaker 1>This is, uh, near to my heart.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:18.769 --> 00:04:19.790
<v Speaker 1>This kind of stuff.

NOTE CONF {"raw":[100,100,100,100]}

00:04:19.790 --> 00:04:23.000
<v Speaker 1>But, uh, but today I'm going to be talking about,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:23.000 --> 00:04:26.090
<v Speaker 1>um, I'm going to be finishing up on data abstraction

NOTE CONF {"raw":[82,100,100,100,100,100,100,100,100,100]}

00:04:26.090 --> 00:04:31.190
<v Speaker 1>and, uh, also talking about laziness and sorting.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:31.190 --> 00:04:32.930
<v Speaker 1>So I've got a lot of stuff today.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:33.230 --> 00:04:35.390
<v Speaker 1>Uh, and so I'm going to be going pretty fast.

NOTE CONF {"raw":[81,100,100,100,100,100,100,100,100,100]}

00:04:35.390 --> 00:04:35.870
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:35.870 --> 00:04:38.840
<v Speaker 1>So, uh, fasten your seatbelts.

NOTE CONF {"raw":[100,100,100,100,65]}

00:04:39.410 --> 00:04:39.830
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:39.830 --> 00:04:42.770
<v Speaker 1>So, uh, finishing up on data abstraction.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:42.770 --> 00:04:46.610
<v Speaker 1>So I was talking about, um, data representation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:46.610 --> 00:04:49.010
<v Speaker 1>And this is a summary of what I've done in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:49.010 --> 00:04:50.270
<v Speaker 1>the last two lectures.

NOTE CONF {"raw":[100,100,100,100]}

00:04:50.270 --> 00:04:50.870
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:51.110 --> 00:04:55.310
<v Speaker 1>Um, so I gave you four representations, Annotations for ways

NOTE CONF {"raw":[100,100,100,100,100,94,100,63,100,100]}

00:04:55.310 --> 00:04:57.140
<v Speaker 1>of representing sets.

NOTE CONF {"raw":[100,100,100]}

00:04:57.980 --> 00:05:02.120
<v Speaker 1>And each of them had the same six components in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:02.120 --> 00:05:02.510
<v Speaker 1>them.

NOTE CONF {"raw":[100]}

00:05:02.510 --> 00:05:03.380
<v Speaker 1>Sets.

NOTE CONF {"raw":[100]}

00:05:03.560 --> 00:05:07.640
<v Speaker 1>Empty set insert function for turning lists into sets, a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:07.640 --> 00:05:10.280
<v Speaker 1>membership function, and an equality test.

NOTE CONF {"raw":[100,100,100,91,91,100]}

00:05:10.280 --> 00:05:11.030
<v Speaker 1>And.

NOTE CONF {"raw":[100]}

00:05:11.330 --> 00:05:15.530
<v Speaker 1>And there were these four representations lists, ordered lists without

NOTE CONF {"raw":[100,100,100,100,85,100,100,100,100,100]}

00:05:15.530 --> 00:05:19.520
<v Speaker 1>duplicates, ordered trees and balanced ordered trees.

NOTE CONF {"raw":[100,100,100,100,100,100,99]}

00:05:20.120 --> 00:05:25.670
<v Speaker 1>Um and and we ended up with different, uh, efficiencies

NOTE CONF {"raw":[91,100,100,100,100,100,100,100,100,100]}

00:05:25.670 --> 00:05:27.530
<v Speaker 1>for the different for the different functions.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:27.530 --> 00:05:30.740
<v Speaker 1>And this is kind of a table showing the results.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:30.830 --> 00:05:31.640
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:05:31.880 --> 00:05:35.390
<v Speaker 1>Um, uh, I won't you can read this yourself.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:35.390 --> 00:05:39.530
<v Speaker 1>The only thing that some that's, uh, requires explanation maybe

NOTE CONF {"raw":[100,100,100,78,92,100,100,100,100,100]}

00:05:39.530 --> 00:05:42.680
<v Speaker 1>is that when, when we got to the ordered trees,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:43.460 --> 00:05:46.670
<v Speaker 1>um, there was a difference between, uh, kind of average

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:05:46.670 --> 00:05:51.710
<v Speaker 1>case time, uh, which is in this line here and,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:51.710 --> 00:05:54.960
<v Speaker 1>uh, worst case time, which is in this line down

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100,100]}

00:05:54.960 --> 00:05:58.770
<v Speaker 1>here, the idea there being that if the trees are

NOTE CONF {"raw":[100,100,100,62,100,100,100,100,100,100]}

00:05:58.770 --> 00:06:04.080
<v Speaker 1>balanced or close to balanced, then, then, then these things

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:04.080 --> 00:06:04.950
<v Speaker 1>are pretty efficient.

NOTE CONF {"raw":[100,100,100]}

00:06:04.950 --> 00:06:12.300
<v Speaker 1>So with insertion whoops, why did that happen with insertion

NOTE CONF {"raw":[100,100,100,54,100,100,100,100,100,100]}

00:06:12.300 --> 00:06:15.300
<v Speaker 1>happening in in, in um, wait a minute.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:06:17.010 --> 00:06:17.370
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:06:17.370 --> 00:06:19.830
<v Speaker 1>I don't know why that there's no control here that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:19.830 --> 00:06:22.170
<v Speaker 1>I pushed out.

NOTE CONF {"raw":[100,94,100]}

00:06:22.260 --> 00:06:22.800
<v Speaker 1>Anyway.

NOTE CONF {"raw":[100]}

00:06:22.800 --> 00:06:26.460
<v Speaker 1>Insertion happening in logarithmic time and um, and membership in

NOTE CONF {"raw":[100,100,100,100,100,100,94,100,100,100]}

00:06:26.460 --> 00:06:27.450
<v Speaker 1>logarithmic time.

NOTE CONF {"raw":[100,100]}

00:06:27.540 --> 00:06:30.390
<v Speaker 1>Uh, but in the case where the trees are very

NOTE CONF {"raw":[65,100,100,100,100,100,100,100,100,100]}

00:06:30.390 --> 00:06:33.840
<v Speaker 1>unbalanced than the worst case, you end up with linear

NOTE CONF {"raw":[100,84,100,100,100,100,100,100,100,100]}

00:06:33.840 --> 00:06:36.720
<v Speaker 1>time for both of those, which is no better than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:36.720 --> 00:06:37.800
<v Speaker 1>ordered lists.

NOTE CONF {"raw":[100,100]}

00:06:38.490 --> 00:06:42.990
<v Speaker 1>Okay, but if we manage to make sure that our

NOTE CONF {"raw":[100,100,100,100,94,100,100,100,100,100]}

00:06:42.990 --> 00:06:46.110
<v Speaker 1>trees are always balanced, then we end up in this,

NOTE CONF {"raw":[100,100,100,100,91,100,100,100,100,100]}

00:06:46.140 --> 00:06:51.510
<v Speaker 1>in this nice, uh, situation here where insertion and membership

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:51.510 --> 00:06:56.100
<v Speaker 1>are, um, our logarithmic and equality is linear and turning

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:06:56.100 --> 00:06:57.630
<v Speaker 1>a listen to a set is n log n.

NOTE CONF {"raw":[69,84,85,100,100,100,100,100,100]}

00:06:57.630 --> 00:06:57.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:06:57.930 --> 00:07:01.770
<v Speaker 1>So um, the idea here is that there's different ways

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:01.770 --> 00:07:03.240
<v Speaker 1>of representing sets.

NOTE CONF {"raw":[100,100,100]}

00:07:03.240 --> 00:07:05.550
<v Speaker 1>And this is not it's not just sets.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:07:05.550 --> 00:07:06.870
<v Speaker 1>This is just an example.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:06.870 --> 00:07:07.590
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:07:07.740 --> 00:07:12.210
<v Speaker 1>Um, uh, you can choose which one of these you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:12.210 --> 00:07:16.320
<v Speaker 1>want according to your application, uh, ordinary lists without, uh,

NOTE CONF {"raw":[100,100,100,100,100,92,100,100,100,88]}

00:07:16.320 --> 00:07:18.450
<v Speaker 1>without order and so forth is the simplest.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:07:18.780 --> 00:07:21.210
<v Speaker 1>Um, but these other ones are available, and you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:21.210 --> 00:07:24.720
<v Speaker 1>choose which one you want according to your needs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:07:24.720 --> 00:07:30.150
<v Speaker 1>Now, um, this is this is, uh, moving on to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:30.150 --> 00:07:31.590
<v Speaker 1>the topic of data abstraction.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:31.590 --> 00:07:36.030
<v Speaker 1>So the idea of data abstraction is that you have,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:36.900 --> 00:07:43.140
<v Speaker 1>um, a situation like this, different, different ways of implementing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:43.140 --> 00:07:46.020
<v Speaker 1>or representing some data type.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:46.020 --> 00:07:46.290
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:07:46.290 --> 00:07:50.460
<v Speaker 1>In this case, sets and data abstraction is, is about

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:07:50.460 --> 00:07:53.800
<v Speaker 1>being able to switch between different implementations of the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:53.800 --> 00:07:59.710
<v Speaker 1>functionality, in this case different representations of sets without changing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:59.710 --> 00:08:00.460
<v Speaker 1>anything else.

NOTE CONF {"raw":[100,100]}

00:08:00.460 --> 00:08:05.380
<v Speaker 1>So imagine a situation where you've got some 40 million

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:05.380 --> 00:08:09.190
<v Speaker 1>line program, and in this program you use sets a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:09.190 --> 00:08:09.790
<v Speaker 1>lot.

NOTE CONF {"raw":[100]}

00:08:10.000 --> 00:08:10.510
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:10.510 --> 00:08:13.150
<v Speaker 1>And so there is a module somewhere in the program

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:13.150 --> 00:08:17.380
<v Speaker 1>that implements sets one of these for okay.

NOTE CONF {"raw":[100,100,100,100,100,100,63,100]}

00:08:17.590 --> 00:08:21.730
<v Speaker 1>And then you've got uh 40 million lines of code

NOTE CONF {"raw":[100,100,100,100,50,100,100,100,100,100]}

00:08:21.730 --> 00:08:24.670
<v Speaker 1>built on top of that with many, many references to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:24.670 --> 00:08:26.800
<v Speaker 1>sets doing things with sets.

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:27.940 --> 00:08:28.360
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:28.360 --> 00:08:30.490
<v Speaker 1>And one day you decide.

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:30.700 --> 00:08:34.000
<v Speaker 1>Um, there's a bottleneck in my in my code here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:34.000 --> 00:08:36.849
<v Speaker 1>Um, I think I need a better I think I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:36.849 --> 00:08:39.219
<v Speaker 1>need a better implementation of sets that goes faster because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:39.219 --> 00:08:40.300
<v Speaker 1>I'm using them a lot.

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:40.300 --> 00:08:43.300
<v Speaker 1>And so you want to be able to pull out

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:43.300 --> 00:08:48.310
<v Speaker 1>your, your, your, um, your implementation of sets and replace

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:48.310 --> 00:08:52.570
<v Speaker 1>it with another one, which is faster without having to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:52.570 --> 00:08:53.500
<v Speaker 1>change anything else.

NOTE CONF {"raw":[100,100,100]}

00:08:53.500 --> 00:08:53.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:53.950 --> 00:08:56.560
<v Speaker 1>Without having to look at the 40 million lines of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:56.560 --> 00:09:00.160
<v Speaker 1>code every single time that you refer to sets to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:00.160 --> 00:09:04.120
<v Speaker 1>make sure that you you're doing it correctly for the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:04.120 --> 00:09:05.680
<v Speaker 1>new version of sets.

NOTE CONF {"raw":[100,100,100,100]}

00:09:05.680 --> 00:09:06.250
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:06.250 --> 00:09:08.890
<v Speaker 1>And, um, there's a hope that you can do this

NOTE CONF {"raw":[100,100,100,48,100,93,100,100,100,100]}

00:09:08.890 --> 00:09:12.130
<v Speaker 1>because the idea of these four versions of sets is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:12.130 --> 00:09:14.230
<v Speaker 1>that they provide the same functionality.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:14.230 --> 00:09:16.630
<v Speaker 1>They have the same set, the same type, I mean,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:16.630 --> 00:09:19.840
<v Speaker 1>the same type name set, they have the same functions

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:19.930 --> 00:09:25.690
<v Speaker 1>provided, you know, insert element equality and so on and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:25.690 --> 00:09:28.390
<v Speaker 1>so and so at least the names and so forth

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:28.390 --> 00:09:29.350
<v Speaker 1>should be right.

NOTE CONF {"raw":[100,100,100]}

00:09:29.710 --> 00:09:30.370
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:30.370 --> 00:09:32.680
<v Speaker 1>But it turns out it's a bit tricky to get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:32.680 --> 00:09:33.760
<v Speaker 1>this to work.

NOTE CONF {"raw":[100,100,100]}

00:09:33.880 --> 00:09:34.240
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:34.240 --> 00:09:35.710
<v Speaker 1>And I want to show you why.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:09:36.280 --> 00:09:38.470
<v Speaker 1>And there's a problem.

NOTE CONF {"raw":[100,100,100,100]}

00:09:38.470 --> 00:09:40.270
<v Speaker 1>And then there's a solution to the problem okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:09:40.270 --> 00:09:43.090
<v Speaker 1>The problem is that if you don't do it right,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:43.120 --> 00:09:45.580
<v Speaker 1>you end up having to look at the 40 million

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:45.580 --> 00:09:48.790
<v Speaker 1>lines of code and trying to sort out what's going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:48.820 --> 00:09:49.240
<v Speaker 1>on?

NOTE CONF {"raw":[100]}

00:09:49.660 --> 00:09:50.350
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:50.920 --> 00:09:53.500
<v Speaker 1>So, um, uh, and it has to do with the

NOTE CONF {"raw":[100,98,54,100,100,100,100,100,100,100]}

00:09:53.500 --> 00:09:55.900
<v Speaker 1>invariant that I, that I've mentioned.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:55.900 --> 00:09:58.000
<v Speaker 1>So remember the invariant for ordered lists.

NOTE CONF {"raw":[100,100,100,100,100,100,92]}

00:09:58.000 --> 00:10:00.760
<v Speaker 1>There was this there was this, um, condition that I

NOTE CONF {"raw":[100,100,100,100,100,100,85,100,100,100]}

00:10:00.760 --> 00:10:04.030
<v Speaker 1>wrote down here which said the lists have to be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:04.030 --> 00:10:06.580
<v Speaker 1>in order, and I wrote it in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:07.000 --> 00:10:08.410
<v Speaker 1>Uh, like this.

NOTE CONF {"raw":[100,100,100]}

00:10:08.410 --> 00:10:08.920
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:10:08.920 --> 00:10:11.200
<v Speaker 1>This is a this is a condition which says that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:11.200 --> 00:10:14.200
<v Speaker 1>everything in the list, uh, is, is in ascending order,

NOTE CONF {"raw":[100,100,100,100,75,100,100,100,100,100]}

00:10:14.200 --> 00:10:16.150
<v Speaker 1>from from beginning to end.

NOTE CONF {"raw":[100,100,100,100,100]}

00:10:16.570 --> 00:10:19.990
<v Speaker 1>Uh, you know, small things at the beginning, big things

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:19.990 --> 00:10:21.700
<v Speaker 1>at the end, and no duplicates.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:21.700 --> 00:10:22.720
<v Speaker 1>That's what it says.

NOTE CONF {"raw":[100,100,100,100]}

00:10:23.200 --> 00:10:23.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:10:23.950 --> 00:10:28.150
<v Speaker 1>And, um, the code respects that invariant.

NOTE CONF {"raw":[100,57,100,100,100,100,100]}

00:10:28.150 --> 00:10:29.650
<v Speaker 1>So things like, um.

NOTE CONF {"raw":[100,100,100,100]}

00:10:29.650 --> 00:10:30.850
<v Speaker 1>Oh, I don't have the code here.

NOTE CONF {"raw":[97,100,100,100,100,100,100]}

00:10:30.850 --> 00:10:33.610
<v Speaker 1>So things like insertion, you put, you put something in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:33.610 --> 00:10:35.800
<v Speaker 1>a, in a, in a list in an ordered list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:35.800 --> 00:10:37.120
<v Speaker 1>and it ends up in the right place.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:37.120 --> 00:10:38.590
<v Speaker 1>So the list is still ordered.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:38.710 --> 00:10:39.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:10:39.400 --> 00:10:42.400
<v Speaker 1>And not only that the code doesn't work.

NOTE CONF {"raw":[100,98,100,100,100,100,100,100]}

00:10:42.640 --> 00:10:47.140
<v Speaker 1>If the, if the if the lists are not ordered.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:47.140 --> 00:10:51.620
<v Speaker 1>So for example, if you try to compare, um, two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:51.620 --> 00:10:54.080
<v Speaker 1>lists for equality and one of them's ordered and the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:54.080 --> 00:10:55.070
<v Speaker 1>other one isn't.

NOTE CONF {"raw":[100,100,100]}

00:10:55.550 --> 00:10:58.280
<v Speaker 1>Um, the fact that you're taking advantage of the order,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:58.280 --> 00:11:01.790
<v Speaker 1>meaning you can use list equality to do testing for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:01.790 --> 00:11:04.160
<v Speaker 1>set equality doesn't work anymore.

NOTE CONF {"raw":[93,100,100,100,100]}

00:11:04.160 --> 00:11:06.980
<v Speaker 1>Or if you're looking for an element in a list,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:06.980 --> 00:11:09.410
<v Speaker 1>in an ordered list, and the list isn't an order,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,52,100]}

00:11:09.410 --> 00:11:10.730
<v Speaker 1>you might look for it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:11:10.730 --> 00:11:11.450
<v Speaker 1>And then you.

NOTE CONF {"raw":[100,100,100]}

00:11:11.450 --> 00:11:13.190
<v Speaker 1>And then you don't find it in the place it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,92]}

00:11:13.190 --> 00:11:14.090
<v Speaker 1>supposed to be.

NOTE CONF {"raw":[100,100,100]}

00:11:14.090 --> 00:11:15.080
<v Speaker 1>And then you give up.

NOTE CONF {"raw":[100,100,100,100,100]}

00:11:15.080 --> 00:11:15.770
<v Speaker 1>You say false.

NOTE CONF {"raw":[100,100,100]}

00:11:15.770 --> 00:11:16.310
<v Speaker 1>It's not there.

NOTE CONF {"raw":[100,100,100]}

00:11:16.310 --> 00:11:19.040
<v Speaker 1>But actually it might be somewhere further down because the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:19.040 --> 00:11:20.000
<v Speaker 1>list is not ordered.

NOTE CONF {"raw":[100,100,100,100]}

00:11:20.000 --> 00:11:20.660
<v Speaker 1>It's so.

NOTE CONF {"raw":[100,54]}

00:11:20.660 --> 00:11:21.860
<v Speaker 1>So it gives the wrong answer.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:21.860 --> 00:11:22.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:11:22.850 --> 00:11:26.630
<v Speaker 1>Um, if the if the invariant doesn't hold, then, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:27.140 --> 00:11:29.480
<v Speaker 1>then you might give the wrong answer using this code

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:29.480 --> 00:11:31.490
<v Speaker 1>because you're depending on this property.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:31.490 --> 00:11:34.220
<v Speaker 1>And here's an example okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:11:34.220 --> 00:11:36.260
<v Speaker 1>And this is called breaking the invariant.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:11:36.410 --> 00:11:39.530
<v Speaker 1>So the first uh the first test here, this is

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:11:39.530 --> 00:11:40.190
<v Speaker 1>a good test.

NOTE CONF {"raw":[100,100,100]}

00:11:40.190 --> 00:11:41.690
<v Speaker 1>This is what you want to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:11:41.690 --> 00:11:45.770
<v Speaker 1>So um suppose you want to suppose you have two

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,100]}

00:11:45.770 --> 00:11:47.810
<v Speaker 1>lists of values here.

NOTE CONF {"raw":[100,100,100,100]}

00:11:47.810 --> 00:11:51.620
<v Speaker 1>And I mean, I've just taken numbers from one up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:51.620 --> 00:11:54.110
<v Speaker 1>to n and then the numbers from n down to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:54.110 --> 00:11:54.410
<v Speaker 1>one.

NOTE CONF {"raw":[100]}

00:11:54.410 --> 00:11:57.650
<v Speaker 1>So same same elements in a different order.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:11:58.160 --> 00:11:58.910
<v Speaker 1>Okay.

NOTE CONF {"raw":[88]}

00:11:59.210 --> 00:12:01.610
<v Speaker 1>If I take these lists and I convert them into

NOTE CONF {"raw":[100,100,100,100,96,100,100,100,100,100]}

00:12:01.610 --> 00:12:07.700
<v Speaker 1>sets using this function set okay I end up with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:08.870 --> 00:12:12.500
<v Speaker 1>uh sets represented as ordered lists.

NOTE CONF {"raw":[100,100,100,100,100,97]}

00:12:12.500 --> 00:12:16.100
<v Speaker 1>So we end up with an ordered list which has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:16.970 --> 00:12:19.460
<v Speaker 1>in fact it looks like this first one here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:19.460 --> 00:12:20.060
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:12:21.680 --> 00:12:24.320
<v Speaker 1>So it puts the second one in the correct order.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:24.620 --> 00:12:28.220
<v Speaker 1>And then and then testing equality gives the right answer

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:28.220 --> 00:12:28.550
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:12:28.550 --> 00:12:30.020
<v Speaker 1>The answer is true okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:30.020 --> 00:12:31.070
<v Speaker 1>Same elements.

NOTE CONF {"raw":[100,100]}

00:12:31.970 --> 00:12:34.010
<v Speaker 1>Uh I've converted them to a set.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:34.940 --> 00:12:37.880
<v Speaker 1>This ends up in the second one being rearranged to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:12:37.880 --> 00:12:39.290
<v Speaker 1>be in order okay.

NOTE CONF {"raw":[100,80,100,100]}

00:12:39.800 --> 00:12:41.510
<v Speaker 1>So this is the way you should do it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:42.230 --> 00:12:46.290
<v Speaker 1>Here's the way you shouldn't do it okay Um, I've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97,100]}

00:12:46.290 --> 00:12:47.070
<v Speaker 1>done the same.

NOTE CONF {"raw":[100,100,100]}

00:12:47.070 --> 00:12:51.930
<v Speaker 1>I've got the same lists here, but I don't I

NOTE CONF {"raw":[100,100,100,100,92,100,100,100,100,100]}

00:12:51.930 --> 00:12:56.580
<v Speaker 1>don't call set to convert these things to to sets.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:56.580 --> 00:12:59.520
<v Speaker 1>I just go ahead and test equality.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:59.820 --> 00:13:01.680
<v Speaker 1>Um, on these lists.

NOTE CONF {"raw":[100,100,100,100]}

00:13:01.680 --> 00:13:02.190
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:13:02.190 --> 00:13:05.850
<v Speaker 1>Since sets are represented as lists, you know, I have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:05.850 --> 00:13:08.580
<v Speaker 1>a, I have a line of code which says, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:08.580 --> 00:13:12.000
<v Speaker 1>you know, type set of a equals list of a.

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:13:16.260 --> 00:13:18.690
<v Speaker 1>Um, this type checks, okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:18.690 --> 00:13:21.720
<v Speaker 1>Because the two things here, these are both lists and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:21.720 --> 00:13:22.380
<v Speaker 1>lists are sets.

NOTE CONF {"raw":[100,100,76]}

00:13:22.380 --> 00:13:24.810
<v Speaker 1>So they're both sets okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:24.810 --> 00:13:28.740
<v Speaker 1>So, um, I end up here with the wrong answer

NOTE CONF {"raw":[100,95,100,100,100,100,100,100,100,100]}

00:13:28.740 --> 00:13:32.010
<v Speaker 1>because if I do equality testing, which is just list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:32.010 --> 00:13:36.630
<v Speaker 1>equality, um, I end up with saying, no, these are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:36.630 --> 00:13:39.630
<v Speaker 1>not equal, even though they have the same elements.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97]}

00:13:39.630 --> 00:13:40.530
<v Speaker 1>So they are equal.

NOTE CONF {"raw":[100,100,100,100]}

00:13:40.530 --> 00:13:43.620
<v Speaker 1>They should be equal as sets, but they're not because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:43.620 --> 00:13:46.530
<v Speaker 1>the algorithm requires the list to be in order.

NOTE CONF {"raw":[100,100,100,100,98,100,100,100,100]}

00:13:46.560 --> 00:13:47.220
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:13:48.420 --> 00:13:50.700
<v Speaker 1>So that's that's kind of bad.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:13:51.090 --> 00:13:55.080
<v Speaker 1>Um, if you make a mistake like that, you'll get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:55.080 --> 00:13:55.800
<v Speaker 1>the wrong answer.

NOTE CONF {"raw":[100,100,100]}

00:13:55.800 --> 00:13:56.100
<v Speaker 1>Okay?

NOTE CONF {"raw":[100]}

00:13:56.100 --> 00:14:01.830
<v Speaker 1>Even worse, even worse, because sets and lists are the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:01.830 --> 00:14:02.940
<v Speaker 1>same type.

NOTE CONF {"raw":[100,100]}

00:14:02.940 --> 00:14:06.420
<v Speaker 1>You can do things in your 40 million lines of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:06.420 --> 00:14:09.330
<v Speaker 1>code that take advantage of that fact.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:14:09.450 --> 00:14:10.050
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:10.050 --> 00:14:13.020
<v Speaker 1>So if, for instance, it happens that the head of

NOTE CONF {"raw":[98,83,100,100,100,100,100,100,100,100]}

00:14:13.020 --> 00:14:16.170
<v Speaker 1>a list, uh, the head of a of a ordered

NOTE CONF {"raw":[100,100,81,100,100,100,100,100,100,100]}

00:14:16.170 --> 00:14:19.110
<v Speaker 1>list will always be the minimum element, okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:19.110 --> 00:14:21.540
<v Speaker 1>And it might be that you'll take advantage of that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:21.540 --> 00:14:26.280
<v Speaker 1>fact, uh, 349 times in your in your 40 million

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:26.280 --> 00:14:27.240
<v Speaker 1>lines of code.

NOTE CONF {"raw":[100,100,100]}

00:14:27.360 --> 00:14:28.110
<v Speaker 1>Okay.

NOTE CONF {"raw":[76]}

00:14:28.290 --> 00:14:30.510
<v Speaker 1>Um, you take the head, you have a set, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:30.510 --> 00:14:32.460
<v Speaker 1>you say, I want the minimum element, I'll just take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:32.460 --> 00:14:32.880
<v Speaker 1>the head.

NOTE CONF {"raw":[100,100]}

00:14:32.880 --> 00:14:34.260
<v Speaker 1>It'll be the minimum element.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:34.620 --> 00:14:35.310
<v Speaker 1>Okay.

NOTE CONF {"raw":[91]}

00:14:35.610 --> 00:14:35.940
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:14:38.820 --> 00:14:42.450
<v Speaker 1>And then you and then, uh, you know, two months

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:42.450 --> 00:14:46.000
<v Speaker 1>later, you you decide to change to a version of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:46.000 --> 00:14:50.080
<v Speaker 1>set that uses balanced binary trees or something.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:50.080 --> 00:14:55.270
<v Speaker 1>Okay, so all of those, all of those uses of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:55.270 --> 00:14:58.930
<v Speaker 1>head, they were formally okay because you're taking the head

NOTE CONF {"raw":[100,100,100,71,100,100,100,100,100,100]}

00:14:58.930 --> 00:14:59.620
<v Speaker 1>of a list.

NOTE CONF {"raw":[100,96,100]}

00:14:59.620 --> 00:15:01.990
<v Speaker 1>So now they will fail to type check.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:01.990 --> 00:15:02.590
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:15:03.010 --> 00:15:08.050
<v Speaker 1>Um, that's kind of a pain, but at least you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:08.050 --> 00:15:11.920
<v Speaker 1>automatically, you know, Haskell will tell you automatically all of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:11.920 --> 00:15:14.590
<v Speaker 1>the, you know, however many hundred times it is that

NOTE CONF {"raw":[100,100,100,78,100,100,100,100,100,100]}

00:15:14.590 --> 00:15:16.870
<v Speaker 1>you made that, that you did that and you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:16.870 --> 00:15:18.430
<v Speaker 1>go in and fix all of those.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:18.430 --> 00:15:24.130
<v Speaker 1>But suppose that instead of, um, instead of replacing your,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:24.130 --> 00:15:28.870
<v Speaker 1>your representation of from, instead of changing from ordered lists

NOTE CONF {"raw":[100,100,85,100,100,100,100,100,100,100]}

00:15:28.870 --> 00:15:33.250
<v Speaker 1>to, uh, you know, balanced binary tree, suppose you instead

NOTE CONF {"raw":[100,100,100,100,100,100,81,100,100,100]}

00:15:33.250 --> 00:15:36.070
<v Speaker 1>decide to change the order so that instead of being

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:36.070 --> 00:15:38.410
<v Speaker 1>ascending order, it's descending order.

NOTE CONF {"raw":[100,100,84,100,100]}

00:15:38.410 --> 00:15:40.660
<v Speaker 1>So big things at the beginning, small things at the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:40.660 --> 00:15:41.200
<v Speaker 1>end.

NOTE CONF {"raw":[100]}

00:15:41.410 --> 00:15:41.980
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:15:41.980 --> 00:15:44.980
<v Speaker 1>Then suddenly, um, the head of the list is the

NOTE CONF {"raw":[100,100,76,100,100,100,100,100,100,100]}

00:15:44.980 --> 00:15:47.410
<v Speaker 1>maximum element and not the minimum element.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:47.560 --> 00:15:50.200
<v Speaker 1>Okay, so instead of instead of and it won't and

NOTE CONF {"raw":[100,100,100,100,100,90,100,100,100,100]}

00:15:50.200 --> 00:15:52.390
<v Speaker 1>it won't fail to type check because they're still lists

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:15:52.390 --> 00:15:52.960
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:15:52.960 --> 00:15:56.350
<v Speaker 1>So instead of instead of giving you a type error,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,96]}

00:15:56.680 --> 00:16:00.700
<v Speaker 1>it'll just give you the wrong answer, okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:00.700 --> 00:16:05.830
<v Speaker 1>And in order to find out okay, you get bugs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:05.830 --> 00:16:07.450
<v Speaker 1>In order to track down these bugs, you have to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:07.450 --> 00:16:12.220
<v Speaker 1>look at every, uh, every time you used the function

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:12.220 --> 00:16:13.240
<v Speaker 1>head in your program.

NOTE CONF {"raw":[100,100,100,100]}

00:16:13.240 --> 00:16:14.740
<v Speaker 1>40 million lines of code.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:15.700 --> 00:16:16.360
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:16:16.360 --> 00:16:19.180
<v Speaker 1>Which might be quite a lot of times.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:19.180 --> 00:16:19.570
<v Speaker 1>Right?

NOTE CONF {"raw":[100]}

00:16:19.570 --> 00:16:21.100
<v Speaker 1>You don't want to have to do that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:21.100 --> 00:16:24.160
<v Speaker 1>You don't want to have to debug your code because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:24.160 --> 00:16:28.510
<v Speaker 1>you because you've been sloppy and, and and use things,

NOTE CONF {"raw":[69,100,100,100,100,100,86,67,100,100]}

00:16:28.750 --> 00:16:31.990
<v Speaker 1>um, you know, basically breaking the invariant and, and getting

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:16:31.990 --> 00:16:37.660
<v Speaker 1>unauthorised access to a representation that, um, that you shouldn't,

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:16:37.780 --> 00:16:42.020
<v Speaker 1>that you shouldn't be, you know, Misusing and say, so

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:42.020 --> 00:16:42.620
<v Speaker 1>what do you do?

NOTE CONF {"raw":[100,100,100,100]}

00:16:42.650 --> 00:16:44.630
<v Speaker 1>What's the solution to this problem?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:44.840 --> 00:16:49.970
<v Speaker 1>Okay, but one solution is you write documentation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:49.970 --> 00:16:54.020
<v Speaker 1>And in this documentation, you know, lots of lots of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:54.020 --> 00:16:58.430
<v Speaker 1>documents and in big bold letters it says don't apply.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:58.430 --> 00:17:02.630
<v Speaker 1>Head to sets and make sure that all arguments of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,95]}

00:17:02.630 --> 00:17:04.760
<v Speaker 1>set functions satisfy the invariant.

NOTE CONF {"raw":[100,73,100,100,100]}

00:17:05.329 --> 00:17:08.959
<v Speaker 1>Okay, big bold letters um, large print.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:17:08.959 --> 00:17:09.439
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:17:09.439 --> 00:17:13.040
<v Speaker 1>And that would fix the problem because everybody always reads

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:13.040 --> 00:17:16.640
<v Speaker 1>all the documentation and does exactly what it says, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:18.530 --> 00:17:19.220
<v Speaker 1>Wrong.

NOTE CONF {"raw":[100]}

00:17:20.030 --> 00:17:20.689
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:17:20.689 --> 00:17:21.740
<v Speaker 1>Of course not.

NOTE CONF {"raw":[100,100,100]}

00:17:22.579 --> 00:17:24.170
<v Speaker 1>Um, you need a different solution.

NOTE CONF {"raw":[60,100,100,100,100,100]}

00:17:24.170 --> 00:17:24.770
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:17:24.920 --> 00:17:28.400
<v Speaker 1>Haskell, um, you know, the type checker makes sure you

NOTE CONF {"raw":[100,100,100,100,100,100,100,63,100,100]}

00:17:28.400 --> 00:17:31.250
<v Speaker 1>don't make certain kinds of mistakes, and you can and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:31.250 --> 00:17:34.160
<v Speaker 1>you can take advantage of the type checker here to,

NOTE CONF {"raw":[100,73,100,100,100,100,100,100,100,100]}

00:17:34.160 --> 00:17:37.790
<v Speaker 1>um, to avoid making these kinds of mistakes by by

NOTE CONF {"raw":[64,100,100,100,100,100,100,100,100,100]}

00:17:37.790 --> 00:17:40.220
<v Speaker 1>being a bit clever Okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:17:40.490 --> 00:17:44.210
<v Speaker 1>Uh, we can we can use Haskell's type system, um,

NOTE CONF {"raw":[37,100,100,100,100,100,100,100,100,100]}

00:17:44.570 --> 00:17:49.700
<v Speaker 1>to, um, to avoid the possibility of breaking the abstraction.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:50.210 --> 00:17:51.980
<v Speaker 1>Um, let me show you another example.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:17:53.240 --> 00:17:56.570
<v Speaker 1>Uh, this is just the same thing, but for for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:56.570 --> 00:17:58.310
<v Speaker 1>for binary trees.

NOTE CONF {"raw":[100,100,100]}

00:17:58.550 --> 00:18:01.370
<v Speaker 1>Okay, I'm using the binary trees that are not the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,97]}

00:18:01.580 --> 00:18:02.480
<v Speaker 1>the balanced version.

NOTE CONF {"raw":[100,100,100]}

00:18:02.480 --> 00:18:03.260
<v Speaker 1>It doesn't matter.

NOTE CONF {"raw":[97,100,100]}

00:18:03.290 --> 00:18:04.760
<v Speaker 1>Same applies to that okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:18:04.760 --> 00:18:08.150
<v Speaker 1>So binary trees have to be in order okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:18:08.150 --> 00:18:11.930
<v Speaker 1>The the for every node everything on the left has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:11.930 --> 00:18:14.900
<v Speaker 1>to be uh, smaller than the node.

NOTE CONF {"raw":[100,100,93,100,100,100,100]}

00:18:14.900 --> 00:18:17.750
<v Speaker 1>And everything on the right has to be larger than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:17.750 --> 00:18:19.850
<v Speaker 1>the node for every node in the tree, which is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:19.850 --> 00:18:21.290
<v Speaker 1>what this invariant says.

NOTE CONF {"raw":[100,100,74,100]}

00:18:22.010 --> 00:18:22.580
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:18:22.580 --> 00:18:28.460
<v Speaker 1>And our trees represented using um two constructors nil and

NOTE CONF {"raw":[100,100,56,100,100,97,100,100,100,100]}

00:18:28.460 --> 00:18:29.450
<v Speaker 1>and node.

NOTE CONF {"raw":[100,100]}

00:18:31.700 --> 00:18:32.420
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:18:32.420 --> 00:18:35.780
<v Speaker 1>And all of our functions maintain this invariant.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:36.200 --> 00:18:41.450
<v Speaker 1>And functions like uh uh, membership test require that the

NOTE CONF {"raw":[100,100,100,72,100,100,71,100,100,100]}

00:18:41.450 --> 00:18:45.020
<v Speaker 1>trees have this structure, um, this order.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:45.020 --> 00:18:47.180
<v Speaker 1>Otherwise they give the wrong answer again.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:47.180 --> 00:18:47.720
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:18:47.720 --> 00:18:50.090
<v Speaker 1>And so here is exactly the same kind of thing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:50.090 --> 00:18:51.530
<v Speaker 1>happening with trees.

NOTE CONF {"raw":[100,100,100]}

00:18:51.740 --> 00:18:56.750
<v Speaker 1>Um, instead of, instead of, um, uh, properly constructing down

NOTE CONF {"raw":[100,100,100,100,100,100,62,100,100,100]}

00:18:56.750 --> 00:19:01.160
<v Speaker 1>here the bad the bad example here, instead of constructing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:01.190 --> 00:19:05.240
<v Speaker 1>t using the functions that I have on trees like

NOTE CONF {"raw":[89,100,100,100,100,100,100,100,100,100]}

00:19:05.330 --> 00:19:05.810
<v Speaker 1>insert.

NOTE CONF {"raw":[100]}

00:19:05.810 --> 00:19:08.660
<v Speaker 1>And so I just, um, I just build a tree

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:08.660 --> 00:19:11.180
<v Speaker 1>using node and nil just using the constructors.

NOTE CONF {"raw":[100,100,100,87,100,100,100,100]}

00:19:11.180 --> 00:19:16.370
<v Speaker 1>And the tree that I build here, um, doesn't respect

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:19:16.370 --> 00:19:17.330
<v Speaker 1>the invariant.

NOTE CONF {"raw":[100,100]}

00:19:17.330 --> 00:19:17.660
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:17.660 --> 00:19:20.630
<v Speaker 1>So if you look at the, um, I mean, what

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:20.630 --> 00:19:23.150
<v Speaker 1>this tree looks like, it has three at the top.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:23.780 --> 00:19:25.910
<v Speaker 1>Uh, it has three at the top, it has one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:25.910 --> 00:19:27.800
<v Speaker 1>down here and it has two down here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:19:27.860 --> 00:19:28.520
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:28.520 --> 00:19:32.630
<v Speaker 1>And and that doesn't respect the invariant because two is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:32.630 --> 00:19:34.280
<v Speaker 1>smaller than three.

NOTE CONF {"raw":[100,100,100]}

00:19:34.280 --> 00:19:37.140
<v Speaker 1>And, uh, stuff over here is supposed to be larger

NOTE CONF {"raw":[100,88,100,100,100,81,100,100,100,100]}

00:19:37.140 --> 00:19:37.890
<v Speaker 1>than the label.

NOTE CONF {"raw":[100,100,100]}

00:19:37.890 --> 00:19:38.250
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:38.250 --> 00:19:39.600
<v Speaker 1>So this breaks the invariant.

NOTE CONF {"raw":[100,100,100,100,100]}

00:19:39.600 --> 00:19:42.630
<v Speaker 1>The the the equality test will give the wrong answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:42.630 --> 00:19:42.840
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:42.840 --> 00:19:46.440
<v Speaker 1>So that's just the same thing happening again with um

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:47.310 --> 00:19:50.910
<v Speaker 1>with with um trees.

NOTE CONF {"raw":[100,100,100,97]}

00:19:51.330 --> 00:19:51.840
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:51.840 --> 00:19:53.460
<v Speaker 1>And so what's the solution?

NOTE CONF {"raw":[100,100,100,100,100]}

00:19:54.120 --> 00:19:58.050
<v Speaker 1>Um, it's to add um, and Haskell, this is the

NOTE CONF {"raw":[100,100,100,100,100,38,100,100,100,61]}

00:19:58.050 --> 00:20:02.310
<v Speaker 1>solution anyway, the, um, the, uh, the solution is to

NOTE CONF {"raw":[100,100,100,100,97,51,100,100,100,100]}

00:20:02.310 --> 00:20:05.910
<v Speaker 1>add in the case of lists, that's add a hidden

NOTE CONF {"raw":[100,100,100,100,100,88,50,76,100,100]}

00:20:05.910 --> 00:20:06.840
<v Speaker 1>constructor.

NOTE CONF {"raw":[100]}

00:20:08.130 --> 00:20:09.600
<v Speaker 1>And what do I mean by that?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:20:09.600 --> 00:20:10.500
<v Speaker 1>Wait a second.

NOTE CONF {"raw":[100,100,100]}

00:20:10.650 --> 00:20:11.910
<v Speaker 1>What do I mean by that?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:11.910 --> 00:20:12.600
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:20:12.870 --> 00:20:15.990
<v Speaker 1>Um, I've replaced so if we go back a couple

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:15.990 --> 00:20:17.670
<v Speaker 1>of slides here.

NOTE CONF {"raw":[100,100,100]}

00:20:17.670 --> 00:20:20.970
<v Speaker 1>So I had type set a equals list of a

NOTE CONF {"raw":[100,100,100,94,94,100,100,100,100,100]}

00:20:22.050 --> 00:20:26.010
<v Speaker 1>okay for my ordered lists I replace that.

NOTE CONF {"raw":[100,100,100,100,100,100,94,100]}

00:20:29.220 --> 00:20:35.760
<v Speaker 1>Oops I replaced that with this algebraic data type which

NOTE CONF {"raw":[96,94,61,100,100,100,100,100,100,100]}

00:20:36.540 --> 00:20:40.770
<v Speaker 1>is the same, except that it uses a constructor to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:40.770 --> 00:20:42.960
<v Speaker 1>turn a list into a set.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:43.230 --> 00:20:47.520
<v Speaker 1>Okay, so there's a function called mixed set here that

NOTE CONF {"raw":[100,100,100,100,100,100,31,100,100,100]}

00:20:47.790 --> 00:20:50.880
<v Speaker 1>takes a it takes a list and it produces a

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:20:50.880 --> 00:20:51.420
<v Speaker 1>set.

NOTE CONF {"raw":[100]}

00:20:51.810 --> 00:20:54.090
<v Speaker 1>So lists are not sets.

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:56.370 --> 00:21:00.420
<v Speaker 1>Uh, sets are lists packaged up with this constructor okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:00.420 --> 00:21:03.360
<v Speaker 1>If you don't package it up using the constructor it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:03.360 --> 00:21:04.890
<v Speaker 1>it's it's a list.

NOTE CONF {"raw":[100,100,100,100]}

00:21:04.890 --> 00:21:07.080
<v Speaker 1>If you package it up it's a set.

NOTE CONF {"raw":[100,100,100,100,100,98,100,100]}

00:21:07.080 --> 00:21:08.850
<v Speaker 1>So these are different types.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:09.690 --> 00:21:11.130
<v Speaker 1>So that's a constructor.

NOTE CONF {"raw":[100,100,98,100]}

00:21:11.130 --> 00:21:15.900
<v Speaker 1>And it's hidden because um in this list of things

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:21:15.900 --> 00:21:19.770
<v Speaker 1>that I export from the um from the module, it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:19.770 --> 00:21:21.300
<v Speaker 1>not it's not there.

NOTE CONF {"raw":[100,100,100,100]}

00:21:21.750 --> 00:21:22.170
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:21:22.170 --> 00:21:24.690
<v Speaker 1>I only export the things that are mentioned here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:21:24.870 --> 00:21:28.290
<v Speaker 1>And I don't export this constructor because it's not mentioned

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:28.320 --> 00:21:28.740
<v Speaker 1>there.

NOTE CONF {"raw":[96]}

00:21:29.580 --> 00:21:30.210
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:21:31.800 --> 00:21:34.440
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[100,100]}

00:21:34.440 --> 00:21:34.870
<v Speaker 1>I'll just.

NOTE CONF {"raw":[100,100]}

00:21:34.870 --> 00:21:37.150
<v Speaker 1>I'll quickly say you have to change.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:37.150 --> 00:21:38.770
<v Speaker 1>You have to change the code.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:39.010 --> 00:21:42.670
<v Speaker 1>Um, to, to sprinkle this constructor in all over the

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:21:42.670 --> 00:21:43.360
<v Speaker 1>place.

NOTE CONF {"raw":[100]}

00:21:43.360 --> 00:21:43.780
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:21:43.780 --> 00:21:46.810
<v Speaker 1>So, so, uh, well, I'll just, you know, for example,

NOTE CONF {"raw":[100,100,81,100,100,100,100,100,100,100]}

00:21:46.810 --> 00:21:49.000
<v Speaker 1>in insert, it appears twice here.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:21:49.240 --> 00:21:52.690
<v Speaker 1>This is, this is a matter of, uh, unpacking and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:52.690 --> 00:21:55.480
<v Speaker 1>repacking your lists into sets and so forth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:21:55.480 --> 00:22:00.160
<v Speaker 1>Okay, so same code, but with some constructors sprinkled throughout.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:00.610 --> 00:22:01.030
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:22:01.030 --> 00:22:02.860
<v Speaker 1>But what's the advantage of this?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:03.790 --> 00:22:05.440
<v Speaker 1>I'll just I'll be very quick because I have to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:05.440 --> 00:22:08.020
<v Speaker 1>get through this to get to the next topic.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:22:08.020 --> 00:22:08.770
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:22:08.920 --> 00:22:13.210
<v Speaker 1>Um, the advantage is, um, I can't break the invariant

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:13.210 --> 00:22:15.970
<v Speaker 1>now after having done this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:17.380 --> 00:22:21.220
<v Speaker 1>Okay, so remember my bad test from before where I

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:22:21.220 --> 00:22:23.950
<v Speaker 1>took two, ordered, where I took two lists and tried

NOTE CONF {"raw":[100,100,93,100,100,100,100,100,100,100]}

00:22:23.950 --> 00:22:26.080
<v Speaker 1>to compare them for equality and one of them was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:26.080 --> 00:22:27.010
<v Speaker 1>not an ordered list.

NOTE CONF {"raw":[100,71,100,100]}

00:22:27.010 --> 00:22:28.840
<v Speaker 1>And so I shouldn't have been doing that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:22:29.290 --> 00:22:30.010
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:22:30.310 --> 00:22:34.270
<v Speaker 1>Um, what I'll get now is a type error rather

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,97,100]}

00:22:34.270 --> 00:22:35.710
<v Speaker 1>than the wrong answer.

NOTE CONF {"raw":[100,100,100,100]}

00:22:36.550 --> 00:22:38.320
<v Speaker 1>Okay, the type error is okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:38.320 --> 00:22:40.690
<v Speaker 1>Wrong answers are bad because you don't know them in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,68]}

00:22:40.690 --> 00:22:42.070
<v Speaker 1>case unless you look at them.

NOTE CONF {"raw":[68,100,100,100,100,100]}

00:22:42.070 --> 00:22:44.350
<v Speaker 1>Look at your results very carefully.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:44.680 --> 00:22:47.260
<v Speaker 1>Um, type errors are kind of good because it tells

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:47.260 --> 00:22:48.430
<v Speaker 1>you there's something wrong here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:48.430 --> 00:22:49.540
<v Speaker 1>You better fix it.

NOTE CONF {"raw":[99,100,100,100]}

00:22:49.570 --> 00:22:53.350
<v Speaker 1>Okay, so it tells me here that I can't do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:53.350 --> 00:23:00.430
<v Speaker 1>this equality test because, um, it's expecting type set and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:00.430 --> 00:23:03.130
<v Speaker 1>it's being given, uh, type list of n.

NOTE CONF {"raw":[98,100,100,82,100,100,100,96]}

00:23:04.390 --> 00:23:04.750
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:04.750 --> 00:23:05.710
<v Speaker 1>It says that twice.

NOTE CONF {"raw":[100,100,100,100]}

00:23:05.710 --> 00:23:07.240
<v Speaker 1>Once for s and once for t.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:23:08.770 --> 00:23:09.040
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:09.040 --> 00:23:11.380
<v Speaker 1>So this is a this is a this is uh,

NOTE CONF {"raw":[100,100,100,56,100,100,100,100,100,88]}

00:23:11.380 --> 00:23:13.900
<v Speaker 1>doesn't type check okay.

NOTE CONF {"raw":[100,100,100,100]}

00:23:13.900 --> 00:23:19.960
<v Speaker 1>Because, um, because I'm using lists here and not and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:19.960 --> 00:23:21.400
<v Speaker 1>not sets.

NOTE CONF {"raw":[100,100]}

00:23:21.700 --> 00:23:22.120
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:22.120 --> 00:23:25.180
<v Speaker 1>But I'm much more clever than Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:23:26.170 --> 00:23:29.620
<v Speaker 1>And so, um, and so I say, aha, I need

NOTE CONF {"raw":[100,100,82,100,100,100,100,100,100,100]}

00:23:29.620 --> 00:23:33.470
<v Speaker 1>to apply this mixed set constructor to turn these lists

NOTE CONF {"raw":[100,100,100,87,97,100,100,100,100,100]}

00:23:33.470 --> 00:23:34.460
<v Speaker 1>into sets.

NOTE CONF {"raw":[100,100]}

00:23:35.690 --> 00:23:37.580
<v Speaker 1>And that'll allow me to do this.

NOTE CONF {"raw":[100,68,100,100,100,100,100]}

00:23:38.450 --> 00:23:40.580
<v Speaker 1>Okay, so here's my same example.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:40.580 --> 00:23:42.710
<v Speaker 1>It's the same as what I had a second ago,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:43.370 --> 00:23:47.000
<v Speaker 1>except I've put mix set here and here.

NOTE CONF {"raw":[100,100,100,43,100,100,100,100]}

00:23:47.750 --> 00:23:48.470
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:48.950 --> 00:23:49.340
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:23:52.310 --> 00:23:53.060
<v Speaker 1>Okay.

NOTE CONF {"raw":[93]}

00:23:53.780 --> 00:23:57.080
<v Speaker 1>Alas, Haskell is cleverer than I am.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:23:57.470 --> 00:23:58.310
<v Speaker 1>Uh, it tells me.

NOTE CONF {"raw":[77,100,100,100]}

00:23:58.310 --> 00:24:03.170
<v Speaker 1>No, you can't do that because mixed set is, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,89,100,100,100]}

00:24:03.170 --> 00:24:04.610
<v Speaker 1>is not in scope.

NOTE CONF {"raw":[100,100,100,100]}

00:24:04.940 --> 00:24:05.600
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:24:05.600 --> 00:24:06.470
<v Speaker 1>It's hidden.

NOTE CONF {"raw":[98,100]}

00:24:06.470 --> 00:24:07.460
<v Speaker 1>It's it's hidden.

NOTE CONF {"raw":[100,100,100]}

00:24:07.460 --> 00:24:08.960
<v Speaker 1>It's inside the module.

NOTE CONF {"raw":[100,100,100,100]}

00:24:08.960 --> 00:24:12.080
<v Speaker 1>It's only usable inside the module, not outside the module.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:12.080 --> 00:24:13.640
<v Speaker 1>This is outside the module.

NOTE CONF {"raw":[100,100,100,100,100]}

00:24:13.640 --> 00:24:16.220
<v Speaker 1>And this is this is in my 40 million lines

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:24:16.220 --> 00:24:21.890
<v Speaker 1>of code where I'm using, uh, sets, you know, uh,

NOTE CONF {"raw":[100,100,100,100,100,99,100,100,100,60]}

00:24:21.890 --> 00:24:24.050
<v Speaker 1>it's given to me and I'm using it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:24.140 --> 00:24:25.820
<v Speaker 1>So I'm not inside the module.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:25.820 --> 00:24:27.260
<v Speaker 1>I don't have access to mixed sets.

NOTE CONF {"raw":[100,100,100,100,100,84,91]}

00:24:27.260 --> 00:24:29.600
<v Speaker 1>So again, I get an error.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:29.600 --> 00:24:30.950
<v Speaker 1>It doesn't allow me to do this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:30.950 --> 00:24:33.680
<v Speaker 1>So this is protecting the abstraction.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:38.420 --> 00:24:40.730
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[100,96]}

00:24:41.720 --> 00:24:43.100
<v Speaker 1>Uh, this.

NOTE CONF {"raw":[100,100]}

00:24:43.100 --> 00:24:44.870
<v Speaker 1>Let me see much time I have.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:46.190 --> 00:24:46.700
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:24:46.700 --> 00:24:50.690
<v Speaker 1>This is doing the same thing with, uh, with trees.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,97]}

00:24:50.870 --> 00:24:54.140
<v Speaker 1>Um, in this case, I don't have to add new

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:54.140 --> 00:24:55.520
<v Speaker 1>constructors because they're already.

NOTE CONF {"raw":[100,100,100,100]}

00:24:55.520 --> 00:24:57.320
<v Speaker 1>They're nil nil in node.

NOTE CONF {"raw":[78,100,100,97,100]}

00:24:59.510 --> 00:25:04.010
<v Speaker 1>Okay, I just don't export them.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:25:04.370 --> 00:25:04.880
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:04.880 --> 00:25:07.250
<v Speaker 1>And I'll just I'll just, uh, go to the punch

NOTE CONF {"raw":[100,100,100,100,100,79,100,100,100,78]}

00:25:07.250 --> 00:25:08.450
<v Speaker 1>line again.

NOTE CONF {"raw":[78,100]}

00:25:08.450 --> 00:25:10.250
<v Speaker 1>If I try to do the bad thing that I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:10.250 --> 00:25:11.510
<v Speaker 1>tried to do before.

NOTE CONF {"raw":[99,100,100,100]}

00:25:11.960 --> 00:25:13.160
<v Speaker 1>Uh, breaking the invariant.

NOTE CONF {"raw":[100,100,100,100]}

00:25:13.160 --> 00:25:16.580
<v Speaker 1>I won't be able to do that because those constructors,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:16.580 --> 00:25:17.840
<v Speaker 1>they haven't been exported.

NOTE CONF {"raw":[100,100,100,100]}

00:25:17.870 --> 00:25:18.830
<v Speaker 1>They're not available.

NOTE CONF {"raw":[100,100,100]}

00:25:18.830 --> 00:25:20.270
<v Speaker 1>I can't build this tree.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:20.570 --> 00:25:22.970
<v Speaker 1>And Haskell catches my mistake.

NOTE CONF {"raw":[96,100,100,100,100]}

00:25:25.190 --> 00:25:27.650
<v Speaker 1>Okay, so this is this is the secret of, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,50]}

00:25:27.650 --> 00:25:29.030
<v Speaker 1>of abstraction.

NOTE CONF {"raw":[100,100]}

00:25:31.140 --> 00:25:31.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:32.010 --> 00:25:33.690
<v Speaker 1>Um, hide the constructor.

NOTE CONF {"raw":[83,100,100,100]}

00:25:36.420 --> 00:25:36.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:36.930 --> 00:25:38.700
<v Speaker 1>And so here's two versions.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:39.420 --> 00:25:39.990
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:39.990 --> 00:25:46.560
<v Speaker 1>The first version, uh, was what I had before where

NOTE CONF {"raw":[100,100,100,61,100,100,100,100,100,100]}

00:25:46.560 --> 00:25:52.560
<v Speaker 1>I've, uh, defined, uh, sets as being lists without this

NOTE CONF {"raw":[100,91,73,100,100,100,100,100,100,100]}

00:25:52.560 --> 00:25:53.940
<v Speaker 1>hidden constructor.

NOTE CONF {"raw":[100,100]}

00:25:55.560 --> 00:25:56.040
<v Speaker 1>Sorry.

NOTE CONF {"raw":[100]}

00:25:56.040 --> 00:25:56.760
<v Speaker 1>Wait a minute.

NOTE CONF {"raw":[100,100,100]}

00:25:57.480 --> 00:25:57.990
<v Speaker 1>Sorry.

NOTE CONF {"raw":[100]}

00:25:57.990 --> 00:25:59.100
<v Speaker 1>This is the bottom one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:59.100 --> 00:26:00.990
<v Speaker 1>The bottom one is if I.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:26:00.990 --> 00:26:05.580
<v Speaker 1>If I export the constructor, then I get mistakes.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:26:06.180 --> 00:26:06.570
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:26:06.570 --> 00:26:10.140
<v Speaker 1>In the top one is where I'm, uh, I've, uh,

NOTE CONF {"raw":[77,100,100,100,100,100,91,67,100,100]}

00:26:10.140 --> 00:26:11.280
<v Speaker 1>hidden the constructor.

NOTE CONF {"raw":[100,100,100]}

00:26:11.280 --> 00:26:14.430
<v Speaker 1>And so instead of, instead of getting wrong answers, I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:14.430 --> 00:26:18.570
<v Speaker 1>get a an error message from Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:26:21.300 --> 00:26:22.050
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:26:22.410 --> 00:26:24.480
<v Speaker 1>Um, so that was for ordered lists.

NOTE CONF {"raw":[100,100,100,100,100,100,93]}

00:26:24.480 --> 00:26:27.420
<v Speaker 1>And here's the same thing for ordered trees.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:27.420 --> 00:26:30.690
<v Speaker 1>I can either hide the constructor like I've done here,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:32.640 --> 00:26:34.560
<v Speaker 1>and then I get an error message when I try

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:34.560 --> 00:26:36.990
<v Speaker 1>to do something I shouldn't be doing, or else I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97,100]}

00:26:36.990 --> 00:26:38.640
<v Speaker 1>can export the constructor.

NOTE CONF {"raw":[100,100,100,100]}

00:26:38.640 --> 00:26:40.920
<v Speaker 1>This is the syntax you use for that in in

NOTE CONF {"raw":[100,100,100,100,100,82,100,100,100,100]}

00:26:40.920 --> 00:26:43.320
<v Speaker 1>Haskell, uh, exporting the constructor.

NOTE CONF {"raw":[100,99,100,100,52]}

00:26:43.410 --> 00:26:45.030
<v Speaker 1>And then I'm allowed to build this tree.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:45.030 --> 00:26:48.150
<v Speaker 1>That's, that's, that's doesn't satisfy the invariant.

NOTE CONF {"raw":[100,100,98,100,100,100,100]}

00:26:48.150 --> 00:26:49.830
<v Speaker 1>And I get wrong answers.

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:51.270 --> 00:26:51.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:26:51.930 --> 00:26:56.790
<v Speaker 1>So that's, uh, that's the secret of abstraction.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:56.790 --> 00:27:00.660
<v Speaker 1>Um, and I'll just, uh, go to the picture that's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:00.660 --> 00:27:04.770
<v Speaker 1>supposed to, um, remind you of this, um, of this.

NOTE CONF {"raw":[100,100,91,100,100,100,100,100,100,100]}

00:27:04.770 --> 00:27:05.430
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:27:05.610 --> 00:27:10.080
<v Speaker 1>Um, so this is like the situation where you were

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:10.080 --> 00:27:13.740
<v Speaker 1>a small child and you had a, a sibling, um,

NOTE CONF {"raw":[92,100,100,100,100,100,83,100,100,100]}

00:27:13.740 --> 00:27:17.280
<v Speaker 1>and, um, and you had some toy that was very

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:27:17.280 --> 00:27:17.730
<v Speaker 1>special.

NOTE CONF {"raw":[100]}

00:27:17.730 --> 00:27:20.250
<v Speaker 1>And it was your toy, and only you were allowed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:20.250 --> 00:27:21.330
<v Speaker 1>to play with this toy.

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:21.330 --> 00:27:21.840
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:27:21.840 --> 00:27:25.680
<v Speaker 1>So your your brother or sister couldn't, couldn't, uh, couldn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:25.680 --> 00:27:26.940
<v Speaker 1>play with this toy, okay?

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:26.940 --> 00:27:28.240
<v Speaker 1>Because it was yours.

NOTE CONF {"raw":[100,100,100,100]}

00:27:28.780 --> 00:27:29.320
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:27:29.320 --> 00:27:32.260
<v Speaker 1>So that's like the that's like the constructors in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,100,100]}

00:27:32.260 --> 00:27:33.460
<v Speaker 1>data abstraction.

NOTE CONF {"raw":[100,100]}

00:27:33.460 --> 00:27:35.110
<v Speaker 1>So you keep them to yourself.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:27:35.110 --> 00:27:38.710
<v Speaker 1>They're only for use inside the private world of your

NOTE CONF {"raw":[95,100,100,100,100,100,100,100,100,100]}

00:27:38.710 --> 00:27:43.000
<v Speaker 1>of your data abstraction inside this module that's representing that,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:43.000 --> 00:27:45.850
<v Speaker 1>that implements the representation of the data type.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:45.850 --> 00:27:49.570
<v Speaker 1>And outside they're not available because it's mine.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:49.660 --> 00:27:50.440
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:27:50.440 --> 00:27:51.880
<v Speaker 1>Like like here.

NOTE CONF {"raw":[100,100,100]}

00:27:51.880 --> 00:27:53.830
<v Speaker 1>And so what this that's what this allows you to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:53.830 --> 00:27:57.010
<v Speaker 1>do is create data abstractions in modules.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:27:58.420 --> 00:28:01.000
<v Speaker 1>Uh, you know, some of them are more efficient than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:01.000 --> 00:28:01.540
<v Speaker 1>others.

NOTE CONF {"raw":[100]}

00:28:01.540 --> 00:28:06.130
<v Speaker 1>And you can just rip out ones that that aren't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:06.130 --> 00:28:08.950
<v Speaker 1>performing the way you want them to and put in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:09.370 --> 00:28:14.200
<v Speaker 1>others that are better and provided the behaviour is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:28:14.200 --> 00:28:14.680
<v Speaker 1>same.

NOTE CONF {"raw":[100]}

00:28:14.680 --> 00:28:15.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:28:16.000 --> 00:28:17.410
<v Speaker 1>Um, everything works.

NOTE CONF {"raw":[100,100,100]}

00:28:17.410 --> 00:28:19.360
<v Speaker 1>You don't have to check the million lines of code.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:19.360 --> 00:28:21.160
<v Speaker 1>Nothing else needs to change.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:21.490 --> 00:28:22.000
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:28:22.000 --> 00:28:25.600
<v Speaker 1>And that's, um, and that's, uh, the idea of data

NOTE CONF {"raw":[100,100,100,100,100,93,100,100,100,100]}

00:28:25.630 --> 00:28:26.620
<v Speaker 1>abstraction.

NOTE CONF {"raw":[100]}

00:28:27.370 --> 00:28:31.150
<v Speaker 1>And you can do this in other languages as well.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:31.360 --> 00:28:32.590
<v Speaker 1>In ML sorry.

NOTE CONF {"raw":[100,100,99]}

00:28:32.590 --> 00:28:36.820
<v Speaker 1>In in Haskell it's nice because it, it, it automatically,

NOTE CONF {"raw":[100,100,100,100,100,100,82,100,100,100]}

00:28:36.850 --> 00:28:40.570
<v Speaker 1>um, prevents you from making certain kinds of mistakes.

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100]}

00:28:41.110 --> 00:28:41.890
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:28:43.240 --> 00:28:44.620
<v Speaker 1>Are there any questions about that?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:28:44.620 --> 00:28:47.440
<v Speaker 1>I'm going at kind of breakneck speed here because I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:47.440 --> 00:28:52.030
<v Speaker 1>want to get to another topic, but I can.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:52.180 --> 00:28:52.450
<v Speaker 1>Yeah.

NOTE CONF {"raw":[97]}

00:28:52.600 --> 00:28:54.790
<v Speaker 1>No, sorry, I thought I saw a hand, but there

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100,100]}

00:28:54.790 --> 00:28:57.220
<v Speaker 1>wasn't one anybody.

NOTE CONF {"raw":[100,100,100]}

00:28:58.660 --> 00:28:59.350
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:00.100 --> 00:29:00.610
<v Speaker 1>That's it.

NOTE CONF {"raw":[100,100]}

00:29:00.610 --> 00:29:01.270
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:01.270 --> 00:29:02.920
<v Speaker 1>I'm going to I'm going to switch to the next

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:02.920 --> 00:29:03.820
<v Speaker 1>topic then.

NOTE CONF {"raw":[100,100]}

00:29:10.690 --> 00:29:11.350
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:29:11.350 --> 00:29:13.690
<v Speaker 1>This is only going to take half an hour or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:13.840 --> 00:29:16.030
<v Speaker 1>21 minutes actually.

NOTE CONF {"raw":[100,100,100]}

00:29:16.390 --> 00:29:22.150
<v Speaker 1>Um, so this is about lazy evaluation and how computation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:22.150 --> 00:29:25.330
<v Speaker 1>using lazy evaluation relates to normal computation.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:29:25.330 --> 00:29:27.040
<v Speaker 1>And I'm going to say a little bit about sorting

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:27.040 --> 00:29:28.720
<v Speaker 1>lists as well.

NOTE CONF {"raw":[100,100,100]}

00:29:28.720 --> 00:29:30.370
<v Speaker 1>And this is this.

NOTE CONF {"raw":[100,100,100,100]}

00:29:30.370 --> 00:29:31.810
<v Speaker 1>This is a shorter lecture.

NOTE CONF {"raw":[100,100,100,100,100]}

00:29:31.810 --> 00:29:32.680
<v Speaker 1>And so it fits.

NOTE CONF {"raw":[100,100,100,100]}

00:29:32.680 --> 00:29:33.220
<v Speaker 1>It fits.

NOTE CONF {"raw":[100,100]}

00:29:33.220 --> 00:29:37.750
<v Speaker 1>Now um, there's no reading associated with this because the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:37.750 --> 00:29:40.600
<v Speaker 1>material on this and the textbook is sprinkled throughout.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:40.900 --> 00:29:44.350
<v Speaker 1>Um, so you will have already encountered the things that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:44.350 --> 00:29:47.380
<v Speaker 1>are relevant to this in reading that you've done already.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:49.390 --> 00:29:49.900
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:49.900 --> 00:29:53.290
<v Speaker 1>So you know, by now Haskell uses lazy evaluation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:53.290 --> 00:29:56.410
<v Speaker 1>So that allows you to do computations with infinite lists

NOTE CONF {"raw":[100,73,100,100,100,100,100,100,100,100]}

00:29:56.410 --> 00:29:57.250
<v Speaker 1>and so forth.

NOTE CONF {"raw":[100,100,100]}

00:29:57.250 --> 00:30:00.610
<v Speaker 1>It's rather an unusual choice, but it allows us to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:00.610 --> 00:30:02.200
<v Speaker 1>do certain cool things.

NOTE CONF {"raw":[100,100,100,100]}

00:30:02.980 --> 00:30:05.530
<v Speaker 1>And um, how does this work?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:30:06.070 --> 00:30:09.190
<v Speaker 1>Um, so it works by never computing the whole infinite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:09.190 --> 00:30:12.400
<v Speaker 1>data structure, because of course that would be impossible.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:12.760 --> 00:30:15.190
<v Speaker 1>Um, it computes just what it needs to give to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,88,100]}

00:30:15.190 --> 00:30:17.230
<v Speaker 1>give the answer that you're looking for.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:30:17.230 --> 00:30:17.500
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:17.500 --> 00:30:19.960
<v Speaker 1>So if you're if you're doing some computation on infinite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:19.960 --> 00:30:23.530
<v Speaker 1>data structure, but you're only interested in like the 47th

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:23.540 --> 00:30:25.970
<v Speaker 1>element of this of this infinite list.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:30:25.970 --> 00:30:29.270
<v Speaker 1>Then only the first 47 elements of the list will

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:29.270 --> 00:30:32.360
<v Speaker 1>be computed, and then you can reach in and pick

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:32.360 --> 00:30:34.940
<v Speaker 1>out the 47th one, and the rest of it is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:34.940 --> 00:30:35.960
<v Speaker 1>never computed.

NOTE CONF {"raw":[100,100]}

00:30:36.680 --> 00:30:37.160
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:37.160 --> 00:30:42.620
<v Speaker 1>The way it works is that Haskell stores, um, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:42.620 --> 00:30:48.590
<v Speaker 1>Haskell stores code in place of values, um, uh, which

NOTE CONF {"raw":[100,94,100,100,100,100,100,100,95,100]}

00:30:48.590 --> 00:30:51.380
<v Speaker 1>when you run it gives you the value.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:30:52.010 --> 00:30:52.490
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:52.490 --> 00:30:54.650
<v Speaker 1>It doesn't do that always, but it does it in,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:54.650 --> 00:30:57.620
<v Speaker 1>in, um, in the places where it needs to do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:57.620 --> 00:31:00.080
<v Speaker 1>in order to be able to deal with these infinite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:00.080 --> 00:31:01.430
<v Speaker 1>computations and so forth.

NOTE CONF {"raw":[100,100,100,100]}

00:31:01.430 --> 00:31:01.910
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:01.910 --> 00:31:05.540
<v Speaker 1>So, um, it, it stores the code, it evaluates the

NOTE CONF {"raw":[100,100,92,100,100,100,100,100,100,100]}

00:31:05.540 --> 00:31:07.670
<v Speaker 1>code when it needs the value and only when it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:07.670 --> 00:31:08.720
<v Speaker 1>needs the value.

NOTE CONF {"raw":[100,100,100]}

00:31:10.100 --> 00:31:10.730
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:10.730 --> 00:31:13.640
<v Speaker 1>And the code that, that when it runs the code

NOTE CONF {"raw":[100,100,100,90,94,100,100,100,100,100]}

00:31:13.640 --> 00:31:16.400
<v Speaker 1>to produce the value if that, if that code would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:16.400 --> 00:31:21.710
<v Speaker 1>produce, um, an infinite data structure as a value, it

NOTE CONF {"raw":[100,100,100,100,100,100,82,100,100,100]}

00:31:21.710 --> 00:31:25.790
<v Speaker 1>only produces enough of that data structure to do the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:25.790 --> 00:31:27.290
<v Speaker 1>next step in the computation.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:27.290 --> 00:31:29.360
<v Speaker 1>So for example, it's an infinite list.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:29.360 --> 00:31:31.460
<v Speaker 1>It'll produce maybe the head and then a piece of

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:31:31.460 --> 00:31:35.030
<v Speaker 1>code representing, you know, the computation needs to do to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:35.030 --> 00:31:35.900
<v Speaker 1>get the tail.

NOTE CONF {"raw":[100,100,100]}

00:31:38.810 --> 00:31:39.080
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:39.080 --> 00:31:41.330
<v Speaker 1>So it's only computing what it needs to make progress

NOTE CONF {"raw":[100,85,100,100,100,100,100,100,100,100]}

00:31:41.330 --> 00:31:44.150
<v Speaker 1>by storing code in place of data.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:44.270 --> 00:31:44.630
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:44.630 --> 00:31:48.140
<v Speaker 1>You can't see this when you're writing programs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:31:48.140 --> 00:31:50.270
<v Speaker 1>You can't access the code, but you can see the

NOTE CONF {"raw":[94,58,100,100,100,100,100,100,100,100]}

00:31:50.270 --> 00:31:54.140
<v Speaker 1>effect because of the fact that that things are you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,52,100]}

00:31:54.140 --> 00:31:56.150
<v Speaker 1>know, they don't they don't run forever.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:56.150 --> 00:32:00.440
<v Speaker 1>And in fact, sometimes they're surprisingly they're fast in ways

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:00.440 --> 00:32:02.450
<v Speaker 1>that you're surprised by.

NOTE CONF {"raw":[100,100,100,100]}

00:32:02.690 --> 00:32:05.300
<v Speaker 1>Okay, so here's a here's a kind of really stupid

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:05.300 --> 00:32:08.750
<v Speaker 1>example, but it illustrates what I want to what I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:08.750 --> 00:32:09.860
<v Speaker 1>want to show you.

NOTE CONF {"raw":[100,100,100,100]}

00:32:09.950 --> 00:32:10.280
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:10.280 --> 00:32:13.490
<v Speaker 1>Imagine you want to search for the first odd number.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:14.180 --> 00:32:16.280
<v Speaker 1>Um, uh, what is it?

NOTE CONF {"raw":[100,87,100,100,100]}

00:32:16.280 --> 00:32:16.580
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:16.580 --> 00:32:17.960
<v Speaker 1>Then the answer is one.

NOTE CONF {"raw":[81,100,100,100,100]}

00:32:18.560 --> 00:32:19.280
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:19.280 --> 00:32:22.860
<v Speaker 1>But here's a here's a here's a really stupid program

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:23.610 --> 00:32:27.000
<v Speaker 1>for finding that the number one is the first odd

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:27.000 --> 00:32:27.390
<v Speaker 1>number.

NOTE CONF {"raw":[100]}

00:32:27.390 --> 00:32:28.020
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:28.290 --> 00:32:32.160
<v Speaker 1>Um, uh, you I've written three versions of this ho

NOTE CONF {"raw":[100,99,97,100,100,100,100,100,100,95]}

00:32:32.160 --> 00:32:35.370
<v Speaker 1>for higher order comp for list comprehension and rec for

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,93,100]}

00:32:35.370 --> 00:32:36.180
<v Speaker 1>recursive.

NOTE CONF {"raw":[100]}

00:32:36.270 --> 00:32:40.620
<v Speaker 1>Okay, so, um, this program, it takes the list of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:40.620 --> 00:32:42.210
<v Speaker 1>numbers from zero up to n.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:43.590 --> 00:32:46.470
<v Speaker 1>It filters them to get out the to get the

NOTE CONF {"raw":[100,100,100,100,100,100,88,100,100,100]}

00:32:46.470 --> 00:32:50.220
<v Speaker 1>odd ones, and then it takes the first one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:52.080 --> 00:32:52.470
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:52.470 --> 00:32:55.920
<v Speaker 1>So imagine n is, is uh, uh, 30 trillion or

NOTE CONF {"raw":[100,100,100,100,100,55,99,100,100,100]}

00:32:55.920 --> 00:32:57.030
<v Speaker 1>something like that.

NOTE CONF {"raw":[100,100,100]}

00:32:57.300 --> 00:32:57.840
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:57.840 --> 00:33:00.990
<v Speaker 1>So this produces this enormous, enormous list.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:00.990 --> 00:33:03.570
<v Speaker 1>Filters out all the odd ones okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:03.570 --> 00:33:05.130
<v Speaker 1>There's only 15 trillion of them.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:05.130 --> 00:33:08.010
<v Speaker 1>If there are 30 trillion in this list and then

NOTE CONF {"raw":[100,100,94,100,100,100,100,100,100,100]}

00:33:08.010 --> 00:33:10.170
<v Speaker 1>it takes the first one, it's the answer is one.

NOTE CONF {"raw":[100,100,100,100,100,92,100,100,100,100]}

00:33:10.950 --> 00:33:11.220
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:33:11.220 --> 00:33:13.950
<v Speaker 1>That's a pretty inefficient way to compute the number one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:14.430 --> 00:33:14.790
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:33:14.790 --> 00:33:16.380
<v Speaker 1>But that's what this program does.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:17.250 --> 00:33:21.240
<v Speaker 1>And this comprehension version does the same thing, essentially just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:21.240 --> 00:33:22.650
<v Speaker 1>written in different syntax.

NOTE CONF {"raw":[100,100,100,100]}

00:33:22.650 --> 00:33:22.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:33:22.950 --> 00:33:28.680
<v Speaker 1>This, this, uh, this bit of code, um, computes all

NOTE CONF {"raw":[100,95,74,100,100,100,100,100,100,100]}

00:33:28.680 --> 00:33:31.500
<v Speaker 1>of the odd numbers from zero up to n, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:31.500 --> 00:33:33.390
<v Speaker 1>then you pick the first one and it's one.

NOTE CONF {"raw":[100,100,100,84,100,100,46,89,100]}

00:33:35.310 --> 00:33:37.260
<v Speaker 1>Um, I'm not going to go into the details of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:37.260 --> 00:33:39.780
<v Speaker 1>this, but this is, this is doing it recursively by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:39.780 --> 00:33:40.620
<v Speaker 1>searching.

NOTE CONF {"raw":[100]}

00:33:40.620 --> 00:33:41.370
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:33:41.640 --> 00:33:49.560
<v Speaker 1>Um, so in a non lazy language, um, these two,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:49.710 --> 00:33:53.130
<v Speaker 1>these first two would take time that's proportional to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:53.160 --> 00:33:55.590
<v Speaker 1>to the number n okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:55.590 --> 00:33:58.800
<v Speaker 1>If you, if you want to filter out, uh, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:58.800 --> 00:34:01.230
<v Speaker 1>know, the first from the first million numbers, if you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:01.230 --> 00:34:03.300
<v Speaker 1>want to filter out the odd numbers of the first

NOTE CONF {"raw":[100,100,77,100,100,100,100,100,100,100]}

00:34:03.300 --> 00:34:07.650
<v Speaker 1>billion numbers, okay, it'll be the size, you know, the

NOTE CONF {"raw":[100,100,100,97,100,100,100,100,100,100]}

00:34:07.650 --> 00:34:09.960
<v Speaker 1>number million or billion or whatever, that will be the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:09.960 --> 00:34:12.240
<v Speaker 1>size of the of the data structures you're dealing with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:12.240 --> 00:34:12.720
<v Speaker 1>here.

NOTE CONF {"raw":[100]}

00:34:12.720 --> 00:34:16.110
<v Speaker 1>And you have to you have to go through all

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:16.110 --> 00:34:18.480
<v Speaker 1>of them, you know, for example, to filter out the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:18.480 --> 00:34:19.050
<v Speaker 1>odd ones.

NOTE CONF {"raw":[100,100]}

00:34:19.060 --> 00:34:19.360
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:34:19.360 --> 00:34:23.350
<v Speaker 1>So linear in n okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:23.350 --> 00:34:25.629
<v Speaker 1>Whereas I won't go into the details here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:34:25.629 --> 00:34:30.639
<v Speaker 1>But this recursive, this recursive searching function will return the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:30.639 --> 00:34:32.710
<v Speaker 1>result in a couple of steps because it only looks

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:32.710 --> 00:34:35.860
<v Speaker 1>at at zero and one, and then it stops because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:35.860 --> 00:34:37.450
<v Speaker 1>that's a that's an odd number.

NOTE CONF {"raw":[100,51,100,100,100,100]}

00:34:37.629 --> 00:34:37.929
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:34:37.929 --> 00:34:43.090
<v Speaker 1>So this is this this third one is constant okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:43.090 --> 00:34:46.690
<v Speaker 1>But um, if you actually run these programs, well first

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:46.690 --> 00:34:49.120
<v Speaker 1>of all, if you run it with large value of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:49.120 --> 00:34:53.710
<v Speaker 1>N, it'll all three of them will, will come back

NOTE CONF {"raw":[100,99,100,100,100,100,100,100,100,100]}

00:34:53.710 --> 00:34:59.650
<v Speaker 1>immediately because, um, uh, it's so fast that, um, that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:59.830 --> 00:35:01.630
<v Speaker 1>you can't see that it's taking up time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:35:01.630 --> 00:35:03.730
<v Speaker 1>I forgot to say here, this is a way in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:03.730 --> 00:35:05.980
<v Speaker 1>Haskell that you can ask it to tell you how

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:05.980 --> 00:35:08.860
<v Speaker 1>fast things are going, and then you get reports on

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:08.860 --> 00:35:10.510
<v Speaker 1>time and space like this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:11.080 --> 00:35:11.650
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:35:11.650 --> 00:35:15.040
<v Speaker 1>This is, uh, setting statistics on is what this says.

NOTE CONF {"raw":[100,100,84,100,100,100,100,100,100,100]}

00:35:15.820 --> 00:35:16.330
<v Speaker 1>Okay?

NOTE CONF {"raw":[100]}

00:35:16.330 --> 00:35:18.610
<v Speaker 1>So it's telling you this takes zero seconds.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:35:19.600 --> 00:35:21.280
<v Speaker 1>This is the higher order version.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:21.310 --> 00:35:21.940
<v Speaker 1>Here's another.

NOTE CONF {"raw":[100,100]}

00:35:21.970 --> 00:35:24.310
<v Speaker 1>Here's the other version that also takes zero seconds, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:24.310 --> 00:35:26.710
<v Speaker 1>the recursive version also takes zero seconds.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:26.710 --> 00:35:29.380
<v Speaker 1>And if you try this, if you say, well, okay,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:29.620 --> 00:35:30.970
<v Speaker 1>uh, ten.

NOTE CONF {"raw":[100,100]}

00:35:31.180 --> 00:35:33.700
<v Speaker 1>Let's see, 1 million is not a big enough number.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:33.700 --> 00:35:37.420
<v Speaker 1>Let's try, uh, you know, 1 trillion or something.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:35:37.420 --> 00:35:38.620
<v Speaker 1>It won't make any difference.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:38.620 --> 00:35:40.990
<v Speaker 1>It'll still, uh, return immediately.

NOTE CONF {"raw":[100,100,89,100,100]}

00:35:40.990 --> 00:35:44.230
<v Speaker 1>It will still take zero seconds because it doesn't compute

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:44.230 --> 00:35:47.380
<v Speaker 1>these big lists because of lazy evaluation.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:49.420 --> 00:35:54.430
<v Speaker 1>Okay, so that's, uh, that's one interesting thing, okay, about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:35:54.430 --> 00:35:57.880
<v Speaker 1>lazy evaluation, uh, things that are that look inefficient or

NOTE CONF {"raw":[100,100,95,100,100,100,100,100,100,55]}

00:35:57.880 --> 00:36:01.090
<v Speaker 1>sometimes, uh, really efficient.

NOTE CONF {"raw":[100,100,100,100]}

00:36:01.090 --> 00:36:01.660
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:36:01.960 --> 00:36:04.990
<v Speaker 1>Um, this is how the recursion version works.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:36:04.990 --> 00:36:07.240
<v Speaker 1>It takes it takes three steps to get to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:07.240 --> 00:36:07.930
<v Speaker 1>answer.

NOTE CONF {"raw":[100]}

00:36:08.260 --> 00:36:12.640
<v Speaker 1>Um, here's how the higher order version works, where the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:12.640 --> 00:36:16.970
<v Speaker 1>notation here putting things inside a box is my way

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:16.970 --> 00:36:20.390
<v Speaker 1>of saying that it's not this value, it's the code

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:20.390 --> 00:36:22.190
<v Speaker 1>for producing this value.

NOTE CONF {"raw":[100,100,100,100]}

00:36:23.600 --> 00:36:27.260
<v Speaker 1>Okay, so if you want H0 of of a million,

NOTE CONF {"raw":[100,100,100,100,100,85,100,100,100,100]}

00:36:28.070 --> 00:36:31.610
<v Speaker 1>you'll, you'll take, um, you know, it's the right hand

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:36:31.610 --> 00:36:34.430
<v Speaker 1>side here and the right and, and the list is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:34.430 --> 00:36:35.990
<v Speaker 1>from zero up to a million.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:35.990 --> 00:36:37.640
<v Speaker 1>But it's code for that list.

NOTE CONF {"raw":[100,96,100,100,100,100]}

00:36:37.640 --> 00:36:39.080
<v Speaker 1>It's not the list itself.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:39.080 --> 00:36:40.940
<v Speaker 1>It's code for producing that list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:42.140 --> 00:36:42.680
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:36:42.680 --> 00:36:44.120
<v Speaker 1>And um, okay.

NOTE CONF {"raw":[100,100,100]}

00:36:44.120 --> 00:36:47.930
<v Speaker 1>The, the the composition here changes a little bit.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:36:47.930 --> 00:36:50.210
<v Speaker 1>And then, and then at this stage you need to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:50.210 --> 00:36:52.730
<v Speaker 1>actually look and see what's in this list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:36:52.730 --> 00:36:55.940
<v Speaker 1>And so you evaluate the code enough to give you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:55.940 --> 00:36:58.640
<v Speaker 1>the head of the list okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:58.640 --> 00:37:00.020
<v Speaker 1>Head of list is zero.

NOTE CONF {"raw":[98,100,100,100,100]}

00:37:00.980 --> 00:37:02.180
<v Speaker 1>And then the rest of the list.

NOTE CONF {"raw":[100,100,100,100,100,100,94]}

00:37:02.180 --> 00:37:04.610
<v Speaker 1>So cons and then code for the rest of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:04.610 --> 00:37:05.240
<v Speaker 1>list.

NOTE CONF {"raw":[95]}

00:37:05.240 --> 00:37:07.820
<v Speaker 1>So the numbers from one up to a million.

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,98]}

00:37:10.520 --> 00:37:11.240
<v Speaker 1>Um okay.

NOTE CONF {"raw":[100,100]}

00:37:11.240 --> 00:37:12.230
<v Speaker 1>Zero is not odd.

NOTE CONF {"raw":[100,100,100,100]}

00:37:12.230 --> 00:37:13.610
<v Speaker 1>So it gets thrown away.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:13.940 --> 00:37:16.640
<v Speaker 1>I've actually left out a step or two here gets

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:16.640 --> 00:37:17.390
<v Speaker 1>thrown away.

NOTE CONF {"raw":[100,100]}

00:37:17.930 --> 00:37:21.290
<v Speaker 1>You evaluate this thing again to give you the list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:21.290 --> 00:37:25.940
<v Speaker 1>containing one cons code for the rest of the list.

NOTE CONF {"raw":[100,100,84,100,100,100,100,100,100,100]}

00:37:27.830 --> 00:37:30.350
<v Speaker 1>Okay, one is odd.

NOTE CONF {"raw":[100,100,100,100]}

00:37:31.460 --> 00:37:35.810
<v Speaker 1>So, uh, you know, so the filter, um, allows it

NOTE CONF {"raw":[100,93,100,100,100,100,100,100,100,100]}

00:37:35.810 --> 00:37:36.470
<v Speaker 1>through.

NOTE CONF {"raw":[100]}

00:37:38.510 --> 00:37:41.000
<v Speaker 1>And, um, and that ends up being the answer.

NOTE CONF {"raw":[97,74,100,100,100,100,100,100,100]}

00:37:41.000 --> 00:37:42.770
<v Speaker 1>And you don't ever have to evaluate the rest of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:42.770 --> 00:37:43.670
<v Speaker 1>this, okay?

NOTE CONF {"raw":[100,100]}

00:37:45.170 --> 00:37:47.300
<v Speaker 1>If you look at these steps okay, one is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:47.300 --> 00:37:48.200
<v Speaker 1>answer here.

NOTE CONF {"raw":[100,100]}

00:37:48.620 --> 00:37:51.710
<v Speaker 1>Uh, because you're doing a take one of this list

NOTE CONF {"raw":[88,100,100,100,100,100,100,100,100,100]}

00:37:51.710 --> 00:37:53.660
<v Speaker 1>of this big list, and you only want the first

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:53.660 --> 00:37:54.290
<v Speaker 1>element.

NOTE CONF {"raw":[100]}

00:37:56.750 --> 00:37:57.410
<v Speaker 1>Okay.

NOTE CONF {"raw":[85]}

00:37:57.650 --> 00:38:02.570
<v Speaker 1>Um, so this is showing how it's not evaluating this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:02.570 --> 00:38:03.350
<v Speaker 1>whole thing.

NOTE CONF {"raw":[100,100]}

00:38:03.350 --> 00:38:06.890
<v Speaker 1>And in addition to this, there's, um, okay, there's some

NOTE CONF {"raw":[100,100,100,100,100,100,91,100,100,100]}

00:38:06.890 --> 00:38:09.050
<v Speaker 1>overhead involved in doing lazy evaluation, so you have to

NOTE CONF {"raw":[100,100,100,100,100,83,100,100,100,100]}

00:38:09.050 --> 00:38:09.860
<v Speaker 1>be careful.

NOTE CONF {"raw":[100,100]}

00:38:10.160 --> 00:38:12.950
<v Speaker 1>Uh, Haskell has to be careful where it's applying this

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:38:12.950 --> 00:38:16.970
<v Speaker 1>kind of packaging things up as code and and evaluating

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:16.970 --> 00:38:18.830
<v Speaker 1>them when required.

NOTE CONF {"raw":[100,100,100]}

00:38:19.010 --> 00:38:22.610
<v Speaker 1>Um, it does very clever analysis of your code to

NOTE CONF {"raw":[63,100,100,100,100,100,100,100,100,100]}

00:38:22.610 --> 00:38:25.820
<v Speaker 1>decide where the places are that it needs to put

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:25.820 --> 00:38:28.550
<v Speaker 1>in, um, code instead of values.

NOTE CONF {"raw":[100,93,100,100,100,100]}

00:38:29.150 --> 00:38:29.600
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:38:29.600 --> 00:38:30.800
<v Speaker 1>So it doesn't do it everywhere.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:30.800 --> 00:38:34.310
<v Speaker 1>It does it in the place where, um, there there

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:34.310 --> 00:38:35.990
<v Speaker 1>could be a problem.

NOTE CONF {"raw":[100,100,100,100]}

00:38:36.260 --> 00:38:39.020
<v Speaker 1>Um, the analysis is called strictness analysis.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:40.190 --> 00:38:45.290
<v Speaker 1>Um, and it avoids most of the overhead, uh, of,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,81,100]}

00:38:45.290 --> 00:38:47.000
<v Speaker 1>of doing lazy evaluation.

NOTE CONF {"raw":[100,100,100,100]}

00:38:48.800 --> 00:38:49.160
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:38:49.160 --> 00:38:50.930
<v Speaker 1>So that's one thing I wanted to show you.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:38:51.440 --> 00:38:57.230
<v Speaker 1>Um, I'm going to skip this part, and I'll just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:57.230 --> 00:39:04.760
<v Speaker 1>say, um, uh, there's a situation in programming where you,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:04.760 --> 00:39:07.340
<v Speaker 1>um, you have a choice.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:07.340 --> 00:39:11.780
<v Speaker 1>Very often a choice between simple code that's slow and

NOTE CONF {"raw":[100,100,100,100,100,100,100,66,100,100]}

00:39:11.780 --> 00:39:13.650
<v Speaker 1>complicated code that's fast.

NOTE CONF {"raw":[100,100,100,100]}

00:39:13.830 --> 00:39:15.660
<v Speaker 1>It's like going shopping.

NOTE CONF {"raw":[100,100,100,100]}

00:39:16.080 --> 00:39:19.080
<v Speaker 1>You can buy something that's cheap and not so good,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:19.080 --> 00:39:21.570
<v Speaker 1>and it breaks very quickly.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:21.570 --> 00:39:24.660
<v Speaker 1>Or you can buy something expensive and, you know, high

NOTE CONF {"raw":[100,100,100,100,100,100,100,57,57,100]}

00:39:24.660 --> 00:39:26.130
<v Speaker 1>quality and it lasts forever.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:26.130 --> 00:39:26.370
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:26.370 --> 00:39:27.480
<v Speaker 1>You get a choice.

NOTE CONF {"raw":[100,100,100,100]}

00:39:27.840 --> 00:39:32.280
<v Speaker 1>Um, and you can decide there's a trade off whether

NOTE CONF {"raw":[100,100,100,100,100,87,100,100,100,100]}

00:39:32.280 --> 00:39:36.090
<v Speaker 1>you pick, you know, cheap and, and and, and and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:36.090 --> 00:39:39.630
<v Speaker 1>flimsy or expensive and high quality.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:39.630 --> 00:39:40.170
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:40.170 --> 00:39:41.190
<v Speaker 1>The big wins.

NOTE CONF {"raw":[100,100,73]}

00:39:41.190 --> 00:39:41.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:41.400 --> 00:39:43.440
<v Speaker 1>This is so this is what it's like in programming.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:43.440 --> 00:39:45.660
<v Speaker 1>Simple and slow, complex and fast.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:45.660 --> 00:39:48.240
<v Speaker 1>Big win is when you can find a way to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:48.240 --> 00:39:50.010
<v Speaker 1>be both simple and fast.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:50.010 --> 00:39:52.620
<v Speaker 1>So that's like cheap and high quality.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:39:52.800 --> 00:39:53.100
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:53.100 --> 00:39:53.970
<v Speaker 1>It's a bargain.

NOTE CONF {"raw":[100,100,100]}

00:39:55.050 --> 00:39:58.410
<v Speaker 1>Um, and uh, uh, you know, so in this case,

NOTE CONF {"raw":[100,100,83,100,100,100,100,100,100,100]}

00:39:58.410 --> 00:40:01.650
<v Speaker 1>for example, this complicated recursive program, you'd expect it to

NOTE CONF {"raw":[100,100,100,100,100,100,93,100,100,100]}

00:40:01.650 --> 00:40:05.190
<v Speaker 1>take to be really fast compared with this, with this,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:05.190 --> 00:40:07.770
<v Speaker 1>um, simple high order program.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:07.980 --> 00:40:10.170
<v Speaker 1>Um, but in fact, it isn't.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:10.380 --> 00:40:10.800
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:40:10.800 --> 00:40:13.950
<v Speaker 1>And this is the result of using lazy evaluation and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:13.950 --> 00:40:18.540
<v Speaker 1>this clever on strictness analysis that that Haskell does for

NOTE CONF {"raw":[100,100,52,100,100,100,100,82,100,100]}

00:40:18.540 --> 00:40:18.990
<v Speaker 1>you.

NOTE CONF {"raw":[100]}

00:40:19.170 --> 00:40:19.920
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:40:19.920 --> 00:40:21.180
<v Speaker 1>So, um.

NOTE CONF {"raw":[100,99]}

00:40:23.340 --> 00:40:23.580
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:40:23.580 --> 00:40:26.790
<v Speaker 1>Simple is good because simple means you don't have to

NOTE CONF {"raw":[100,79,100,100,100,100,100,100,100,100]}

00:40:26.790 --> 00:40:29.340
<v Speaker 1>think very hard to, to make it right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:29.970 --> 00:40:31.320
<v Speaker 1>And of course, fast is good.

NOTE CONF {"raw":[100,100,100,100,81,100]}

00:40:31.320 --> 00:40:32.190
<v Speaker 1>That's clear.

NOTE CONF {"raw":[100,100]}

00:40:32.520 --> 00:40:33.150
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:40:35.790 --> 00:40:36.870
<v Speaker 1>Any questions about that?

NOTE CONF {"raw":[100,100,100,100]}

00:40:36.870 --> 00:40:38.970
<v Speaker 1>I'm going to say something about sorting now.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:40.470 --> 00:40:44.460
<v Speaker 1>This is a this is a very quick lecture with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:44.640 --> 00:40:46.710
<v Speaker 1>different topics okay.

NOTE CONF {"raw":[100,100,94]}

00:40:49.110 --> 00:40:51.750
<v Speaker 1>I'm going to be showing you some sorting algorithms.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:40:52.320 --> 00:40:53.640
<v Speaker 1>So what's sorting.

NOTE CONF {"raw":[100,77,100]}

00:40:53.940 --> 00:40:56.670
<v Speaker 1>It's about arranging a list into ascending order.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:56.670 --> 00:40:59.130
<v Speaker 1>And this is a very common thing that you do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:59.460 --> 00:41:00.030
<v Speaker 1>okay.

NOTE CONF {"raw":[91]}

00:41:00.030 --> 00:41:02.070
<v Speaker 1>In in in computing okay.

NOTE CONF {"raw":[71,100,100,100,100]}

00:41:02.370 --> 00:41:06.540
<v Speaker 1>Uh, you know, dictionaries are in alphabetical order.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:41:06.540 --> 00:41:09.510
<v Speaker 1>I mean, nobody uses dictionaries anymore on paper, but, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:41:09.930 --> 00:41:12.070
<v Speaker 1>in the old days, you had a book and you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:12.070 --> 00:41:14.290
<v Speaker 1>would find things by by looking.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:14.290 --> 00:41:16.720
<v Speaker 1>And it only was possible to find things because the

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:41:16.720 --> 00:41:17.830
<v Speaker 1>words were in order.

NOTE CONF {"raw":[100,100,100,100]}

00:41:17.950 --> 00:41:18.670
<v Speaker 1>Okay.

NOTE CONF {"raw":[75]}

00:41:18.820 --> 00:41:20.830
<v Speaker 1>Um, there's lots of other situations where you need to

NOTE CONF {"raw":[75,100,100,100,100,100,100,100,100,100]}

00:41:20.830 --> 00:41:22.780
<v Speaker 1>put things in order, and there are different ways of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:22.780 --> 00:41:23.500
<v Speaker 1>doing it.

NOTE CONF {"raw":[100,100]}

00:41:24.850 --> 00:41:25.600
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:25.810 --> 00:41:29.410
<v Speaker 1>Um, so I'll just want to show you three algorithms

NOTE CONF {"raw":[100,100,55,100,94,100,100,100,100,100]}

00:41:29.410 --> 00:41:30.640
<v Speaker 1>for doing sorting.

NOTE CONF {"raw":[100,100,100]}

00:41:32.740 --> 00:41:35.200
<v Speaker 1>And the first one is called insertion sort.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:41:35.200 --> 00:41:35.530
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:35.530 --> 00:41:37.300
<v Speaker 1>This this top thing is about fold.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:41:37.300 --> 00:41:38.920
<v Speaker 1>You already know about fold.

NOTE CONF {"raw":[100,100,100,100,100]}

00:41:39.310 --> 00:41:42.460
<v Speaker 1>Um, this is insertion sort and it happens to use

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:42.460 --> 00:41:43.120
<v Speaker 1>fold.

NOTE CONF {"raw":[100]}

00:41:43.600 --> 00:41:43.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:43.930 --> 00:41:48.160
<v Speaker 1>The idea of insertion sort is, uh, you have a

NOTE CONF {"raw":[100,100,100,100,100,100,69,100,100,100]}

00:41:48.160 --> 00:41:51.280
<v Speaker 1>list of values, and they're not in any particular order.

NOTE CONF {"raw":[100,100,100,100,85,100,100,100,100,100]}

00:41:51.280 --> 00:41:53.680
<v Speaker 1>Okay, let's let's imagine that there are numbers, lots of

NOTE CONF {"raw":[100,100,100,100,100,85,85,100,100,100]}

00:41:53.680 --> 00:41:54.400
<v Speaker 1>numbers.

NOTE CONF {"raw":[100]}

00:41:54.400 --> 00:41:54.880
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:54.880 --> 00:41:58.030
<v Speaker 1>So the way to sort this list of numbers is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:58.030 --> 00:42:01.870
<v Speaker 1>that you take another list which starts off being empty,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:02.410 --> 00:42:04.810
<v Speaker 1>and you put each of the numbers from this, from

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:04.810 --> 00:42:08.080
<v Speaker 1>this unordered list into this new list, one at a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:08.080 --> 00:42:08.800
<v Speaker 1>time.

NOTE CONF {"raw":[100]}

00:42:09.250 --> 00:42:11.980
<v Speaker 1>Keeping them, keeping the new list in order as you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:11.980 --> 00:42:12.400
<v Speaker 1>do it.

NOTE CONF {"raw":[100,100]}

00:42:12.400 --> 00:42:13.540
<v Speaker 1>So you're doing insert.

NOTE CONF {"raw":[100,100,100,100]}

00:42:13.540 --> 00:42:17.560
<v Speaker 1>Remember the insert function from our ordered list?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:18.070 --> 00:42:21.070
<v Speaker 1>Okay, it looks for the right place to put each

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:21.070 --> 00:42:23.350
<v Speaker 1>number, and then it puts it there so that the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:23.350 --> 00:42:25.870
<v Speaker 1>list is kept in ascending order.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:26.440 --> 00:42:27.130
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:42:27.940 --> 00:42:29.770
<v Speaker 1>And so if you do that for all of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:29.770 --> 00:42:32.020
<v Speaker 1>all of the numbers in your unordered list, you put

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:32.020 --> 00:42:34.510
<v Speaker 1>them into this new list, maintaining the order.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:34.510 --> 00:42:36.970
<v Speaker 1>In the end, all of the numbers will be there

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:36.970 --> 00:42:39.700
<v Speaker 1>and they'll be in ascending order.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:41.050 --> 00:42:45.190
<v Speaker 1>Okay, that's the idea of insertion sort named insertion sort

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:45.190 --> 00:42:49.060
<v Speaker 1>because of the fact that it's using this sum, this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,73,100]}

00:42:49.060 --> 00:42:53.020
<v Speaker 1>function insert that you've seen already from.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:42:53.020 --> 00:42:54.670
<v Speaker 1>Um, yeah.

NOTE CONF {"raw":[100,100]}

00:42:54.670 --> 00:42:58.480
<v Speaker 1>The earlier part of the lecture, I think on Monday

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:58.480 --> 00:43:00.130
<v Speaker 1>or whenever it was.

NOTE CONF {"raw":[100,100,100,100]}

00:43:00.130 --> 00:43:00.730
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:00.730 --> 00:43:03.820
<v Speaker 1>And, and this is code which sort of repeatedly does

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:03.820 --> 00:43:04.420
<v Speaker 1>that.

NOTE CONF {"raw":[100]}

00:43:04.840 --> 00:43:09.380
<v Speaker 1>Um, using fold starting from the empty list Okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:43:09.560 --> 00:43:11.000
<v Speaker 1>That's insertion sort.

NOTE CONF {"raw":[100,100,100]}

00:43:13.010 --> 00:43:14.780
<v Speaker 1>So how much time does this take?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:43:14.780 --> 00:43:17.840
<v Speaker 1>Let's look at the, uh, at the at the running

NOTE CONF {"raw":[100,100,100,100,82,100,100,100,100,100]}

00:43:17.840 --> 00:43:18.410
<v Speaker 1>time.

NOTE CONF {"raw":[100]}

00:43:18.680 --> 00:43:19.370
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:19.370 --> 00:43:20.420
<v Speaker 1>It's, um.

NOTE CONF {"raw":[100,97]}

00:43:21.950 --> 00:43:23.690
<v Speaker 1>Does anybody actually have a guess?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:26.390 --> 00:43:30.590
<v Speaker 1>Does anybody n squared, I think I just heard yeah.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:43:30.740 --> 00:43:31.130
<v Speaker 1>Yeah.

NOTE CONF {"raw":[98]}

00:43:31.130 --> 00:43:32.180
<v Speaker 1>It's it's quadratic.

NOTE CONF {"raw":[93,100,100]}

00:43:32.180 --> 00:43:33.050
<v Speaker 1>It's n squared.

NOTE CONF {"raw":[100,100,100]}

00:43:33.050 --> 00:43:33.980
<v Speaker 1>It's n squared.

NOTE CONF {"raw":[100,100,100]}

00:43:33.980 --> 00:43:37.070
<v Speaker 1>Because actually because I told you it was uh no

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,100]}

00:43:37.070 --> 00:43:37.730
<v Speaker 1>I didn't.

NOTE CONF {"raw":[100,100]}

00:43:38.450 --> 00:43:39.140
<v Speaker 1>Maybe I did.

NOTE CONF {"raw":[100,100,100]}

00:43:39.140 --> 00:43:42.410
<v Speaker 1>Anyway, um, insert is linear.

NOTE CONF {"raw":[100,100,100,100,100]}

00:43:43.010 --> 00:43:43.430
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:43.430 --> 00:43:46.760
<v Speaker 1>Because, uh, you're putting a new element into a list.

NOTE CONF {"raw":[100,92,100,100,100,100,100,100,100,100]}

00:43:46.760 --> 00:43:48.410
<v Speaker 1>You have to look for the right place to put

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:48.410 --> 00:43:48.830
<v Speaker 1>it.

NOTE CONF {"raw":[100]}

00:43:49.100 --> 00:43:49.550
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:49.550 --> 00:43:52.010
<v Speaker 1>So you have to look at everything in the list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:52.010 --> 00:43:52.940
<v Speaker 1>potentially.

NOTE CONF {"raw":[100]}

00:43:53.270 --> 00:43:53.750
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:53.750 --> 00:43:55.640
<v Speaker 1>And you have to do that for every one of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:55.640 --> 00:43:57.380
<v Speaker 1>the elements from your original list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:58.040 --> 00:43:58.490
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:58.490 --> 00:44:02.420
<v Speaker 1>So um, in fact, it's one plus two plus three

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:02.420 --> 00:44:05.870
<v Speaker 1>plus four plus dot dot dot plus n steps, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:05.870 --> 00:44:08.930
<v Speaker 1>is actually n times n minus one over two, but

NOTE CONF {"raw":[100,100,97,100,100,100,100,100,100,100]}

00:44:08.930 --> 00:44:12.080
<v Speaker 1>that ends up being n squared with a with a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:12.080 --> 00:44:14.780
<v Speaker 1>constant um, constant factor.

NOTE CONF {"raw":[100,64,100,100]}

00:44:15.680 --> 00:44:16.010
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:44:16.010 --> 00:44:17.030
<v Speaker 1>So insertion sort.

NOTE CONF {"raw":[100,100,100]}

00:44:17.180 --> 00:44:18.050
<v Speaker 1>Quadratic.

NOTE CONF {"raw":[100]}

00:44:18.050 --> 00:44:20.870
<v Speaker 1>That's not very good as a sorting method, but it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,95]}

00:44:20.870 --> 00:44:22.190
<v Speaker 1>uh but it's simple.

NOTE CONF {"raw":[96,100,100,100]}

00:44:23.630 --> 00:44:26.360
<v Speaker 1>Um, here's another sorting method.

NOTE CONF {"raw":[100,100,100,100,100]}

00:44:26.360 --> 00:44:27.560
<v Speaker 1>It's called quicksort.

NOTE CONF {"raw":[97,100,100]}

00:44:28.460 --> 00:44:28.760
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:44:31.310 --> 00:44:37.370
<v Speaker 1>Quicksort is uh, is a so-called divide and conquer method.

NOTE CONF {"raw":[100,100,100,100,100,86,100,100,100,98]}

00:44:37.400 --> 00:44:41.510
<v Speaker 1>What it does is it takes it takes a list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:42.230 --> 00:44:43.970
<v Speaker 1>Okay, here's here's a list.

NOTE CONF {"raw":[100,100,100,94,100]}

00:44:45.260 --> 00:44:46.250
<v Speaker 1>Ignore the first.

NOTE CONF {"raw":[100,100,100]}

00:44:46.250 --> 00:44:47.240
<v Speaker 1>Ignore the first line.

NOTE CONF {"raw":[100,100,100,100]}

00:44:47.240 --> 00:44:48.440
<v Speaker 1>I'll come back to that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:44:48.440 --> 00:44:49.760
<v Speaker 1>It takes a list.

NOTE CONF {"raw":[100,100,100,100]}

00:44:50.630 --> 00:44:56.540
<v Speaker 1>And it, uh, first, um, filters out all the things

NOTE CONF {"raw":[100,100,52,100,100,100,100,100,100,100]}

00:44:56.540 --> 00:44:57.350
<v Speaker 1>in the list.

NOTE CONF {"raw":[100,100,100]}

00:44:58.310 --> 00:44:59.570
<v Speaker 1>Okay, well, it takes a list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:44:59.570 --> 00:45:00.650
<v Speaker 1>It looks at the first element.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:45:00.650 --> 00:45:01.280
<v Speaker 1>Why?

NOTE CONF {"raw":[73]}

00:45:01.640 --> 00:45:04.130
<v Speaker 1>It filters out all the things that are smaller than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:04.130 --> 00:45:07.410
<v Speaker 1>why In one list.

NOTE CONF {"raw":[100,100,100,100]}

00:45:07.860 --> 00:45:10.530
<v Speaker 1>In another list, it filters all the things that are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:10.530 --> 00:45:15.090
<v Speaker 1>bigger than Y, and then it sorts both of those

NOTE CONF {"raw":[100,100,98,100,100,100,100,100,100,100]}

00:45:15.090 --> 00:45:20.070
<v Speaker 1>lists and then joins them together with Y in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:20.070 --> 00:45:20.700
<v Speaker 1>middle.

NOTE CONF {"raw":[100]}

00:45:20.790 --> 00:45:23.220
<v Speaker 1>Okay, so here's my unordered list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:45:23.430 --> 00:45:25.560
<v Speaker 1>Here's the stuff that's smaller than y.

NOTE CONF {"raw":[100,100,100,97,100,100,100]}

00:45:25.590 --> 00:45:27.480
<v Speaker 1>Here's the stuff that's bigger than y.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:27.510 --> 00:45:30.420
<v Speaker 1>Here's y in the middle I sort both of these.

NOTE CONF {"raw":[100,63,100,100,100,100,81,100,100,100]}

00:45:31.080 --> 00:45:32.130
<v Speaker 1>I put them together.

NOTE CONF {"raw":[100,100,100,100]}

00:45:32.130 --> 00:45:33.660
<v Speaker 1>I ended up with a sorted list.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:33.660 --> 00:45:34.290
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:45:38.430 --> 00:45:40.800
<v Speaker 1>Um, that's called quicksort.

NOTE CONF {"raw":[100,100,100,100]}

00:45:40.830 --> 00:45:42.960
<v Speaker 1>It was invented by Tony Hoare, who was one of

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:45:42.960 --> 00:45:44.790
<v Speaker 1>the people whose pictures I showed at the beginning of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:44.790 --> 00:45:47.250
<v Speaker 1>the lecture on Monday a week ago.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:47.790 --> 00:45:50.670
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[100,100]}

00:45:52.860 --> 00:45:54.180
<v Speaker 1>How fast is this?

NOTE CONF {"raw":[100,100,100,100]}

00:45:54.210 --> 00:45:56.310
<v Speaker 1>I mean, did you understand what I just explained as

NOTE CONF {"raw":[100,100,68,100,100,100,100,100,100,67]}

00:45:56.310 --> 00:45:56.760
<v Speaker 1>what it did?

NOTE CONF {"raw":[100,100,100]}

00:45:56.760 --> 00:45:59.160
<v Speaker 1>Very hand-wavy sort of explanation.

NOTE CONF {"raw":[100,100,100,100,100]}

00:45:59.370 --> 00:46:00.090
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:00.360 --> 00:46:02.640
<v Speaker 1>Um, how much time does this take?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:02.670 --> 00:46:03.030
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:03.030 --> 00:46:03.900
<v Speaker 1>If you're lucky.

NOTE CONF {"raw":[100,100,100]}

00:46:03.900 --> 00:46:06.030
<v Speaker 1>And this turns out to be the average case.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:46:07.110 --> 00:46:09.900
<v Speaker 1>This is n log n time okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:10.170 --> 00:46:13.440
<v Speaker 1>And I'll show a diagram later that explains why that's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:13.440 --> 00:46:14.190
<v Speaker 1>the case.

NOTE CONF {"raw":[100,100]}

00:46:14.820 --> 00:46:15.570
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:15.660 --> 00:46:19.440
<v Speaker 1>Um, because if you're lucky, each time you do the,

NOTE CONF {"raw":[73,100,100,100,100,100,100,100,100,100]}

00:46:19.440 --> 00:46:23.400
<v Speaker 1>um, this breaking down the list into two sublists, you're,

NOTE CONF {"raw":[62,100,100,100,100,100,100,100,100,87]}

00:46:23.400 --> 00:46:26.880
<v Speaker 1>you're roughly, uh, you're ending up with two lists, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:26.880 --> 00:46:29.730
<v Speaker 1>are roughly half the length of the original list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:46:30.030 --> 00:46:30.540
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:30.540 --> 00:46:33.300
<v Speaker 1>And then on the next, on the next time you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:33.300 --> 00:46:34.920
<v Speaker 1>apply Q sort, it's going to be a quarter of

NOTE CONF {"raw":[100,65,78,100,100,100,100,100,100,100]}

00:46:34.920 --> 00:46:38.070
<v Speaker 1>the, the length of the original list and so forth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:38.100 --> 00:46:38.820
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:38.820 --> 00:46:41.610
<v Speaker 1>So you're having the length of the sublists each time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,76,100,100]}

00:46:42.000 --> 00:46:44.700
<v Speaker 1>Um, the worst case is a is a list which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:44.700 --> 00:46:47.280
<v Speaker 1>is already sorted, in which case it's quadratic.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:46:49.290 --> 00:46:50.070
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:51.090 --> 00:46:54.150
<v Speaker 1>So this is, uh, this is sometimes very good and

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:46:54.150 --> 00:46:55.380
<v Speaker 1>sometimes not so great.

NOTE CONF {"raw":[100,100,100,100]}

00:46:55.380 --> 00:46:57.720
<v Speaker 1>Not sometimes just as bad as insertion sort.

NOTE CONF {"raw":[89,100,100,100,100,100,100,100]}

00:46:57.840 --> 00:46:59.760
<v Speaker 1>Well, let me explain the first line.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:00.240 --> 00:47:03.270
<v Speaker 1>Um, it turns out that insertion sort is faster than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:03.300 --> 00:47:05.310
<v Speaker 1>quicksort for a very small lists.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:05.940 --> 00:47:08.610
<v Speaker 1>And so I can add.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:09.210 --> 00:47:13.680
<v Speaker 1>I can add something here which says um before doing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:13.680 --> 00:47:16.140
<v Speaker 1>quicksort, look and see how long my list is.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:47:16.140 --> 00:47:19.020
<v Speaker 1>If it's if it's less than a threshold, just do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:19.020 --> 00:47:19.950
<v Speaker 1>insertion sort.

NOTE CONF {"raw":[100,100]}

00:47:20.790 --> 00:47:23.730
<v Speaker 1>Otherwise do quicksort.

NOTE CONF {"raw":[100,100,100]}

00:47:24.030 --> 00:47:25.500
<v Speaker 1>And of course this is recursive.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:25.500 --> 00:47:28.770
<v Speaker 1>So it means once the list gets small enough I

NOTE CONF {"raw":[100,100,100,100,100,66,80,100,100,100]}

00:47:28.770 --> 00:47:31.200
<v Speaker 1>will be using insertion sort on all of these sub

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,78]}

00:47:31.200 --> 00:47:31.860
<v Speaker 1>lists.

NOTE CONF {"raw":[78]}

00:47:31.860 --> 00:47:33.450
<v Speaker 1>That's the small sub lists.

NOTE CONF {"raw":[100,79,100,65,65]}

00:47:35.910 --> 00:47:36.570
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:47:36.840 --> 00:47:37.920
<v Speaker 1>Third method.

NOTE CONF {"raw":[100,100]}

00:47:38.790 --> 00:47:39.990
<v Speaker 1>It's called merge sort.

NOTE CONF {"raw":[82,100,100,100]}

00:47:40.710 --> 00:47:45.120
<v Speaker 1>It always breaks the problem into two lists which are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:45.420 --> 00:47:47.460
<v Speaker 1>half the length of the original lists.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:48.540 --> 00:47:51.690
<v Speaker 1>Okay I'm just going to explain what this does without

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:51.690 --> 00:47:53.430
<v Speaker 1>going line by line through it.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:53.580 --> 00:47:54.090
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:47:54.090 --> 00:47:58.920
<v Speaker 1>So given given a list it just breaks the list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:58.920 --> 00:47:59.910
<v Speaker 1>into two lists.

NOTE CONF {"raw":[100,100,100]}

00:47:59.910 --> 00:48:03.250
<v Speaker 1>The the first, the first half and the second half.

NOTE CONF {"raw":[100,98,100,100,100,100,100,100,100,100]}

00:48:04.870 --> 00:48:05.200
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:05.200 --> 00:48:08.770
<v Speaker 1>That's what that's what is happening here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:48:09.580 --> 00:48:14.230
<v Speaker 1>And here, where M is, uh, M is half the

NOTE CONF {"raw":[100,100,100,100,100,64,100,100,100,100]}

00:48:14.230 --> 00:48:15.310
<v Speaker 1>length of the list.

NOTE CONF {"raw":[100,100,100,100]}

00:48:16.480 --> 00:48:17.170
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:17.170 --> 00:48:18.610
<v Speaker 1>So it takes those.

NOTE CONF {"raw":[100,100,100,100]}

00:48:18.880 --> 00:48:20.230
<v Speaker 1>It sorts them.

NOTE CONF {"raw":[100,100,100]}

00:48:21.010 --> 00:48:24.490
<v Speaker 1>So then you have two lists which are sorted and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:24.490 --> 00:48:28.270
<v Speaker 1>then it merges them, which is what this code does.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:28.270 --> 00:48:29.410
<v Speaker 1>What is merge?

NOTE CONF {"raw":[100,100,100]}

00:48:29.620 --> 00:48:32.770
<v Speaker 1>Merge is a is a function which takes two sorted

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:32.770 --> 00:48:36.640
<v Speaker 1>lists and produces a sorted list as its result.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:48:36.640 --> 00:48:40.750
<v Speaker 1>And it's kind of like imagine shuffling, um, you know,

NOTE CONF {"raw":[100,98,100,100,100,100,100,51,100,100]}

00:48:40.750 --> 00:48:43.150
<v Speaker 1>you shuffle a deck of cards, you split into half,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:43.150 --> 00:48:45.160
<v Speaker 1>and then you and then you interleave them.

NOTE CONF {"raw":[100,100,100,100,100,97,100,100]}

00:48:45.160 --> 00:48:45.550
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:45.550 --> 00:48:47.710
<v Speaker 1>But it's a sort of it's a sort of interleaving

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:47.710 --> 00:48:52.720
<v Speaker 1>thing which looks to see where each element should go.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:52.720 --> 00:48:56.320
<v Speaker 1>But you're only ever comparing the lists.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:48:56.710 --> 00:48:58.600
<v Speaker 1>You're only ever having to look at the first thing

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:48:58.600 --> 00:48:59.680
<v Speaker 1>on the list and so forth.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:48:59.680 --> 00:49:03.070
<v Speaker 1>It's, uh, it ends up being linear.

NOTE CONF {"raw":[100,100,100,100,100,100,95]}

00:49:03.100 --> 00:49:04.150
<v Speaker 1>Linear time.

NOTE CONF {"raw":[100,100]}

00:49:04.150 --> 00:49:06.280
<v Speaker 1>You don't have to compare every value with every other

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:06.280 --> 00:49:06.520
<v Speaker 1>value.

NOTE CONF {"raw":[100]}

00:49:06.520 --> 00:49:08.980
<v Speaker 1>You only have to compare the values at the beginning.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:08.980 --> 00:49:11.800
<v Speaker 1>So you're sort of you're sort of, um, doing something

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:49:11.800 --> 00:49:12.550
<v Speaker 1>like that.

NOTE CONF {"raw":[100,100]}

00:49:12.550 --> 00:49:16.390
<v Speaker 1>But at each point you decide whether, okay, here's my,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:16.390 --> 00:49:17.770
<v Speaker 1>here's my two lists.

NOTE CONF {"raw":[100,100,100,100]}

00:49:18.880 --> 00:49:21.760
<v Speaker 1>Uh, they're going to go sort of together like that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:21.760 --> 00:49:25.330
<v Speaker 1>But at each point you're comparing to see whether, whether

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:25.330 --> 00:49:29.590
<v Speaker 1>this should go here or here or maybe here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:49:30.040 --> 00:49:30.820
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:49:30.970 --> 00:49:34.450
<v Speaker 1>You never have to compare this value with some value

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:34.450 --> 00:49:35.200
<v Speaker 1>down here.

NOTE CONF {"raw":[100,100]}

00:49:35.440 --> 00:49:35.860
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:49:35.860 --> 00:49:37.210
<v Speaker 1>So this is linear.

NOTE CONF {"raw":[100,100,100,100]}

00:49:38.620 --> 00:49:41.170
<v Speaker 1>And this ends up being always n log n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:49:41.170 --> 00:49:44.890
<v Speaker 1>Again I've got a um a kind of, uh, threshold

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,95,100]}

00:49:44.890 --> 00:49:48.310
<v Speaker 1>thing at the beginning here, uh, to use insertion sort

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:48.310 --> 00:49:49.600
<v Speaker 1>if it's very short.

NOTE CONF {"raw":[100,100,100,100]}

00:49:49.600 --> 00:49:55.510
<v Speaker 1>And um, and here is the picture I promised y

NOTE CONF {"raw":[100,100,100,69,69,100,100,100,100,62]}

00:49:55.870 --> 00:49:57.610
<v Speaker 1>y these are n log n.

NOTE CONF {"raw":[60,100,99,100,100,100]}

00:49:57.760 --> 00:49:58.360
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:49:58.360 --> 00:50:00.380
<v Speaker 1>You're breaking things into Into.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:00.380 --> 00:50:01.400
<v Speaker 1>Sublists.

NOTE CONF {"raw":[100]}

00:50:01.880 --> 00:50:02.660
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:50:02.660 --> 00:50:06.290
<v Speaker 1>Original list length n two sublists of length and over

NOTE CONF {"raw":[100,100,100,100,100,72,100,100,96,100]}

00:50:06.290 --> 00:50:06.860
<v Speaker 1>two.

NOTE CONF {"raw":[100]}

00:50:06.890 --> 00:50:09.320
<v Speaker 1>Breaking down into four sub lists of length n over

NOTE CONF {"raw":[100,100,80,100,95,95,100,100,100,100]}

00:50:09.320 --> 00:50:09.980
<v Speaker 1>four.

NOTE CONF {"raw":[100]}

00:50:10.010 --> 00:50:14.600
<v Speaker 1>Okay, eventually into lists which are, um, small enough that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:14.600 --> 00:50:16.220
<v Speaker 1>you can use insertion sort on them.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:16.370 --> 00:50:17.060
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:50:17.060 --> 00:50:22.280
<v Speaker 1>The height of this is log n okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:50:22.280 --> 00:50:25.850
<v Speaker 1>And the and the time okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:50:25.850 --> 00:50:26.900
<v Speaker 1>You've got n elements.

NOTE CONF {"raw":[100,100,100,100]}

00:50:26.900 --> 00:50:29.090
<v Speaker 1>So it's n log n basically that's the that's the

NOTE CONF {"raw":[100,100,100,100,100,100,78,78,95,100]}

00:50:29.090 --> 00:50:31.370
<v Speaker 1>explanation kind of hand-wavy explanation.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:31.370 --> 00:50:34.100
<v Speaker 1>And that's what merge sort is always like that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:50:34.100 --> 00:50:35.720
<v Speaker 1>And quicksort is like that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:35.720 --> 00:50:40.040
<v Speaker 1>If um, if you end up, uh, you know, in,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:40.040 --> 00:50:44.510
<v Speaker 1>in um, in the average case, right.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:44.780 --> 00:50:47.180
<v Speaker 1>I've managed to finish on time.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:50:47.180 --> 00:50:48.470
<v Speaker 1>Thank you for your attention.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:48.470 --> 00:50:50.120
<v Speaker 1>Sorry this was so fast.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:50.480 --> 00:50:52.370
<v Speaker 1>Uh, I hope it was interesting.

NOTE CONF {"raw":[83,69,100,100,100,100]}

00:50:52.880 --> 00:50:53.060
<v Speaker 1>Mm.

NOTE CONF {"raw":[71]}

00:50:57.830 --> 00:50:58.010
<v Speaker 1>Mm.

NOTE CONF {"raw":[57]}

00:51:00.170 --> 00:51:03.020
<v Speaker 1>Don't forget to come on Friday to the guest lecture.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:03.020 --> 00:51:04.070
<v Speaker 1>It's going to be fun.

NOTE CONF {"raw":[100,100,100,100,100]}

00:51:20.240 --> 00:51:21.260
<v Speaker 4>Hi, I'm still.

NOTE CONF {"raw":[90,76,61]}

00:51:21.260 --> 00:51:25.400
<v Speaker 5>Going to write a function called remove Prop, which you

NOTE CONF {"raw":[90,100,100,100,100,100,100,69,100,100]}

00:51:25.400 --> 00:51:26.900
<v Speaker 5>had asked him to ask us to do it.

NOTE CONF {"raw":[90,98,95,100,100,68,100,100,100]}

00:51:27.500 --> 00:51:29.540
<v Speaker 5>The function remove prop for the last tutorial.

NOTE CONF {"raw":[100,100,58,100,100,100,100,100]}

00:51:29.690 --> 00:51:31.520
<v Speaker 1>Remove or maybe.

NOTE CONF {"raw":[100,100,98]}

00:51:32.090 --> 00:51:32.600
<v Speaker 1>Okay okay.

NOTE CONF {"raw":[86,100]}

00:51:32.600 --> 00:51:34.910
<v Speaker 1>Yeah it was, it was, it was replacing or with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:34.910 --> 00:51:35.480
<v Speaker 1>something else.

NOTE CONF {"raw":[100,100]}

00:51:35.480 --> 00:51:35.960
<v Speaker 1>Yeah yeah.

NOTE CONF {"raw":[98,100]}

00:51:35.960 --> 00:51:36.230
<v Speaker 4>Yeah.

NOTE CONF {"raw":[100]}

00:51:36.710 --> 00:51:39.860
<v Speaker 1>Yeah with with and and negation.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:51:39.860 --> 00:51:41.000
<v Speaker 1>Yes yes yes okay.

NOTE CONF {"raw":[100,100,100,100]}

00:51:41.150 --> 00:51:41.630
<v Speaker 4>I have.

NOTE CONF {"raw":[100,100]}

00:51:41.630 --> 00:51:42.380
<v Speaker 5>Done that.

NOTE CONF {"raw":[100,100]}

00:51:42.380 --> 00:51:43.340
<v Speaker 5>I need to ask you.

NOTE CONF {"raw":[100,90,100,100,100]}

00:51:43.820 --> 00:51:44.420
<v Speaker 4>This is correct.

NOTE CONF {"raw":[100,100,100]}

00:51:54.110 --> 00:51:54.860
<v Speaker 1>No.

NOTE CONF {"raw":[100]}

00:51:55.100 --> 00:51:57.080
<v Speaker 1>Um, this is only, um sorry.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:51:57.080 --> 00:51:57.530
<v Speaker 4>Let me let.

NOTE CONF {"raw":[100,100,100]}

00:51:57.530 --> 00:51:57.930
<v Speaker 1>Me turn.

NOTE CONF {"raw":[100,100]}

00:51:57.930 --> 00:51:58.530
<v Speaker 4>This off.

NOTE CONF {"raw":[100,100]}

00:52:00.030 --> 00:52:02.250
<v Speaker 1>This is this is turning it into a string.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:52:02.250 --> 00:52:02.520
<v Speaker 1>Okay?

NOTE CONF {"raw":[100]}

00:52:02.520 --> 00:52:03.150
<v Speaker 1>It wasn't.

NOTE CONF {"raw":[82,99]}

00:52:23.430 --> 00:52:23.700
<v Speaker 4>No.

NOTE CONF {"raw":[89]}

00:52:29.910 --> 00:52:30.360
<v Speaker 4>Strings.

NOTE CONF {"raw":[82]}

00:52:36.300 --> 00:52:37.050
<v Speaker 1>Yes.

NOTE CONF {"raw":[100]}

00:52:37.050 --> 00:52:38.040
<v Speaker 1>And not just this one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:52:43.860 --> 00:52:45.450
<v Speaker 4>Similar to this one.

NOTE CONF {"raw":[100,100,97,97]}

00:52:45.660 --> 00:52:46.230
<v Speaker 4>Strings.

NOTE CONF {"raw":[38]}

00:52:50.940 --> 00:52:51.270
<v Speaker 4>The first.

NOTE CONF {"raw":[73,64]}

00:52:54.240 --> 00:52:54.630
<v Speaker 4>String.

NOTE CONF {"raw":[82]}

00:52:55.890 --> 00:52:56.070
<v Speaker 4>Can.

NOTE CONF {"raw":[34]}

00:52:59.850 --> 00:53:00.780
<v Speaker 4>I ask you.

NOTE CONF {"raw":[98,72,31]}

00:53:00.930 --> 00:53:05.160
<v Speaker 4>I didn't ask you to do this because it's good

NOTE CONF {"raw":[100,99,99,93,100,100,100,71,100,100]}

00:53:05.160 --> 00:53:07.380
<v Speaker 4>practice for this week's exercise.

NOTE CONF {"raw":[100,100,100,100,71]}

00:53:07.500 --> 00:53:09.060
<v Speaker 4>You've already done so.

NOTE CONF {"raw":[100,100,100,99]}

00:53:10.800 --> 00:53:11.760
<v Speaker 4>Okay, so we have.

NOTE CONF {"raw":[100,100,78,78]}

00:53:13.560 --> 00:53:14.820
<v Speaker 4>Uh, well, that's what this is.

NOTE CONF {"raw":[78,100,100,100,100,100]}

00:53:14.820 --> 00:53:15.570
<v Speaker 4>That's the idea.

NOTE CONF {"raw":[100,100,100]}

00:53:15.930 --> 00:53:16.200
<v Speaker 4>Okay.

NOTE CONF {"raw":[100]}

00:53:16.380 --> 00:53:16.830
<v Speaker 4>Okay.

NOTE CONF {"raw":[100]}

00:53:18.720 --> 00:53:18.960
<v Speaker 4>Yeah.

NOTE CONF {"raw":[33]}

00:53:19.320 --> 00:53:19.680
<v Speaker 4>Okay.

NOTE CONF {"raw":[100]}

00:53:20.400 --> 00:53:20.550
<v Speaker 4>Yeah.

NOTE CONF {"raw":[100]}

00:53:20.550 --> 00:53:24.270
<v Speaker 4>It was just the wrong thing that you're thinking about.

NOTE CONF {"raw":[92,100,100,100,100,100,100,95,48,38]}

00:53:25.110 --> 00:53:25.650
<v Speaker 4>So I just.

NOTE CONF {"raw":[99,98,99]}

00:53:26.850 --> 00:53:29.970
<v Speaker 4>I need to use this.

NOTE CONF {"raw":[66,26,28,15,18]}

00:53:32.160 --> 00:53:32.730
<v Unknown>Uh, yes.

NOTE CONF {"raw":[95,100]}

00:53:32.730 --> 00:53:33.930
<v Unknown>Because you got some of that.

NOTE CONF {"raw":[66,71,91,48,30,28]}

00:53:35.850 --> 00:53:36.570
<v Speaker 4>Yes.

NOTE CONF {"raw":[100]}

00:53:36.750 --> 00:53:40.740
<v Speaker 4>Is it good for you?

NOTE CONF {"raw":[98,95,100,100,97]}

00:53:41.340 --> 00:53:41.760
<v Speaker 4>Uh.

NOTE CONF {"raw":[81]}

00:53:46.680 --> 00:53:46.920
<v Unknown>Yeah.

NOTE CONF {"raw":[87]}

00:53:47.100 --> 00:53:50.580
<v Unknown>You took us back.

NOTE CONF {"raw":[94,8,47,23]}

00:53:51.180 --> 00:53:51.420
<v Unknown>Yeah.

NOTE CONF {"raw":[100]}

00:53:51.570 --> 00:53:52.800
<v Unknown>And then as you go down the hall.

NOTE CONF {"raw":[93,95,95,95,95,92,91,58]}

00:53:57.820 --> 00:54:01.120
<v Unknown>And so all of those other problems wouldn't be solved.

NOTE CONF {"raw":[88,86,100,100,100,100,100,100,100,100]}

00:54:02.200 --> 00:54:03.040
<v Unknown>But you do it.

NOTE CONF {"raw":[93,100,100,100]}

00:54:03.190 --> 00:54:04.390
<v Unknown>You do those things.

NOTE CONF {"raw":[100,100,100,100]}

00:54:04.420 --> 00:54:05.860
<v Unknown>It's one of those again.

NOTE CONF {"raw":[100,100,100,100,56]}

00:54:05.860 --> 00:54:08.740
<v Unknown>But you only lost one of us.

NOTE CONF {"raw":[98,97,94,35,39,37,42]}

00:54:09.610 --> 00:54:12.340
<v Unknown>There's a lot of confusion.

NOTE CONF {"raw":[60,60,58,58,41]}

00:54:17.020 --> 00:54:20.170
<v Unknown>And I think that's okay.

NOTE CONF {"raw":[66,100,100,100,70]}

00:54:20.470 --> 00:54:21.010
<v Unknown>Forgive me.

NOTE CONF {"raw":[19,19]}

00:54:21.460 --> 00:54:21.700
<v Unknown>Thank you.

NOTE CONF {"raw":[88,88]}

00:54:22.720 --> 00:54:23.260
<v Speaker 4>I'm just.

NOTE CONF {"raw":[86,83]}

00:54:27.310 --> 00:54:27.610
<v Speaker 4>Glad.

NOTE CONF {"raw":[86]}

00:54:33.250 --> 00:54:34.060
<v Speaker 4>I did it.

NOTE CONF {"raw":[66,66,81]}

00:54:36.310 --> 00:54:37.450
<v Unknown>Um.

NOTE CONF {"raw":[97]}

00:54:39.250 --> 00:54:40.840
<v Unknown>Not that I know of.

NOTE CONF {"raw":[100,100,100,100,100]}

00:54:41.050 --> 00:54:43.810
<v Unknown>Um, I'm not sure.

NOTE CONF {"raw":[100,100,100,100]}

00:54:43.810 --> 00:54:46.270
<v Unknown>I mean, the, uh, the hospital.

NOTE CONF {"raw":[100,100,54,67,100,100]}

00:54:46.420 --> 00:54:46.780
<v Unknown>I don't.

NOTE CONF {"raw":[55,33]}

00:54:51.280 --> 00:54:53.110
<v Unknown>I'm not aware of that as well.

NOTE CONF {"raw":[100,100,100,90,100,50,50]}

00:54:53.650 --> 00:54:54.040
<v Unknown>Um, yeah.

NOTE CONF {"raw":[100,100]}
