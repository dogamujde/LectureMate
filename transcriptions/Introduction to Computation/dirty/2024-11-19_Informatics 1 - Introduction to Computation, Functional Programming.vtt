WEBVTT

00:01:38.940 --> 00:01:39.390
<v Speaker 0>Oh.

NOTE CONF {"raw":[89]}

00:01:56.220 --> 00:01:57.090
<v Speaker 0>Do you want me to speak now?

NOTE CONF {"raw":[77,77,77,77,77,77,71]}

00:01:58.630 --> 00:01:58.840
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:01:58.840 --> 00:01:59.200
<v Speaker 0>Go ahead.

NOTE CONF {"raw":[100,100]}

00:02:05.170 --> 00:02:05.530
<v Speaker 0>All right.

NOTE CONF {"raw":[100,100]}

00:02:06.280 --> 00:02:06.610
<v Speaker 0>Yeah.

NOTE CONF {"raw":[100]}

00:02:13.780 --> 00:02:14.770
<v Speaker 1>Hi, everyone.

NOTE CONF {"raw":[100,100]}

00:02:14.830 --> 00:02:16.180
<v Speaker 1>Um, sorry to interrupt.

NOTE CONF {"raw":[100,100,100,100]}

00:02:16.180 --> 00:02:17.590
<v Speaker 1>I just want to take a quick minute of your

NOTE CONF {"raw":[91,100,100,100,100,100,100,100,100,100]}

00:02:17.590 --> 00:02:20.080
<v Speaker 1>time to tell you about a really exciting opportunity that

NOTE CONF {"raw":[100,100,100,100,100,94,100,100,100,100]}

00:02:20.080 --> 00:02:22.180
<v Speaker 1>we have, which is to climb Kilimanjaro.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:22.210 --> 00:02:24.040
<v Speaker 1>We're putting together a huge team from Edinburgh.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:02:24.040 --> 00:02:25.630
<v Speaker 1>We've actually got quite a lot of people on board

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:25.630 --> 00:02:28.360
<v Speaker 1>already, but it will be great to have even more.

NOTE CONF {"raw":[100,97,90,64,100,100,100,100,100,100]}

00:02:28.600 --> 00:02:30.310
<v Speaker 1>Um, I took part in this challenge last year and

NOTE CONF {"raw":[87,100,100,100,100,100,100,100,100,100]}

00:02:30.310 --> 00:02:31.660
<v Speaker 1>it was actually the best thing I've ever done.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:31.660 --> 00:02:33.190
<v Speaker 1>I could not recommend it any more.

NOTE CONF {"raw":[100,100,100,100,100,52,52]}

00:02:33.670 --> 00:02:34.930
<v Speaker 1>Um, but it's a charity challenge.

NOTE CONF {"raw":[80,100,100,98,100,100]}

00:02:34.930 --> 00:02:36.880
<v Speaker 1>So you fundraise in order to come on the climb.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:36.880 --> 00:02:39.100
<v Speaker 1>Half the half of the money you raise covers your

NOTE CONF {"raw":[99,66,100,100,100,100,100,100,100,100]}

00:02:39.100 --> 00:02:41.050
<v Speaker 1>climb costs, and half of the money goes towards Dig

NOTE CONF {"raw":[100,100,100,100,57,100,100,100,100,100]}

00:02:41.050 --> 00:02:41.380
<v Speaker 1>Deep.

NOTE CONF {"raw":[100]}

00:02:41.590 --> 00:02:43.870
<v Speaker 1>Dig deep are a small charity based in the south

NOTE CONF {"raw":[100,100,85,86,100,100,100,100,100,86]}

00:02:43.870 --> 00:02:44.740
<v Speaker 1>west of Kenya.

NOTE CONF {"raw":[86,100,100]}

00:02:44.770 --> 00:02:47.560
<v Speaker 1>They help to provide clean water, safe toilets and hygiene

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:02:47.560 --> 00:02:48.430
<v Speaker 1>education.

NOTE CONF {"raw":[100]}

00:02:48.430 --> 00:02:49.900
<v Speaker 1>And in that area of the world, two out of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:49.900 --> 00:02:52.060
<v Speaker 1>three people don't currently have access to clean water.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:52.060 --> 00:02:53.740
<v Speaker 1>So really, really important cause.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:53.740 --> 00:02:56.590
<v Speaker 1>But even more exciting opportunity for you on the climb

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:56.590 --> 00:02:57.010
<v Speaker 1>itself.

NOTE CONF {"raw":[100]}

00:02:57.010 --> 00:02:59.470
<v Speaker 1>You go through four different ecosystems on your way to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:59.470 --> 00:03:02.050
<v Speaker 1>the snow capped summit, which is also the tallest freestanding

NOTE CONF {"raw":[100,72,50,100,100,100,100,100,100,98]}

00:03:02.050 --> 00:03:03.160
<v Speaker 1>mountain in the world.

NOTE CONF {"raw":[100,100,100,100]}

00:03:03.370 --> 00:03:05.620
<v Speaker 1>And then after the climb, you have the opportunity to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:05.620 --> 00:03:08.350
<v Speaker 1>see a bit more of Tanzania by going on safari.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:08.350 --> 00:03:10.720
<v Speaker 1>Or you can go to Zanzibar to just relax after

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:10.720 --> 00:03:11.770
<v Speaker 1>all of your hard work.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:11.860 --> 00:03:13.750
<v Speaker 1>If you would like to find out any more information,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:13.750 --> 00:03:15.490
<v Speaker 1>you can scan the QR code on the screen behind

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,100]}

00:03:15.490 --> 00:03:15.820
<v Speaker 1>me.

NOTE CONF {"raw":[100]}

00:03:16.090 --> 00:03:19.420
<v Speaker 1>And we're also hosting an information session tonight in 50

NOTE CONF {"raw":[78,99,100,100,100,100,100,100,100,100]}

00:03:19.420 --> 00:03:20.920
<v Speaker 1>George Square Room Geo two.

NOTE CONF {"raw":[71,100,99,39,58]}

00:03:20.950 --> 00:03:22.210
<v Speaker 1>It's going to be at 6 p.m..

NOTE CONF {"raw":[93,100,100,100,100,85,85]}

00:03:22.210 --> 00:03:24.220
<v Speaker 1>We're going through all the details about the climb, the

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:03:24.220 --> 00:03:26.830
<v Speaker 1>charity, the fundraising and how we can support you with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:26.830 --> 00:03:28.060
<v Speaker 1>your fundraising as well.

NOTE CONF {"raw":[100,100,100,100]}

00:03:28.360 --> 00:03:30.820
<v Speaker 1>You also get a Â£100 discount by attending the session.

NOTE CONF {"raw":[100,100,100,100,62,100,100,100,100,100]}

00:03:30.820 --> 00:03:32.470
<v Speaker 1>So if it is something you're interested in or you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:32.470 --> 00:03:34.630
<v Speaker 1>know anyone who might be, please do come along at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:34.630 --> 00:03:37.810
<v Speaker 1>6 p.m. to go to in 50 George Square.

NOTE CONF {"raw":[98,98,100,97,97,100,100,100,100]}

00:03:37.960 --> 00:03:39.040
<v Speaker 1>Thanks very much.

NOTE CONF {"raw":[100,100,100]}

00:03:42.040 --> 00:03:42.310
<v Speaker 0>Thank you.

NOTE CONF {"raw":[100,100]}

00:03:42.400 --> 00:03:42.850
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:03:43.750 --> 00:03:44.410
<v Speaker 2>Right.

NOTE CONF {"raw":[80]}

00:03:46.120 --> 00:03:48.310
<v Speaker 2>Let's get this organised.

NOTE CONF {"raw":[100,100,100,84]}

00:03:58.510 --> 00:03:59.440
<v Speaker 2>Ah, yesterday.

NOTE CONF {"raw":[100,100]}

00:03:59.440 --> 00:04:00.790
<v Speaker 2>It didn't work on both screens.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:04:00.790 --> 00:04:01.540
<v Speaker 2>Today it does.

NOTE CONF {"raw":[100,100,100]}

00:04:01.540 --> 00:04:02.560
<v Speaker 2>She fixed something.

NOTE CONF {"raw":[100,100,100]}

00:04:02.560 --> 00:04:03.130
<v Speaker 2>Yay!

NOTE CONF {"raw":[74]}

00:04:04.960 --> 00:04:06.130
<v Speaker 2>Oh, okay.

NOTE CONF {"raw":[100,100]}

00:04:06.280 --> 00:04:09.070
<v Speaker 2>Good afternoon, I'm Phillip Wadler.

NOTE CONF {"raw":[100,100,100,78,100]}

00:04:09.070 --> 00:04:11.890
<v Speaker 2>I'm lecturing in place of dawn this week.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:12.550 --> 00:04:13.780
<v Speaker 2>Uh, it's great to be back here.

NOTE CONF {"raw":[70,100,100,100,100,100,97]}

00:04:13.780 --> 00:04:17.019
<v Speaker 2>I used to, uh, I created this course, actually, so

NOTE CONF {"raw":[100,100,100,63,100,100,100,100,100,100]}

00:04:17.019 --> 00:04:19.900
<v Speaker 2>it's great to be able to teach it again.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:04:22.030 --> 00:04:26.740
<v Speaker 2>So before I start, some of you were here yesterday

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100,100]}

00:04:26.740 --> 00:04:29.230
<v Speaker 2>and heard me explain how important questions are.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:29.710 --> 00:04:31.480
<v Speaker 2>Are there any questions?

NOTE CONF {"raw":[100,100,100,100]}

00:04:36.820 --> 00:04:38.740
<v Speaker 2>And just so I can check, it looks like there

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:38.740 --> 00:04:39.940
<v Speaker 2>are more people here today.

NOTE CONF {"raw":[97,100,100,100,100]}

00:04:39.940 --> 00:04:44.470
<v Speaker 2>How many people saw in yesterday's lecture and how many

NOTE CONF {"raw":[100,100,100,100,58,100,100,100,100,100]}

00:04:44.470 --> 00:04:46.960
<v Speaker 2>people didn't see yesterday's lecture?

NOTE CONF {"raw":[100,100,100,100,100]}

00:04:48.010 --> 00:04:49.660
<v Speaker 2>Okay, just a few of you.

NOTE CONF {"raw":[100,100,100,100,97,97]}

00:04:49.660 --> 00:04:52.810
<v Speaker 2>So if you didn't see it, you'll be a little

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:52.810 --> 00:04:53.560
<v Speaker 2>bit confused.

NOTE CONF {"raw":[100,100]}

00:04:53.560 --> 00:04:56.090
<v Speaker 2>And then you'll go, oh well, I can't ask a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:56.090 --> 00:04:58.190
<v Speaker 2>question because I'm a little bit confused and I didn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:04:58.190 --> 00:04:58.940
<v Speaker 2>see it yesterday.

NOTE CONF {"raw":[100,100,100]}

00:04:58.970 --> 00:05:01.100
<v Speaker 2>Just go ahead and ask questions, okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:05.630 --> 00:05:06.470
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:05:06.920 --> 00:05:09.200
<v Speaker 2>So we're talking about monads.

NOTE CONF {"raw":[100,100,100,100,100]}

00:05:09.200 --> 00:05:12.050
<v Speaker 2>And yesterday we were talking about IO and monads.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:12.050 --> 00:05:14.360
<v Speaker 2>So IO stands for input output.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:05:14.360 --> 00:05:17.990
<v Speaker 2>And we learned how a monad lets you describe.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:22.280 --> 00:05:22.640
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:05:22.640 --> 00:05:24.950
<v Speaker 2>So put char you give it a character and it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:24.950 --> 00:05:29.780
<v Speaker 2>returns a command something that's written io of unit type.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:30.800 --> 00:05:34.310
<v Speaker 2>So right open closed parenthesis drunk.

NOTE CONF {"raw":[100,94,100,99,100,72]}

00:05:34.910 --> 00:05:36.230
<v Speaker 2>It's just the unit type.

NOTE CONF {"raw":[97,100,100,100,100]}

00:05:36.230 --> 00:05:38.570
<v Speaker 2>In Haskell it has only one value which is also

NOTE CONF {"raw":[86,100,85,100,100,100,100,100,100,100]}

00:05:38.570 --> 00:05:40.670
<v Speaker 2>written open close parenthesis.

NOTE CONF {"raw":[100,100,100,82]}

00:05:41.210 --> 00:05:45.110
<v Speaker 2>So it's quite useful to have sort of um uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,86]}

00:05:45.110 --> 00:05:48.410
<v Speaker 2>trivial types like that in particular here instead of having

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:05:48.410 --> 00:05:51.770
<v Speaker 2>to make up a separate command, IO in general returns

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,100,100]}

00:05:51.770 --> 00:05:54.290
<v Speaker 2>a value the way we you can say we're not

NOTE CONF {"raw":[100,100,100,100,60,100,100,100,100,100]}

00:05:54.290 --> 00:05:56.840
<v Speaker 2>interested in the value we returned by saying is it's

NOTE CONF {"raw":[100,100,100,100,100,93,100,100,96,100]}

00:05:56.840 --> 00:05:58.130
<v Speaker 2>always of this type.

NOTE CONF {"raw":[100,100,100,100]}

00:05:58.130 --> 00:05:59.810
<v Speaker 2>This type only has one value.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:05:59.810 --> 00:06:00.890
<v Speaker 2>Nothing to see here.

NOTE CONF {"raw":[100,100,100,100]}

00:06:00.890 --> 00:06:02.480
<v Speaker 2>No interesting information.

NOTE CONF {"raw":[100,100,100]}

00:06:04.010 --> 00:06:06.830
<v Speaker 2>By the way, does anybody know what this unit type,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:06.830 --> 00:06:09.650
<v Speaker 2>the type of no interesting information is called in the

NOTE CONF {"raw":[100,100,100,97,100,100,100,100,100,98]}

00:06:09.680 --> 00:06:11.600
<v Speaker 2>C programming language.

NOTE CONF {"raw":[100,100,100]}

00:06:14.300 --> 00:06:15.920
<v Speaker 2>Has anybody programmed in C?

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:17.480 --> 00:06:18.320
<v Speaker 2>Yes, some of you.

NOTE CONF {"raw":[79,100,100,100]}

00:06:19.190 --> 00:06:20.360
<v Speaker 2>I was afraid of that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:20.360 --> 00:06:20.570
<v Speaker 2>Yes.

NOTE CONF {"raw":[100]}

00:06:20.570 --> 00:06:22.400
<v Speaker 2>Some of you have been exposed to C.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:06:23.210 --> 00:06:26.120
<v Speaker 2>And what is the unit type called in C when

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:26.120 --> 00:06:28.760
<v Speaker 2>you have a procedure that returns nothing of interest, what's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:28.760 --> 00:06:29.510
<v Speaker 2>its type.

NOTE CONF {"raw":[90,100]}

00:06:29.510 --> 00:06:30.440
<v Speaker 2>Void.

NOTE CONF {"raw":[100]}

00:06:30.920 --> 00:06:31.460
<v Speaker 2>Right.

NOTE CONF {"raw":[95]}

00:06:31.460 --> 00:06:35.840
<v Speaker 2>Except void sounds like empty whereas unit sounds like one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:35.840 --> 00:06:38.120
<v Speaker 2>In fact, this is the type with one value in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:38.120 --> 00:06:38.270
<v Speaker 2>it.

NOTE CONF {"raw":[100]}

00:06:38.270 --> 00:06:39.620
<v Speaker 2>It's the unit type.

NOTE CONF {"raw":[94,100,100,100]}

00:06:40.850 --> 00:06:43.820
<v Speaker 2>Um, the empty type is a different type.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:06:43.820 --> 00:06:46.130
<v Speaker 2>It has no values in it whatsoever.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:46.820 --> 00:06:49.970
<v Speaker 2>And if you go on to fourth year and take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:49.970 --> 00:06:54.470
<v Speaker 2>my class on Agda, you'll learn just how important the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:54.470 --> 00:06:57.260
<v Speaker 2>empty type is, but that's a different type.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:06:57.260 --> 00:07:01.400
<v Speaker 2>So C unfortunately makes things a bit confusing by calling

NOTE CONF {"raw":[100,90,100,100,100,100,100,100,100,100]}

00:07:01.400 --> 00:07:03.230
<v Speaker 2>the unit type the void type.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:03.410 --> 00:07:05.300
<v Speaker 2>It's not type with nothing in it, it's a type

NOTE CONF {"raw":[99,100,100,100,100,88,81,91,91,100]}

00:07:05.300 --> 00:07:08.600
<v Speaker 2>with one thing in it, but that has no interesting

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:08.600 --> 00:07:11.150
<v Speaker 2>information because it's always the same thing.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:07:14.660 --> 00:07:18.500
<v Speaker 2>Okay, so put char takes a charge and returns a

NOTE CONF {"raw":[100,100,100,100,100,95,61,100,100,100]}

00:07:18.500 --> 00:07:19.220
<v Speaker 2>command.

NOTE CONF {"raw":[100]}

00:07:19.220 --> 00:07:22.100
<v Speaker 2>So this is an IO of unit type.

NOTE CONF {"raw":[96,100,100,100,96,100,100,100]}

00:07:22.280 --> 00:07:24.620
<v Speaker 2>And if you ever did that command it would print

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:24.620 --> 00:07:25.550
<v Speaker 2>an exclamation mark.

NOTE CONF {"raw":[100,100,100]}

00:07:25.550 --> 00:07:28.640
<v Speaker 2>But the point is this is a pure value.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:07:29.060 --> 00:07:32.780
<v Speaker 2>It stands for something that could, you know, it stands

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:32.780 --> 00:07:33.260
<v Speaker 2>for.

NOTE CONF {"raw":[100]}

00:07:33.260 --> 00:07:36.380
<v Speaker 2>It's a set of instructions to follow, to do something,

NOTE CONF {"raw":[93,100,100,100,100,100,100,100,100,100]}

00:07:36.380 --> 00:07:38.420
<v Speaker 2>but it doesn't follow the instructions.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:38.420 --> 00:07:40.970
<v Speaker 2>It's just a set of instructions to follow.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:07:41.450 --> 00:07:43.730
<v Speaker 2>And then this lets you put together two sets of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:43.730 --> 00:07:47.450
<v Speaker 2>instructions to first do the, um, the first one and

NOTE CONF {"raw":[100,100,100,100,100,81,100,100,100,100]}

00:07:47.450 --> 00:07:48.770
<v Speaker 2>then do the second one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:48.770 --> 00:07:51.870
<v Speaker 2>So if I say put your question mark, put char

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,46]}

00:07:52.020 --> 00:07:55.830
<v Speaker 2>exclamation mark, then that will write out two characters.

NOTE CONF {"raw":[100,100,100,100,100,95,100,98,100]}

00:07:58.470 --> 00:08:03.030
<v Speaker 2>Done really does nothing and returns no interesting value.

NOTE CONF {"raw":[81,100,100,100,100,100,100,100,100]}

00:08:04.650 --> 00:08:06.630
<v Speaker 2>And then we could write a string.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:08:06.990 --> 00:08:07.260
<v Speaker 2>Right?

NOTE CONF {"raw":[99]}

00:08:07.260 --> 00:08:08.400
<v Speaker 2>So you take a string.

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:08.400 --> 00:08:10.500
<v Speaker 2>If it's empty, you do nothing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:08:10.500 --> 00:08:13.860
<v Speaker 2>If it's head and tail xz then first you put

NOTE CONF {"raw":[100,94,100,100,100,96,100,100,100,100]}

00:08:13.860 --> 00:08:17.670
<v Speaker 2>the character x and then recursively we apply put string

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:17.670 --> 00:08:20.070
<v Speaker 2>again to xz so it ends up printing out the

NOTE CONF {"raw":[100,100,62,100,100,100,100,100,100,100]}

00:08:20.070 --> 00:08:21.060
<v Speaker 2>whole string.

NOTE CONF {"raw":[100,100]}

00:08:21.060 --> 00:08:22.560
<v Speaker 2>So put string.

NOTE CONF {"raw":[100,100,99]}

00:08:22.890 --> 00:08:24.690
<v Speaker 2>Question mark playing is the same as.

NOTE CONF {"raw":[97,97,100,100,100,100,100]}

00:08:24.690 --> 00:08:30.090
<v Speaker 2>Put a question mark, put char exclamation mark and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:30.090 --> 00:08:31.230
<v Speaker 2>do nothing else.

NOTE CONF {"raw":[100,100,100]}

00:08:38.219 --> 00:08:40.020
<v Speaker 2>Uh, we could also think of put string as just

NOTE CONF {"raw":[63,100,91,100,100,100,100,100,86,100]}

00:08:40.020 --> 00:08:45.690
<v Speaker 2>folder with sequence and done uh, composed with map of

NOTE CONF {"raw":[98,100,100,100,100,74,100,100,100,100]}

00:08:45.690 --> 00:08:46.350
<v Speaker 2>put char.

NOTE CONF {"raw":[100,92]}

00:08:46.770 --> 00:08:48.600
<v Speaker 2>So the important thing is there are some laws that

NOTE CONF {"raw":[100,100,100,100,100,70,70,100,100,100]}

00:08:48.600 --> 00:08:53.520
<v Speaker 2>are satisfied here Um, m followed by Don is just

NOTE CONF {"raw":[100,100,100,93,98,100,100,89,100,100]}

00:08:53.520 --> 00:08:54.930
<v Speaker 2>em, right?

NOTE CONF {"raw":[100,98]}

00:08:55.020 --> 00:08:57.990
<v Speaker 2>Do em and then do nothing is just do em.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:57.990 --> 00:09:00.930
<v Speaker 2>Do nothing and then do em is just do em,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:01.050 --> 00:09:03.930
<v Speaker 2>do em and then do n, and then do o

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,94]}

00:09:03.930 --> 00:09:07.290
<v Speaker 2>is just do em and then do n and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:07.290 --> 00:09:08.220
<v Speaker 2>do oh.

NOTE CONF {"raw":[100,100]}

00:09:08.220 --> 00:09:10.950
<v Speaker 2>So you can put the parentheses either place.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:09:12.900 --> 00:09:16.770
<v Speaker 2>And does anybody remember the name for a system that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:16.770 --> 00:09:20.760
<v Speaker 2>has an operator and an identity that satisfy these three

NOTE CONF {"raw":[100,100,100,100,100,100,100,83,100,100]}

00:09:20.760 --> 00:09:21.480
<v Speaker 2>laws?

NOTE CONF {"raw":[100]}

00:09:23.220 --> 00:09:24.030
<v Speaker 2>Monoid.

NOTE CONF {"raw":[100]}

00:09:24.030 --> 00:09:24.690
<v Speaker 2>Correct.

NOTE CONF {"raw":[100]}

00:09:24.690 --> 00:09:25.290
<v Speaker 2>Sorry.

NOTE CONF {"raw":[100]}

00:09:28.590 --> 00:09:33.120
<v Speaker 2>Uh, Boolean algebras have two of these in them, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,88]}

00:09:33.120 --> 00:09:36.600
<v Speaker 2>One for conjunction and one for disjunction.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:09:37.050 --> 00:09:39.900
<v Speaker 2>But a Boolean algebra is a much more sophisticated structure.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:39.900 --> 00:09:43.320
<v Speaker 2>This is very simple, just one operator and one unit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:43.320 --> 00:09:45.360
<v Speaker 2>satisfying these three laws.

NOTE CONF {"raw":[100,100,100,100]}

00:09:45.990 --> 00:09:48.270
<v Speaker 2>And you'll have bumped into these because these are very

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:48.270 --> 00:09:51.520
<v Speaker 2>important for doing um just as here folder.

NOTE CONF {"raw":[100,100,100,100,100,100,100,94]}

00:09:51.550 --> 00:09:54.940
<v Speaker 2>We often have folder and some boolean operator.

NOTE CONF {"raw":[100,100,100,94,100,100,100,100]}

00:09:54.940 --> 00:09:57.130
<v Speaker 2>Some binary operator I'm sorry.

NOTE CONF {"raw":[100,100,100,100,100]}

00:09:57.370 --> 00:09:58.930
<v Speaker 2>And then it's unit.

NOTE CONF {"raw":[100,100,66,100]}

00:09:59.080 --> 00:10:02.410
<v Speaker 2>So that's a very common pattern which is why it's

NOTE CONF {"raw":[81,100,100,100,100,100,100,100,100,100]}

00:10:02.410 --> 00:10:04.240
<v Speaker 2>worth knowing about monoids.

NOTE CONF {"raw":[100,100,100,100]}

00:10:05.650 --> 00:10:08.200
<v Speaker 2>But the other reason it's worth knowing about monoids is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:08.200 --> 00:10:11.080
<v Speaker 2>because monad is a pun on monoid.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:14.380 --> 00:10:18.220
<v Speaker 2>So I've told you how to put together commands.

NOTE CONF {"raw":[100,100,100,100,100,100,100,79,100]}

00:10:18.220 --> 00:10:21.520
<v Speaker 2>How do you actually execute a command?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:21.880 --> 00:10:25.510
<v Speaker 2>And the answer is if we bind main.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:25.690 --> 00:10:28.810
<v Speaker 2>So main is just another function in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:28.810 --> 00:10:31.810
<v Speaker 2>But by convention main always has type command.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:31.870 --> 00:10:35.710
<v Speaker 2>And by convention when you run a program, whatever is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:35.710 --> 00:10:38.650
<v Speaker 2>bound to main, that's what you do.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:39.640 --> 00:10:42.250
<v Speaker 2>So I gave an example of this yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:42.940 --> 00:10:45.490
<v Speaker 2>Oh that's not the one I want.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:47.200 --> 00:10:48.910
<v Speaker 2>I gave an example of this yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:48.910 --> 00:10:50.950
<v Speaker 2>If we say run GHC.

NOTE CONF {"raw":[100,100,100,100,100]}

00:10:51.040 --> 00:10:52.390
<v Speaker 2>Well, let's look at the file.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:52.390 --> 00:10:53.500
<v Speaker 2>Confused first.

NOTE CONF {"raw":[100,100]}

00:10:58.870 --> 00:11:04.450
<v Speaker 2>But that just says print out an exclamation mark and

NOTE CONF {"raw":[91,100,100,100,100,100,82,100,100,100]}

00:11:04.450 --> 00:11:06.760
<v Speaker 2>a question mark and an exclamation mark.

NOTE CONF {"raw":[100,100,100,98,100,100,100]}

00:11:09.520 --> 00:11:12.940
<v Speaker 2>And then if I say, okay, run that program.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:11:19.030 --> 00:11:19.810
<v Speaker 2>That's what it does.

NOTE CONF {"raw":[100,100,100,100]}

00:11:19.810 --> 00:11:22.450
<v Speaker 2>It prints the question mark at an exclamation mark.

NOTE CONF {"raw":[100,100,69,100,100,100,100,100,100]}

00:11:22.450 --> 00:11:24.910
<v Speaker 2>Didn't even print a new line after it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:11:25.840 --> 00:11:27.970
<v Speaker 2>It just had this funny prompt.

NOTE CONF {"raw":[87,100,98,100,100,100]}

00:11:38.920 --> 00:11:42.640
<v Speaker 2>And the point is that we can then do exceptional

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,58]}

00:11:42.640 --> 00:11:47.110
<v Speaker 2>reasoning in languages with side effects like, see print!

NOTE CONF {"raw":[100,100,100,100,100,100,100,87,100]}

00:11:47.110 --> 00:11:47.380
<v Speaker 2>Ha!

NOTE CONF {"raw":[100]}

00:11:47.380 --> 00:11:47.680
<v Speaker 2>Print!

NOTE CONF {"raw":[100]}

00:11:47.680 --> 00:11:48.970
<v Speaker 2>Ha goes ha ha!

NOTE CONF {"raw":[99,98,100,100]}

00:11:49.300 --> 00:11:52.600
<v Speaker 2>But if you say let x be the value of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:52.600 --> 00:11:58.180
<v Speaker 2>print ha in x, followed by x in only, this

NOTE CONF {"raw":[100,100,100,100,100,100,100,51,100,100]}

00:11:58.720 --> 00:12:00.340
<v Speaker 2>does that as a side effect.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:00.340 --> 00:12:02.710
<v Speaker 2>This does nothing at all, so you only get one.

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,100]}

00:12:02.710 --> 00:12:03.070
<v Speaker 2>Ha!

NOTE CONF {"raw":[95]}

00:12:03.250 --> 00:12:04.900
<v Speaker 2>The laugh is on you.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:07.630 --> 00:12:08.140
<v Speaker 2>So.

NOTE CONF {"raw":[100]}

00:12:08.140 --> 00:12:11.920
<v Speaker 2>But in Haskell this does nothing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:12.130 --> 00:12:13.330
<v Speaker 2>It's just a command.

NOTE CONF {"raw":[100,100,100,100]}

00:12:13.330 --> 00:12:15.070
<v Speaker 2>It's a list of instructions.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:15.310 --> 00:12:19.120
<v Speaker 2>So saying let em be this list of instructions in

NOTE CONF {"raw":[100,100,100,73,100,100,100,100,100,100]}

00:12:19.300 --> 00:12:22.270
<v Speaker 2>this new list of instructions M followed by m.

NOTE CONF {"raw":[100,100,100,100,100,81,100,100,79]}

00:12:22.900 --> 00:12:23.650
<v Speaker 2>That's fine.

NOTE CONF {"raw":[100,100]}

00:12:23.650 --> 00:12:25.090
<v Speaker 2>That works perfectly well.

NOTE CONF {"raw":[100,100,100,100]}

00:12:25.870 --> 00:12:28.150
<v Speaker 2>So we don't need to worry about let doing something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:28.150 --> 00:12:28.630
<v Speaker 2>funny.

NOTE CONF {"raw":[100]}

00:12:28.630 --> 00:12:31.360
<v Speaker 2>It's just a set of instructions.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:33.910 --> 00:12:37.570
<v Speaker 2>And then the next trick is instead of always writing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:37.570 --> 00:12:38.950
<v Speaker 2>unit, we can write something else.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:38.950 --> 00:12:42.250
<v Speaker 2>So I o of char is a command that reads

NOTE CONF {"raw":[100,63,63,100,91,100,100,100,100,100]}

00:12:42.250 --> 00:12:44.380
<v Speaker 2>something from the input.

NOTE CONF {"raw":[100,100,100,100]}

00:12:46.970 --> 00:12:47.990
<v Speaker 2>And returns.

NOTE CONF {"raw":[100,100]}

00:12:47.990 --> 00:12:49.340
<v Speaker 2>Whatever it was, it read.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:50.750 --> 00:12:53.210
<v Speaker 2>So this is a list of commands.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:53.630 --> 00:12:57.200
<v Speaker 2>And whenever you execute the command, then it's going to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:57.200 --> 00:12:58.580
<v Speaker 2>return a value.

NOTE CONF {"raw":[100,100,100]}

00:12:59.330 --> 00:13:02.060
<v Speaker 2>So when we finally execute this command, if the input

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:02.060 --> 00:13:04.970
<v Speaker 2>is a b, c when we're done it's going to

NOTE CONF {"raw":[100,96,96,96,100,100,100,100,100,100]}

00:13:04.970 --> 00:13:06.560
<v Speaker 2>return the value a.

NOTE CONF {"raw":[100,100,100,100]}

00:13:06.920 --> 00:13:09.620
<v Speaker 2>And after we've done this it's done something.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:09.620 --> 00:13:11.360
<v Speaker 2>So the remaining input has changed.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:13:11.360 --> 00:13:14.360
<v Speaker 2>It's now BK we've read the A and B see

NOTE CONF {"raw":[93,100,48,100,100,100,100,100,100,69]}

00:13:14.360 --> 00:13:15.620
<v Speaker 2>what is left to read.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:18.320 --> 00:13:22.730
<v Speaker 2>Return does nothing except return the value that you give

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:22.730 --> 00:13:22.850
<v Speaker 2>it.

NOTE CONF {"raw":[100]}

00:13:22.850 --> 00:13:26.240
<v Speaker 2>So return of empty list could have type I o

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,83,86]}

00:13:26.240 --> 00:13:27.080
<v Speaker 2>of string.

NOTE CONF {"raw":[100,100]}

00:13:27.680 --> 00:13:29.870
<v Speaker 2>So in this case it's returning the empty string.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:13:30.560 --> 00:13:33.380
<v Speaker 2>And if the input was BK it would yield the

NOTE CONF {"raw":[100,100,100,100,100,50,100,100,100,100]}

00:13:33.380 --> 00:13:34.760
<v Speaker 2>value empty string.

NOTE CONF {"raw":[100,100,100]}

00:13:34.760 --> 00:13:37.790
<v Speaker 2>And the input doesn't change it just b c.

NOTE CONF {"raw":[100,100,100,100,100,89,100,55,57]}

00:13:37.790 --> 00:13:40.190
<v Speaker 2>So it does nothing except return a value.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:42.740 --> 00:13:46.190
<v Speaker 2>And now we can combine commands.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:13:46.580 --> 00:13:48.860
<v Speaker 2>So we first we do this command.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:48.860 --> 00:13:52.010
<v Speaker 2>It does some stuff and it returns a value.

NOTE CONF {"raw":[100,100,100,100,100,100,100,62,100]}

00:13:52.010 --> 00:13:53.930
<v Speaker 2>What are we going to do with that value.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:13:54.470 --> 00:13:56.960
<v Speaker 2>We are going to pass it into another function.

NOTE CONF {"raw":[84,84,100,100,100,100,100,100,100]}

00:13:57.380 --> 00:13:58.970
<v Speaker 2>This is a separate function.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:00.230 --> 00:14:02.060
<v Speaker 2>It takes an argument of type A.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:14:02.060 --> 00:14:03.500
<v Speaker 2>So we'll give it that one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:14:03.650 --> 00:14:06.800
<v Speaker 2>And then it does some stuff and returns the value

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,85,100]}

00:14:06.800 --> 00:14:07.640
<v Speaker 2>of type B.

NOTE CONF {"raw":[100,100,100]}

00:14:08.180 --> 00:14:09.860
<v Speaker 2>And this final thing.

NOTE CONF {"raw":[100,100,100,100]}

00:14:09.860 --> 00:14:11.090
<v Speaker 2>So what does this do.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:11.090 --> 00:14:13.550
<v Speaker 2>So it returns the value this one returned.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:13.670 --> 00:14:14.810
<v Speaker 2>But what does it do.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:14.810 --> 00:14:17.810
<v Speaker 2>It does everything this one does and everything this one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:17.810 --> 00:14:18.380
<v Speaker 2>does.

NOTE CONF {"raw":[100]}

00:14:18.380 --> 00:14:21.200
<v Speaker 2>So it's combining two things.

NOTE CONF {"raw":[100,97,100,100,100]}

00:14:21.200 --> 00:14:24.560
<v Speaker 2>So it's very similar to the operator we saw before.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:24.560 --> 00:14:26.840
<v Speaker 2>But now it's threading a value through.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:14:28.250 --> 00:14:32.360
<v Speaker 2>So for example if we say get char and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,96,100,100]}

00:14:32.360 --> 00:14:35.630
<v Speaker 2>apply this function lambda x put char to upper of

NOTE CONF {"raw":[100,100,100,100,100,100,100,96,100,100]}

00:14:35.630 --> 00:14:39.350
<v Speaker 2>x so it gets the character a x gets bound

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:39.350 --> 00:14:42.290
<v Speaker 2>to a to upper of little a is big A,

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:14:42.290 --> 00:14:43.760
<v Speaker 2>and that writes a big A.

NOTE CONF {"raw":[100,100,40,99,100,68]}

00:14:44.210 --> 00:14:47.540
<v Speaker 2>So when the input is a, b, c it produces

NOTE CONF {"raw":[100,100,100,100,100,96,96,96,100,100]}

00:14:47.540 --> 00:14:52.310
<v Speaker 2>the output a and the remaining input is BC.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,71]}

00:15:00.200 --> 00:15:04.880
<v Speaker 2>So in general right if m has type AOA and

NOTE CONF {"raw":[100,100,100,76,100,100,100,100,70,100]}

00:15:04.880 --> 00:15:05.570
<v Speaker 2>k.

NOTE CONF {"raw":[100]}

00:15:05.930 --> 00:15:08.450
<v Speaker 2>So this is actually a standard technique K stands for

NOTE CONF {"raw":[100,100,100,100,52,100,100,100,100,100]}

00:15:08.450 --> 00:15:09.530
<v Speaker 2>continuation.

NOTE CONF {"raw":[100]}

00:15:09.530 --> 00:15:12.470
<v Speaker 2>And quite often you write programs in what's called continuation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:12.470 --> 00:15:15.170
<v Speaker 2>passing style where you have a function that says this

NOTE CONF {"raw":[100,100,100,100,100,93,100,100,100,100]}

00:15:15.170 --> 00:15:16.730
<v Speaker 2>is what you do afterwards.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:19.940 --> 00:15:22.460
<v Speaker 2>So k takes an a doesn't I of b, then

NOTE CONF {"raw":[100,100,100,100,100,81,91,91,100,100]}

00:15:22.460 --> 00:15:25.490
<v Speaker 2>m followed by k will be an I o of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:25.520 --> 00:15:26.060
<v Speaker 2>b.

NOTE CONF {"raw":[100]}

00:15:26.240 --> 00:15:28.280
<v Speaker 2>And again this is just a recipe.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:28.520 --> 00:15:30.470
<v Speaker 2>And what does it do if you ever do it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:30.710 --> 00:15:32.690
<v Speaker 2>It performs the command m.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:32.960 --> 00:15:37.010
<v Speaker 2>But that will yield a value of type A which

NOTE CONF {"raw":[100,100,100,100,96,100,100,100,100,100]}

00:15:37.010 --> 00:15:38.120
<v Speaker 2>we'll call x.

NOTE CONF {"raw":[68,100,100]}

00:15:38.720 --> 00:15:41.270
<v Speaker 2>And then um it'll perform.

NOTE CONF {"raw":[100,100,81,99,100]}

00:15:41.270 --> 00:15:46.110
<v Speaker 2>It'll Ill apply k to x that yield something of

NOTE CONF {"raw":[98,98,96,76,75,97,42,39,100,100]}

00:15:46.110 --> 00:15:46.800
<v Speaker 2>type I of b.

NOTE CONF {"raw":[100,99,98,98]}

00:15:46.800 --> 00:15:48.210
<v Speaker 2>So that's some instructions.

NOTE CONF {"raw":[100,100,100,100]}

00:15:48.210 --> 00:15:51.300
<v Speaker 2>So it will do whatever the instructions say and return

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:51.300 --> 00:15:52.470
<v Speaker 2>a value y of type b.

NOTE CONF {"raw":[96,100,100,100,100,100]}

00:15:52.470 --> 00:15:55.140
<v Speaker 2>And then when we're done we just return the final

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:55.140 --> 00:15:56.430
<v Speaker 2>value y.

NOTE CONF {"raw":[100,100]}

00:15:59.940 --> 00:16:03.810
<v Speaker 2>So here's a program get line which says okay read

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:03.810 --> 00:16:04.620
<v Speaker 2>a character.

NOTE CONF {"raw":[100,100]}

00:16:04.620 --> 00:16:05.760
<v Speaker 2>Put that in X.

NOTE CONF {"raw":[100,100,100,100]}

00:16:05.760 --> 00:16:09.480
<v Speaker 2>If it's new line, stop, just return the empty string.

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:16:09.870 --> 00:16:13.770
<v Speaker 2>Otherwise recursively read the rest of the line again.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:16:13.770 --> 00:16:15.960
<v Speaker 2>You'll stop whenever you finally see a new line.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:16:15.960 --> 00:16:19.410
<v Speaker 2>Call that x as and return x cons xs.

NOTE CONF {"raw":[100,100,100,66,100,81,89,100,67]}

00:16:19.770 --> 00:16:22.410
<v Speaker 2>So if the input was a b, c new line

NOTE CONF {"raw":[100,100,100,100,100,74,74,74,100,100]}

00:16:22.410 --> 00:16:26.640
<v Speaker 2>def, it'll return the first line, the string a, b,

NOTE CONF {"raw":[100,78,100,100,100,100,100,100,100,100]}

00:16:26.640 --> 00:16:28.710
<v Speaker 2>c, and the remaining input.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:28.710 --> 00:16:29.970
<v Speaker 2>It'll eat up the new lines.

NOTE CONF {"raw":[85,100,100,100,100,67]}

00:16:29.970 --> 00:16:32.580
<v Speaker 2>The remaining input will be d e f.

NOTE CONF {"raw":[100,100,100,100,100,37,37,37]}

00:16:34.590 --> 00:16:35.280
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:16:35.280 --> 00:16:36.930
<v Speaker 2>Any questions about that?

NOTE CONF {"raw":[100,100,100,100]}

00:16:37.350 --> 00:16:41.730
<v Speaker 2>Especially from people who didn't see the slower Presentation yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:43.350 --> 00:16:46.050
<v Speaker 2>People who didn't see the slower presentation can nod like,

NOTE CONF {"raw":[100,100,100,100,97,97,100,100,100,100]}

00:16:46.050 --> 00:16:47.220
<v Speaker 2>okay, I follow that.

NOTE CONF {"raw":[100,100,100,100]}

00:16:48.990 --> 00:16:50.760
<v Speaker 2>Anybody nodding okay.

NOTE CONF {"raw":[100,100,99]}

00:16:53.700 --> 00:16:55.740
<v Speaker 2>So notice that right?

NOTE CONF {"raw":[100,100,100,100]}

00:16:55.740 --> 00:17:01.320
<v Speaker 2>Return um and bind are related to the things we

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,100]}

00:17:01.320 --> 00:17:02.970
<v Speaker 2>saw before down in sequence.

NOTE CONF {"raw":[100,100,83,100,100]}

00:17:03.000 --> 00:17:06.180
<v Speaker 2>Done is just return of again this unit type.

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,98]}

00:17:06.810 --> 00:17:12.329
<v Speaker 2>The thing that C calls void and sequence which just

NOTE CONF {"raw":[100,100,100,78,100,100,100,100,100,98]}

00:17:12.329 --> 00:17:17.610
<v Speaker 2>combines two commands, is just m bind a function that

NOTE CONF {"raw":[100,100,100,100,100,93,100,100,100,100]}

00:17:17.610 --> 00:17:18.930
<v Speaker 2>just ignores its argument.

NOTE CONF {"raw":[100,100,95,100]}

00:17:19.079 --> 00:17:22.260
<v Speaker 2>Its argument is bound to be the value of this

NOTE CONF {"raw":[79,100,100,100,100,100,100,100,100,100]}

00:17:22.260 --> 00:17:24.600
<v Speaker 2>type, and then goes off and does n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:17:25.260 --> 00:17:27.750
<v Speaker 2>So m followed by n can just be written as

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:27.750 --> 00:17:30.720
<v Speaker 2>a bind in this way, where you ignore the bound

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:30.720 --> 00:17:33.180
<v Speaker 2>value because it's always going to be of the unit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:33.180 --> 00:17:33.480
<v Speaker 2>type.

NOTE CONF {"raw":[100]}

00:17:33.480 --> 00:17:35.010
<v Speaker 2>So not very interesting.

NOTE CONF {"raw":[100,100,100,100]}

00:17:38.730 --> 00:17:40.950
<v Speaker 2>Though as I described, the unit type is not very

NOTE CONF {"raw":[37,84,100,96,100,51,100,100,100,100]}

00:17:40.950 --> 00:17:44.100
<v Speaker 2>interesting, but this is one of the interesting things that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,65]}

00:17:44.100 --> 00:17:46.830
<v Speaker 2>I hope you'll learn from seeing all this, which is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:46.830 --> 00:17:50.550
<v Speaker 2>that not very interesting types are very useful, but the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,74,100]}

00:17:50.550 --> 00:17:53.460
<v Speaker 2>unit type lets us deal just with IE of an

NOTE CONF {"raw":[100,100,100,100,100,100,100,32,100,100]}

00:17:53.460 --> 00:17:54.180
<v Speaker 2>arbitrary type.

NOTE CONF {"raw":[100,100]}

00:17:54.180 --> 00:17:57.060
<v Speaker 2>We don't need to build make up something separate to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:57.060 --> 00:17:59.310
<v Speaker 2>mean a command that doesn't return a value.

NOTE CONF {"raw":[100,100,100,100,100,100,86,100]}

00:17:59.340 --> 00:18:01.920
<v Speaker 2>We can just have I o of unit as saying,

NOTE CONF {"raw":[100,100,100,100,58,58,100,100,100,100]}

00:18:01.920 --> 00:18:04.050
<v Speaker 2>oh, this is a command and don't worry about the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:04.050 --> 00:18:05.280
<v Speaker 2>value it returns.

NOTE CONF {"raw":[100,84,100]}

00:18:05.310 --> 00:18:07.230
<v Speaker 2>It'll always be the same thing.

NOTE CONF {"raw":[89,100,100,100,100,100]}

00:18:09.360 --> 00:18:11.070
<v Speaker 2>And the type the unit type.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:18:11.070 --> 00:18:14.190
<v Speaker 2>Let's use the types to say whatever it returns.

NOTE CONF {"raw":[95,100,100,100,100,100,100,100,100]}

00:18:14.190 --> 00:18:15.390
<v Speaker 2>We know what it is.

NOTE CONF {"raw":[100,100,100,100,100]}

00:18:15.390 --> 00:18:17.670
<v Speaker 2>It will be the one value of the unit type.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:23.130 --> 00:18:26.490
<v Speaker 2>So now we have this echo program which does get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:26.490 --> 00:18:28.560
<v Speaker 2>line binds that to a line.

NOTE CONF {"raw":[100,86,100,100,100,100]}

00:18:28.740 --> 00:18:31.050
<v Speaker 2>This is very similar to the hand we just saw.

NOTE CONF {"raw":[100,100,100,100,100,96,42,100,100,100]}

00:18:31.050 --> 00:18:34.200
<v Speaker 2>If the line is empty then we'll stop and we'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,79]}

00:18:34.200 --> 00:18:35.130
<v Speaker 2>return the unit type.

NOTE CONF {"raw":[100,100,100,100]}

00:18:35.130 --> 00:18:39.430
<v Speaker 2>So this thing eventually returns the unit type And otherwise

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:39.580 --> 00:18:42.220
<v Speaker 2>we will map to upper over the line.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:42.220 --> 00:18:45.280
<v Speaker 2>So put the whole line in uppercase and then we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:45.280 --> 00:18:47.410
<v Speaker 2>will print it out with a new line at the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:47.410 --> 00:18:47.950
<v Speaker 2>end.

NOTE CONF {"raw":[100]}

00:18:49.840 --> 00:18:50.920
<v Speaker 2>So we read a line.

NOTE CONF {"raw":[100,100,100,70,100]}

00:18:50.920 --> 00:18:52.300
<v Speaker 2>Read the new line at the end.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:52.300 --> 00:18:53.350
<v Speaker 2>Print the line.

NOTE CONF {"raw":[100,100,100]}

00:18:53.350 --> 00:18:55.090
<v Speaker 2>Convert the line to uppercase.

NOTE CONF {"raw":[100,98,100,100,100]}

00:18:55.090 --> 00:18:55.960
<v Speaker 2>Print the line.

NOTE CONF {"raw":[100,100,100]}

00:18:55.960 --> 00:18:57.520
<v Speaker 2>Print a new line at the end.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:57.850 --> 00:19:00.250
<v Speaker 2>And again I'll just show an example of this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:19:00.250 --> 00:19:00.850
<v Speaker 2>Oops.

NOTE CONF {"raw":[94]}

00:19:31.690 --> 00:19:32.290
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:19:32.620 --> 00:19:34.390
<v Speaker 2>And now if I just hit New line, what's going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:34.390 --> 00:19:35.020
<v Speaker 2>to happen.

NOTE CONF {"raw":[100,100]}

00:19:38.830 --> 00:19:39.310
<v Speaker 2>Come on.

NOTE CONF {"raw":[100,100]}

00:19:39.310 --> 00:19:41.320
<v Speaker 2>If I just hit new lines, what's going to happen?

NOTE CONF {"raw":[100,100,100,100,82,66,100,100,100,100]}

00:19:43.960 --> 00:19:45.610
<v Speaker 2>The computer will explode.

NOTE CONF {"raw":[100,100,100,100]}

00:19:46.750 --> 00:19:47.170
<v Speaker 2>Yes.

NOTE CONF {"raw":[100]}

00:19:47.170 --> 00:19:47.680
<v Speaker 2>No.

NOTE CONF {"raw":[100]}

00:19:47.680 --> 00:19:48.340
<v Speaker 2>We'll vote.

NOTE CONF {"raw":[100,100]}

00:19:48.370 --> 00:19:50.500
<v Speaker 2>How many people think the computer will explode?

NOTE CONF {"raw":[100,100,100,100,99,100,100,100]}

00:19:51.970 --> 00:19:52.630
<v Speaker 2>Three.

NOTE CONF {"raw":[100]}

00:19:52.630 --> 00:19:52.990
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:19:52.990 --> 00:19:55.810
<v Speaker 2>How many people think the program will just terminate quietly?

NOTE CONF {"raw":[100,100,100,100,100,98,100,100,100,100]}

00:19:58.450 --> 00:20:00.040
<v Speaker 2>Ah, it didn't explode.

NOTE CONF {"raw":[100,100,100,100]}

00:20:00.040 --> 00:20:00.820
<v Speaker 2>How boring.

NOTE CONF {"raw":[100,100]}

00:20:08.710 --> 00:20:11.860
<v Speaker 2>Okay, and then we have a special built in notation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:11.860 --> 00:20:15.370
<v Speaker 2>in Haskell called do notation, where, just as a matter

NOTE CONF {"raw":[99,100,100,52,100,100,100,100,100,100]}

00:20:15.370 --> 00:20:19.000
<v Speaker 2>of engineering the way our brains work, it's much easier

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:19.000 --> 00:20:21.790
<v Speaker 2>if you get the short name first and then get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:21.790 --> 00:20:23.710
<v Speaker 2>the thing that has that short name, because then you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:23.710 --> 00:20:24.790
<v Speaker 2>know what to call it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:25.540 --> 00:20:29.650
<v Speaker 2>Then if you give it a possibly long thing, saying

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:29.650 --> 00:20:32.020
<v Speaker 2>what to do, and then the short name to call

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:32.020 --> 00:20:32.590
<v Speaker 2>it by.

NOTE CONF {"raw":[100,96]}

00:20:33.220 --> 00:20:36.620
<v Speaker 2>So the, uh, the way Haskell works, right?

NOTE CONF {"raw":[100,100,100,100,100,90,100,100]}

00:20:36.620 --> 00:20:37.910
<v Speaker 2>We need a function here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:37.910 --> 00:20:39.710
<v Speaker 2>So the lambda has to come here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:20:39.710 --> 00:20:43.280
<v Speaker 2>So we just defined a special notation that says well

NOTE CONF {"raw":[99,100,100,71,100,100,100,100,100,100]}

00:20:43.280 --> 00:20:46.400
<v Speaker 2>you write the name here and a backwards arrow.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:20:46.400 --> 00:20:50.030
<v Speaker 2>And then the function, it looks a little bit like

NOTE CONF {"raw":[100,100,100,100,96,100,100,100,100,100]}

00:20:50.030 --> 00:20:51.800
<v Speaker 2>what you do in the list comprehension.

NOTE CONF {"raw":[100,100,100,100,76,100,100]}

00:20:53.090 --> 00:20:56.000
<v Speaker 2>Um, so this program and this one are just the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:56.000 --> 00:20:56.240
<v Speaker 2>same.

NOTE CONF {"raw":[100]}

00:20:56.240 --> 00:20:59.870
<v Speaker 2>So it says um do get char bind x to

NOTE CONF {"raw":[75,83,100,100,100,100,96,100,97,94]}

00:20:59.870 --> 00:21:04.130
<v Speaker 2>the result, do get line bind XS to the result.

NOTE CONF {"raw":[100,100,100,100,57,100,84,100,100,100]}

00:21:04.130 --> 00:21:05.690
<v Speaker 2>So that's what's written here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:05.870 --> 00:21:07.940
<v Speaker 2>And this is just a different way of writing the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:07.940 --> 00:21:08.630
<v Speaker 2>same thing.

NOTE CONF {"raw":[100,100]}

00:21:08.630 --> 00:21:11.750
<v Speaker 2>What's most important here is that due notation is written

NOTE CONF {"raw":[100,100,100,100,100,100,66,100,100,100]}

00:21:11.750 --> 00:21:15.170
<v Speaker 2>with curly braces and with semicolons after each of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:15.170 --> 00:21:18.590
<v Speaker 2>command, which makes it look a bit like see, C

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,49,89]}

00:21:18.590 --> 00:21:22.850
<v Speaker 2>was the most popular language when Haskell was designed, so

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:22.850 --> 00:21:24.380
<v Speaker 2>it was helpful to make it look a little bit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:24.380 --> 00:21:25.220
<v Speaker 2>like that.

NOTE CONF {"raw":[100,100]}

00:21:25.310 --> 00:21:27.860
<v Speaker 2>But the key thing I said this yesterday, but I'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:27.860 --> 00:21:31.940
<v Speaker 2>repeat it now, is that because Haskell is a functional

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:31.940 --> 00:21:36.740
<v Speaker 2>language, because you can always bind variables with lambda expressions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:37.070 --> 00:21:38.450
<v Speaker 2>I could just define this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:38.450 --> 00:21:41.210
<v Speaker 2>I didn't need to get Will Partain, who was in

NOTE CONF {"raw":[100,100,100,100,100,100,100,90,81,100]}

00:21:41.210 --> 00:21:45.500
<v Speaker 2>charge of the Haskell compiler, to add this special notation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,58,100,100]}

00:21:45.830 --> 00:21:48.770
<v Speaker 2>I could just write this and experiment with it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:21:50.720 --> 00:21:52.220
<v Speaker 2>So that's very important.

NOTE CONF {"raw":[87,100,100,100]}

00:21:52.220 --> 00:21:55.940
<v Speaker 2>Haskell puts a lot of power at your fingertips.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:21:55.940 --> 00:21:59.390
<v Speaker 2>That may not always be the most convenient notation, but

NOTE CONF {"raw":[87,100,100,100,100,100,100,100,100,100]}

00:21:59.390 --> 00:22:02.510
<v Speaker 2>it will be a pretty convenient notation for writing things

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:02.510 --> 00:22:03.170
<v Speaker 2>out in.

NOTE CONF {"raw":[100,100]}

00:22:03.380 --> 00:22:09.350
<v Speaker 2>So when you become a true programmer, what a true

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:09.350 --> 00:22:13.850
<v Speaker 2>programmer does is first they decide the the right language

NOTE CONF {"raw":[100,100,100,100,100,100,95,100,100,100]}

00:22:13.850 --> 00:22:16.130
<v Speaker 2>for expressing their solution.

NOTE CONF {"raw":[100,100,100,100]}

00:22:16.670 --> 00:22:20.570
<v Speaker 2>They implement that language, and then they express their solution

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:20.570 --> 00:22:21.950
<v Speaker 2>in that language.

NOTE CONF {"raw":[100,100,100]}

00:22:22.400 --> 00:22:25.010
<v Speaker 2>That's really what programming is about.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:25.010 --> 00:22:28.340
<v Speaker 2>And the real power of functional languages is they make

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:28.340 --> 00:22:31.370
<v Speaker 2>it very easy to define whatever language it is you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:31.370 --> 00:22:32.060
<v Speaker 2>need.

NOTE CONF {"raw":[100]}

00:22:32.240 --> 00:22:35.750
<v Speaker 2>So I was doing here with Return and Bind was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:35.750 --> 00:22:40.010
<v Speaker 2>basically defining a language that's useful for expressing sets of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:40.010 --> 00:22:44.930
<v Speaker 2>commands, sequences of commands, instructions to follow whatever you want.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:50.510 --> 00:22:52.790
<v Speaker 2>Okay, so when you write do x one from e1,

NOTE CONF {"raw":[100,100,100,100,98,100,100,100,100,82]}

00:22:52.790 --> 00:22:55.550
<v Speaker 2>x two from e2, e3, and so on, it really

NOTE CONF {"raw":[100,100,100,92,75,100,100,100,100,85]}

00:22:55.550 --> 00:22:57.980
<v Speaker 2>means e1 bind lambda x one.

NOTE CONF {"raw":[100,100,100,100,54,54]}

00:22:58.100 --> 00:22:59.930
<v Speaker 2>And then the body of the function is all the

NOTE CONF {"raw":[100,100,100,100,100,100,89,89,100,100]}

00:22:59.930 --> 00:23:03.020
<v Speaker 2>rest of this e2 bind lambda x two and the

NOTE CONF {"raw":[100,100,100,88,100,100,86,86,100,100]}

00:23:03.020 --> 00:23:05.060
<v Speaker 2>body is all the rest of this, and so on.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:09.050 --> 00:23:09.620
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:23:09.620 --> 00:23:14.360
<v Speaker 2>So we just went through what a monoid is right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:14.360 --> 00:23:18.650
<v Speaker 2>If you've got an operator um, oh plus and a

NOTE CONF {"raw":[100,100,100,100,100,100,72,100,100,100]}

00:23:18.650 --> 00:23:22.340
<v Speaker 2>value you short for unit such that you is the

NOTE CONF {"raw":[100,92,100,100,100,84,86,100,100,100]}

00:23:22.340 --> 00:23:23.210
<v Speaker 2>unit for oh plus.

NOTE CONF {"raw":[100,100,51,99]}

00:23:23.210 --> 00:23:26.360
<v Speaker 2>So you plus x is x x plus you is

NOTE CONF {"raw":[71,92,100,100,100,100,100,100,61,100]}

00:23:26.360 --> 00:23:29.570
<v Speaker 2>x and x plus y plus z is the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:29.570 --> 00:23:31.310
<v Speaker 2>no matter how you parentheses it.

NOTE CONF {"raw":[100,100,100,100,95,100]}

00:23:31.550 --> 00:23:31.970
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:23:31.970 --> 00:23:35.520
<v Speaker 2>There are lots of these around plus and zero times

NOTE CONF {"raw":[100,100,100,100,100,100,100,96,100,100]}

00:23:35.520 --> 00:23:40.260
<v Speaker 2>and one or and false and and true concatenate and

NOTE CONF {"raw":[100,100,100,98,100,100,74,100,100,68]}

00:23:40.260 --> 00:23:41.400
<v Speaker 2>the empty list.

NOTE CONF {"raw":[100,100,100]}

00:23:41.400 --> 00:23:44.760
<v Speaker 2>And we saw another one sequence and done.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:23:44.910 --> 00:23:47.160
<v Speaker 2>These are all examples of monoids.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:47.160 --> 00:23:48.030
<v Speaker 2>Does anybody.

NOTE CONF {"raw":[100,100]}

00:23:48.030 --> 00:23:50.730
<v Speaker 2>So this includes the two from Boolean algebra.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:23:50.820 --> 00:23:53.520
<v Speaker 2>Does anybody else have a favourite example of a monoid?

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:23:57.990 --> 00:23:58.770
<v Speaker 2>No one.

NOTE CONF {"raw":[100,100]}

00:24:00.900 --> 00:24:04.560
<v Speaker 2>How about matrix multiplication and the unit matrix?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:06.870 --> 00:24:10.110
<v Speaker 2>Any others vector space?

NOTE CONF {"raw":[97,100,100,100]}

00:24:10.140 --> 00:24:10.620
<v Speaker 2>Good.

NOTE CONF {"raw":[100]}

00:24:11.910 --> 00:24:15.360
<v Speaker 2>Um, so you've got um vector addition in the vector

NOTE CONF {"raw":[100,100,100,100,100,100,100,55,70,100]}

00:24:15.360 --> 00:24:16.170
<v Speaker 2>space.

NOTE CONF {"raw":[100]}

00:24:16.500 --> 00:24:19.740
<v Speaker 2>And then the unit is the zero vector.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:19.740 --> 00:24:20.430
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:24:20.670 --> 00:24:21.540
<v Speaker 2>Very good.

NOTE CONF {"raw":[100,100]}

00:24:23.730 --> 00:24:25.680
<v Speaker 2>So just lots of these things.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:27.060 --> 00:24:30.210
<v Speaker 2>So a monad is actually very similar to a monoid.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:30.900 --> 00:24:31.230
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:24:31.230 --> 00:24:35.730
<v Speaker 2>We've got something like a unit which is return, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,84,100]}

00:24:35.730 --> 00:24:39.030
<v Speaker 2>we have a property like associativity, which is if I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:39.030 --> 00:24:42.210
<v Speaker 2>do m bind the result to x and then do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:42.210 --> 00:24:45.360
<v Speaker 2>n and bind the result to y and then do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:45.360 --> 00:24:45.990
<v Speaker 2>O.

NOTE CONF {"raw":[67]}

00:24:46.020 --> 00:24:48.660
<v Speaker 2>It doesn't really matter where I put the parentheses.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:24:51.120 --> 00:24:54.750
<v Speaker 2>And if I return a value v and then bind

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:54.750 --> 00:24:57.690
<v Speaker 2>that to x and do m, then that's just like

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:24:57.690 --> 00:24:59.370
<v Speaker 2>lambda x m applied to v.

NOTE CONF {"raw":[100,66,66,100,100,100]}

00:24:59.370 --> 00:25:02.400
<v Speaker 2>Or it's also like m with x replaced by v.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:03.300 --> 00:25:06.390
<v Speaker 2>If I do m and then do lambda x return

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:06.390 --> 00:25:09.300
<v Speaker 2>x, which could also I could just write return there.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,85]}

00:25:09.300 --> 00:25:10.620
<v Speaker 2>They mean the same thing.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:11.670 --> 00:25:14.370
<v Speaker 2>Um, then that's just doing M right.

NOTE CONF {"raw":[92,100,100,100,100,77,92]}

00:25:14.370 --> 00:25:16.620
<v Speaker 2>If I do m bind the result to x and

NOTE CONF {"raw":[99,100,100,94,100,100,100,82,100,100]}

00:25:16.620 --> 00:25:19.020
<v Speaker 2>then return x, well, that's the same as if I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:19.020 --> 00:25:19.800
<v Speaker 2>just did em.

NOTE CONF {"raw":[100,100,58]}

00:25:21.510 --> 00:25:22.110
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:25:25.440 --> 00:25:28.740
<v Speaker 2>So something satisfying.

NOTE CONF {"raw":[100,100,100]}

00:25:28.740 --> 00:25:36.210
<v Speaker 2>These three laws is called a monad, and it doesn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:36.210 --> 00:25:36.630
<v Speaker 2>look like.

NOTE CONF {"raw":[100,100]}

00:25:36.720 --> 00:25:39.630
<v Speaker 2>I mean, if you squint, these look very similar, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:39.630 --> 00:25:42.960
<v Speaker 2>clearly this is doing some extra stuff that this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:42.960 --> 00:25:43.830
<v Speaker 2>not doing.

NOTE CONF {"raw":[100,100]}

00:25:44.280 --> 00:25:46.800
<v Speaker 2>But there's something called category theory.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:25:47.130 --> 00:25:51.150
<v Speaker 2>And in category three it has such general definitions that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:51.150 --> 00:25:54.360
<v Speaker 2>you can actually turn this one into an instance of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:54.360 --> 00:25:57.450
<v Speaker 2>the definition in category theory of this one.

NOTE CONF {"raw":[100,100,88,100,100,100,100,100]}

00:25:59.160 --> 00:26:02.490
<v Speaker 2>So this actually really is a monoid.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:26:03.240 --> 00:26:05.970
<v Speaker 2>So the reason it's called monad is there's this branch

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:05.970 --> 00:26:08.190
<v Speaker 2>of mathematics called category theory.

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:09.420 --> 00:26:12.660
<v Speaker 2>Um it's quite general.

NOTE CONF {"raw":[100,100,100,100]}

00:26:12.660 --> 00:26:15.990
<v Speaker 2>It's a very useful thing for computer scientists to know

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:15.990 --> 00:26:18.990
<v Speaker 2>because it's basically about taking different systems and how you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:18.990 --> 00:26:19.770
<v Speaker 2>relate them.

NOTE CONF {"raw":[100,100]}

00:26:20.040 --> 00:26:22.560
<v Speaker 2>So it's a generalisation of algebra.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:26:22.560 --> 00:26:25.230
<v Speaker 2>In algebra you have different kinds of algebras and mappings

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:25.230 --> 00:26:29.830
<v Speaker 2>between them, which are called homomorphisms In categories.

NOTE CONF {"raw":[100,100,100,100,100,100,85,100]}

00:26:30.430 --> 00:26:31.870
<v Speaker 2>You have things.

NOTE CONF {"raw":[100,100,43]}

00:26:32.230 --> 00:26:35.200
<v Speaker 2>They might be algebras, they might be sets, they might

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:35.200 --> 00:26:36.010
<v Speaker 2>be other thingies.

NOTE CONF {"raw":[100,100,56]}

00:26:36.010 --> 00:26:37.690
<v Speaker 2>They're just called objects.

NOTE CONF {"raw":[97,100,100,100]}

00:26:38.290 --> 00:26:41.410
<v Speaker 2>And you have mappings between them which are called arrows.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:41.860 --> 00:26:44.200
<v Speaker 2>And very pleased to tell you that the objects in

NOTE CONF {"raw":[76,100,100,100,100,100,100,100,100,50]}

00:26:44.200 --> 00:26:48.490
<v Speaker 2>category theory have nothing whatsoever to do with object oriented

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:48.490 --> 00:26:53.200
<v Speaker 2>programming, but they are very useful for computing.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:54.940 --> 00:26:57.460
<v Speaker 2>Um, and so if you want to go off and

NOTE CONF {"raw":[96,100,99,100,100,100,100,100,100,100]}

00:26:57.460 --> 00:26:58.840
<v Speaker 2>study it, it's kind of useful.

NOTE CONF {"raw":[100,82,100,100,100,100]}

00:26:58.840 --> 00:27:01.630
<v Speaker 2>But an example of this is that right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:01.630 --> 00:27:03.940
<v Speaker 2>You don't need any category theory to understand this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:03.940 --> 00:27:05.440
<v Speaker 2>I just explained it to you.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:27:05.800 --> 00:27:09.400
<v Speaker 2>But the people who first discovered these notions were category

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:09.400 --> 00:27:10.180
<v Speaker 2>theorists.

NOTE CONF {"raw":[100]}

00:27:10.360 --> 00:27:14.740
<v Speaker 2>So category theory was first developed in the 40s.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:14.830 --> 00:27:17.950
<v Speaker 2>In the 50s, they found out that this structure was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:17.950 --> 00:27:22.540
<v Speaker 2>quite useful for doing things in algebraic topology, which I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:22.540 --> 00:27:26.560
<v Speaker 2>don't know, but this generalisation came out of it, of

NOTE CONF {"raw":[100,100,100,100,80,100,100,100,100,100]}

00:27:26.560 --> 00:27:31.750
<v Speaker 2>having a bind operator and a return operator, which they

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:31.750 --> 00:27:33.520
<v Speaker 2>had different names for those.

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:33.520 --> 00:27:35.560
<v Speaker 2>But it's essentially just this idea.

NOTE CONF {"raw":[100,96,100,100,100,100]}

00:27:37.240 --> 00:27:38.260
<v Speaker 2>And then Eugenio.

NOTE CONF {"raw":[100,100,68]}

00:27:38.710 --> 00:27:42.880
<v Speaker 2>So the reason it's called a monad is it looks

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:42.880 --> 00:27:45.130
<v Speaker 2>a lot like a monoid, but the pun on that

NOTE CONF {"raw":[100,100,100,100,100,52,52,100,100,100]}

00:27:45.130 --> 00:27:49.510
<v Speaker 2>monad is a term used by Leibnitz when he did

NOTE CONF {"raw":[100,100,100,100,100,100,88,100,100,100]}

00:27:49.510 --> 00:27:50.470
<v Speaker 2>philosophy.

NOTE CONF {"raw":[100]}

00:27:51.730 --> 00:27:54.280
<v Speaker 2>Um, so monads are something we use in computing all

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:54.280 --> 00:27:56.740
<v Speaker 2>the time to structure side effects.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:27:57.130 --> 00:28:00.520
<v Speaker 2>Actually, when Leibniz was writing about monads, interestingly, he was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:00.520 --> 00:28:05.410
<v Speaker 2>using them for abstract data types because we said about

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:28:05.410 --> 00:28:08.680
<v Speaker 2>monad is it has no windows through which you can

NOTE CONF {"raw":[93,98,100,100,100,100,100,100,100,100]}

00:28:08.680 --> 00:28:09.610
<v Speaker 2>see it's inside.

NOTE CONF {"raw":[100,52,100]}

00:28:09.610 --> 00:28:13.090
<v Speaker 2>So in other words, it's an abstraction where you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:13.090 --> 00:28:14.440
<v Speaker 2>understand it from the outside.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:14.440 --> 00:28:16.960
<v Speaker 2>But how it works on the inside is immaterial.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:17.230 --> 00:28:20.260
<v Speaker 2>And the most famous sentence you will find in Leibniz

NOTE CONF {"raw":[100,100,100,100,100,99,99,100,100,64]}

00:28:20.290 --> 00:28:23.320
<v Speaker 2>says God is a monad.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:26.200 --> 00:28:29.830
<v Speaker 2>So the category theorist, it was called category theory after

NOTE CONF {"raw":[100,100,100,55,100,100,100,100,100,100]}

00:28:29.830 --> 00:28:32.020
<v Speaker 2>Kant's categorical imperative.

NOTE CONF {"raw":[100,100,100]}

00:28:32.020 --> 00:28:35.740
<v Speaker 2>They just, um, sort of decided as a convention everything

NOTE CONF {"raw":[100,100,86,100,100,100,100,100,100,100]}

00:28:35.740 --> 00:28:39.340
<v Speaker 2>they named, they would give it a name from philosophy.

NOTE CONF {"raw":[100,83,100,100,100,100,100,100,100,100]}

00:28:39.640 --> 00:28:44.470
<v Speaker 2>So this this actually has three parts to it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:44.800 --> 00:28:47.230
<v Speaker 2>Um, one is the name of the thing that builds

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:47.230 --> 00:28:47.650
<v Speaker 2>the type.

NOTE CONF {"raw":[100,100]}

00:28:47.650 --> 00:28:50.200
<v Speaker 2>So for us that's been fixed at IO, but we'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,89,100,100]}

00:28:50.200 --> 00:28:50.350
<v Speaker 2>see.

NOTE CONF {"raw":[100]}

00:28:50.350 --> 00:28:53.680
<v Speaker 2>It can be an arbitrary, um, type constructor.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:28:53.680 --> 00:28:57.670
<v Speaker 2>So the arbitrary constructor, the thing that squishes things together,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:57.760 --> 00:29:00.910
<v Speaker 2>which is bind, and the thing that just pushes something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:00.910 --> 00:29:04.660
<v Speaker 2>into, uh, into this type, which is called return.

NOTE CONF {"raw":[100,65,100,100,100,100,100,100,100]}

00:29:04.660 --> 00:29:07.930
<v Speaker 2>So it was also called a triple, but that's a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:07.930 --> 00:29:08.980
<v Speaker 2>very boring name.

NOTE CONF {"raw":[100,100,100]}

00:29:09.850 --> 00:29:12.730
<v Speaker 2>Calling them triples when they have three components.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:12.730 --> 00:29:15.160
<v Speaker 2>It's sort of like calling something, hey, you.

NOTE CONF {"raw":[70,100,100,100,100,100,100,100]}

00:29:15.940 --> 00:29:20.050
<v Speaker 2>So monad was a much better name because it had

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:20.050 --> 00:29:21.400
<v Speaker 2>some substance to it.

NOTE CONF {"raw":[100,100,100,100]}

00:29:21.490 --> 00:29:25.520
<v Speaker 2>And um, it alluded to things in category theory.

NOTE CONF {"raw":[100,55,100,89,100,100,100,100,100]}

00:29:26.390 --> 00:29:29.240
<v Speaker 2>Sorry eluded to things in philosophy.

NOTE CONF {"raw":[100,57,100,100,100,100]}

00:29:29.240 --> 00:29:30.440
<v Speaker 2>Let's get this right.

NOTE CONF {"raw":[100,100,100,100]}

00:29:33.680 --> 00:29:35.120
<v Speaker 2>So I've meant so.

NOTE CONF {"raw":[100,100,98,100]}

00:29:35.120 --> 00:29:38.570
<v Speaker 2>I've just shown you the one monad that's built in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:38.570 --> 00:29:41.690
<v Speaker 2>to Haskell, which we use for doing stuff.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:42.170 --> 00:29:46.880
<v Speaker 2>But in fact, why says what a, um, what?

NOTE CONF {"raw":[100,100,100,64,99,100,100,100,100]}

00:29:46.880 --> 00:29:49.970
<v Speaker 2>Any programming language is most useful for designing your own

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:49.970 --> 00:29:53.060
<v Speaker 2>language and then using that to solve your problem.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:53.360 --> 00:29:55.640
<v Speaker 2>So I'm going to show you now how are we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,94]}

00:29:55.640 --> 00:29:56.420
<v Speaker 2>doing for time?

NOTE CONF {"raw":[100,100,100]}

00:29:57.620 --> 00:30:00.230
<v Speaker 2>Two instances of doing that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:30:04.430 --> 00:30:10.640
<v Speaker 2>So in general we have um, an arbitrary constructor.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:10.640 --> 00:30:14.060
<v Speaker 2>So here is how monads are defined in Haskell as

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:30:14.060 --> 00:30:16.130
<v Speaker 2>a type class that defines a type class.

NOTE CONF {"raw":[100,63,63,100,100,97,82,82]}

00:30:16.130 --> 00:30:20.780
<v Speaker 2>So we can always reuse the names return and greater

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:20.780 --> 00:30:23.540
<v Speaker 2>than greater than equal which I'll pronounce bind.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:30:24.980 --> 00:30:25.400
<v Speaker 2>um.

NOTE CONF {"raw":[99]}

00:30:27.470 --> 00:30:29.570
<v Speaker 2>But in general, you just say monad of m.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:29.570 --> 00:30:31.910
<v Speaker 2>M is an arbitrary type constructor.

NOTE CONF {"raw":[100,97,100,100,100,100]}

00:30:32.870 --> 00:30:33.440
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:30:33.950 --> 00:30:37.670
<v Speaker 2>Return takes a value of type A for any type

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:37.670 --> 00:30:39.560
<v Speaker 2>A and returns an m of A.

NOTE CONF {"raw":[100,100,100,98,100,100,100]}

00:30:40.010 --> 00:30:40.910
<v Speaker 2>So before it.

NOTE CONF {"raw":[100,100,77]}

00:30:41.240 --> 00:30:43.040
<v Speaker 2>So before m was I o.

NOTE CONF {"raw":[100,100,100,100,42,38]}

00:30:43.040 --> 00:30:44.750
<v Speaker 2>So this returned an I o of a.

NOTE CONF {"raw":[100,100,100,94,94,94,100,100]}

00:30:44.750 --> 00:30:46.430
<v Speaker 2>In general it's just an m of a.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:30:46.580 --> 00:30:50.360
<v Speaker 2>And similarly bind takes an m of a and an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:50.360 --> 00:30:52.880
<v Speaker 2>a to m of B and returns an m of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:52.910 --> 00:30:53.360
<v Speaker 2>B.

NOTE CONF {"raw":[100]}

00:30:54.560 --> 00:30:58.640
<v Speaker 2>Example lists form a monad.

NOTE CONF {"raw":[100,100,100,100,100]}

00:30:58.970 --> 00:31:00.170
<v Speaker 2>So here open.

NOTE CONF {"raw":[100,100,100]}

00:31:00.170 --> 00:31:02.840
<v Speaker 2>Close is used not to mean the empty list, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:02.840 --> 00:31:04.550
<v Speaker 2>to mean the list type.

NOTE CONF {"raw":[100,100,100,100,99]}

00:31:06.350 --> 00:31:06.590
<v Speaker 2>Right.

NOTE CONF {"raw":[58]}

00:31:06.590 --> 00:31:09.020
<v Speaker 2>So open close applies to a is what we write.

NOTE CONF {"raw":[70,100,82,39,100,100,100,100,100,100]}

00:31:09.290 --> 00:31:11.300
<v Speaker 2>Open bracket A closed bracket.

NOTE CONF {"raw":[100,100,100,61,100]}

00:31:11.300 --> 00:31:12.920
<v Speaker 2>The type lists of a.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:12.980 --> 00:31:15.560
<v Speaker 2>So return takes an A and gives you a list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:15.560 --> 00:31:16.160
<v Speaker 2>of a.

NOTE CONF {"raw":[100,99]}

00:31:16.340 --> 00:31:18.980
<v Speaker 2>Okay I know a function that does that return of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:18.980 --> 00:31:21.380
<v Speaker 2>x returns the list with one thing in it, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:21.380 --> 00:31:22.100
<v Speaker 2>is x.

NOTE CONF {"raw":[100,100]}

00:31:22.970 --> 00:31:26.630
<v Speaker 2>The return takes a value into a list of that

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:31:26.630 --> 00:31:29.840
<v Speaker 2>value and bind.

NOTE CONF {"raw":[100,100,100]}

00:31:29.870 --> 00:31:30.200
<v Speaker 2>Hmm.

NOTE CONF {"raw":[90]}

00:31:31.400 --> 00:31:36.080
<v Speaker 2>So bind takes a list of a right because it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,100,96]}

00:31:36.080 --> 00:31:38.750
<v Speaker 2>in M of that B list of A and a

NOTE CONF {"raw":[56,65,89,55,31,100,100,100,100,100]}

00:31:38.750 --> 00:31:40.700
<v Speaker 2>function from A to m of b, so that would

NOTE CONF {"raw":[100,100,100,100,71,100,100,100,100,100]}

00:31:40.700 --> 00:31:43.880
<v Speaker 2>be from A to list of b and returns a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:43.880 --> 00:31:45.080
<v Speaker 2>list of b.

NOTE CONF {"raw":[100,100,100]}

00:31:47.510 --> 00:31:49.130
<v Speaker 2>How would I do that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:49.340 --> 00:31:53.150
<v Speaker 2>Okay so m now stands for list k is a

NOTE CONF {"raw":[100,100,73,100,100,100,100,100,100,100]}

00:31:53.150 --> 00:31:58.190
<v Speaker 2>function that given an element of that list, returns another

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:58.190 --> 00:31:59.060
<v Speaker 2>whole list.

NOTE CONF {"raw":[100,100]}

00:31:59.870 --> 00:32:03.290
<v Speaker 2>So this M is a list of type a k

NOTE CONF {"raw":[100,100,87,100,100,100,100,100,100,100]}

00:32:03.290 --> 00:32:06.020
<v Speaker 2>takes an A and returns a list of type b.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:07.490 --> 00:32:09.320
<v Speaker 2>So what does bind do here?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:09.320 --> 00:32:13.760
<v Speaker 2>Well, if I wrote it as a list comprehension that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:13.760 --> 00:32:17.840
<v Speaker 2>would be take x from m, draw x from m,

NOTE CONF {"raw":[100,100,100,100,100,98,98,100,100,93]}

00:32:18.080 --> 00:32:21.410
<v Speaker 2>and then for each x and m, let y be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:21.420 --> 00:32:24.900
<v Speaker 2>drawn from k of X and then return that list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:24.900 --> 00:32:25.590
<v Speaker 2>of y.

NOTE CONF {"raw":[100,98]}

00:32:26.850 --> 00:32:30.000
<v Speaker 2>Notice that this is just equivalent to the following recursive

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:30.000 --> 00:32:30.900
<v Speaker 2>definition.

NOTE CONF {"raw":[100]}

00:32:31.230 --> 00:32:34.410
<v Speaker 2>Empty list bind k is just empty list.

NOTE CONF {"raw":[100,100,85,100,100,100,100,100]}

00:32:34.890 --> 00:32:37.680
<v Speaker 2>X cons x is bind k is.

NOTE CONF {"raw":[87,100,100,100,100,100,100]}

00:32:37.680 --> 00:32:39.300
<v Speaker 2>Apply k to x.

NOTE CONF {"raw":[95,100,100,100]}

00:32:39.300 --> 00:32:41.250
<v Speaker 2>That will give us a list of b.

NOTE CONF {"raw":[100,100,100,100,100,100,100,99]}

00:32:42.510 --> 00:32:42.810
<v Speaker 2>Um.

NOTE CONF {"raw":[100]}

00:32:42.990 --> 00:32:45.270
<v Speaker 2>Take x and bind k on it.

NOTE CONF {"raw":[100,47,100,100,100,100,100]}

00:32:45.270 --> 00:32:46.980
<v Speaker 2>That will give us a list of b.

NOTE CONF {"raw":[93,93,100,100,100,100,100,100]}

00:32:46.980 --> 00:32:49.680
<v Speaker 2>We've got two lists of B and we just append

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:49.680 --> 00:32:49.950
<v Speaker 2>them.

NOTE CONF {"raw":[100]}

00:32:51.210 --> 00:32:54.930
<v Speaker 2>Or another way of writing this is m bind k

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,96,100]}

00:32:54.930 --> 00:32:56.700
<v Speaker 2>is just map k over m.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:56.700 --> 00:32:58.620
<v Speaker 2>So now we've got a list of list of b

NOTE CONF {"raw":[100,100,100,100,100,100,100,85,100,100]}

00:32:58.620 --> 00:32:59.730
<v Speaker 2>and we concat.

NOTE CONF {"raw":[100,95,74]}

00:32:59.730 --> 00:33:02.790
<v Speaker 2>So that collapses that down to a list of b.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:04.290 --> 00:33:07.470
<v Speaker 2>And in fact when I was first applying monads I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:07.470 --> 00:33:09.690
<v Speaker 2>wasn't doing it for side effects.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:09.690 --> 00:33:11.250
<v Speaker 2>I was doing it for this.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:11.250 --> 00:33:15.630
<v Speaker 2>To understand what's going on with list comprehensions, I realised

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,93]}

00:33:15.630 --> 00:33:19.350
<v Speaker 2>that monads were exactly gave you just enough stuff to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:19.350 --> 00:33:22.590
<v Speaker 2>define a list comprehension and set of do notation, we

NOTE CONF {"raw":[100,100,100,100,100,51,52,100,100,100]}

00:33:22.590 --> 00:33:24.900
<v Speaker 2>have what's not in Haskell anymore.

NOTE CONF {"raw":[76,100,100,100,100,90]}

00:33:24.900 --> 00:33:28.230
<v Speaker 2>Monad comprehensions where this instead of a list could be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:28.230 --> 00:33:33.750
<v Speaker 2>an arbitrary monad do notation turned out to be a

NOTE CONF {"raw":[100,100,100,94,100,100,100,100,100,100]}

00:33:33.750 --> 00:33:35.700
<v Speaker 2>little bit easier for people to use.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:42.210 --> 00:33:44.460
<v Speaker 2>And again, when I first did it, I didn't have

NOTE CONF {"raw":[100,100,98,99,100,100,100,100,100,100]}

00:33:44.460 --> 00:33:45.870
<v Speaker 2>that notation available.

NOTE CONF {"raw":[100,100,100]}

00:33:45.870 --> 00:33:48.120
<v Speaker 2>So I just wrote things out in this way or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:48.120 --> 00:33:48.840
<v Speaker 2>this way.

NOTE CONF {"raw":[100,100]}

00:33:48.840 --> 00:33:52.080
<v Speaker 2>Again, I could just define it for myself because Haskell's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:52.080 --> 00:33:53.040
<v Speaker 2>that powerful.

NOTE CONF {"raw":[100,100]}

00:33:53.610 --> 00:33:56.070
<v Speaker 2>So it doesn't always give you the exact syntax you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:56.070 --> 00:33:58.950
<v Speaker 2>want, but can give you the exact concept that you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:58.950 --> 00:33:59.490
<v Speaker 2>want.

NOTE CONF {"raw":[100]}

00:34:04.590 --> 00:34:08.520
<v Speaker 2>Um, so in fact, do notation and comprehensions are very

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:08.520 --> 00:34:09.240
<v Speaker 2>similar.

NOTE CONF {"raw":[100]}

00:34:10.050 --> 00:34:13.740
<v Speaker 2>So here let's form all pairs where the first component

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:13.740 --> 00:34:14.610
<v Speaker 2>is less than the second.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:14.610 --> 00:34:17.790
<v Speaker 2>So that would be all pairs I j where I

NOTE CONF {"raw":[100,100,100,100,100,100,84,84,100,100]}

00:34:17.790 --> 00:34:21.419
<v Speaker 2>is drawn from the list one to n j is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:34:21.419 --> 00:34:24.629
<v Speaker 2>drawn from the list I plus one up to n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:26.730 --> 00:34:26.970
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:34:26.970 --> 00:34:28.590
<v Speaker 2>So if we think about pairs of four is going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:28.590 --> 00:34:32.850
<v Speaker 2>to be one two, 1314 and then 2324 and then

NOTE CONF {"raw":[100,100,100,92,100,100,100,100,100,100]}

00:34:32.850 --> 00:34:36.780
<v Speaker 2>three fourths all pairs where the first component is strictly

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:36.780 --> 00:34:38.580
<v Speaker 2>less than the second component.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:42.570 --> 00:34:46.620
<v Speaker 2>Um, but a different way of defining that is I

NOTE CONF {"raw":[51,100,100,100,100,100,100,100,100,100]}

00:34:46.620 --> 00:34:49.740
<v Speaker 2>could use the list monad and use do notation.

NOTE CONF {"raw":[100,100,100,100,100,100,94,100,100]}

00:34:49.740 --> 00:34:52.950
<v Speaker 2>I could say do I drawn from one to n

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:53.159 --> 00:34:56.730
<v Speaker 2>j drawn from I plus one up to n, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:56.730 --> 00:34:58.170
<v Speaker 2>then return ij.

NOTE CONF {"raw":[100,100,74]}

00:34:58.170 --> 00:35:07.050
<v Speaker 2>So very important thing about um bind in monads, about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:08.490 --> 00:35:14.040
<v Speaker 2>guards, in list comprehensions and about do notation is the

NOTE CONF {"raw":[100,100,100,100,100,100,87,100,100,100]}

00:35:14.040 --> 00:35:16.560
<v Speaker 2>thing that you bind in the first one can be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:16.560 --> 00:35:17.880
<v Speaker 2>used in the second one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:19.300 --> 00:35:22.480
<v Speaker 2>So the way we get that in, um.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:35:28.750 --> 00:35:31.780
<v Speaker 2>The way we get that out of bind is because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:31.780 --> 00:35:34.570
<v Speaker 2>the second thing pass to bind is a function.

NOTE CONF {"raw":[100,100,100,46,64,100,100,100,100]}

00:35:34.570 --> 00:35:36.970
<v Speaker 2>It can use the value returned by the first one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:37.810 --> 00:35:40.330
<v Speaker 2>So this idea that whatever you do in the first

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:40.330 --> 00:35:44.320
<v Speaker 2>one can be referred to in the second one is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:44.470 --> 00:35:47.830
<v Speaker 2>one reason why monads are so powerful.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:53.980 --> 00:35:54.730
<v Speaker 2>So you see.

NOTE CONF {"raw":[100,100,99]}

00:35:55.180 --> 00:35:55.540
<v Speaker 2>Right.

NOTE CONF {"raw":[74]}

00:35:55.540 --> 00:35:58.720
<v Speaker 2>So here I've done for a particular list comprehension.

NOTE CONF {"raw":[92,100,100,100,100,100,100,100,100]}

00:35:58.720 --> 00:36:01.090
<v Speaker 2>But you could see that you could always change a

NOTE CONF {"raw":[100,100,97,100,100,100,100,100,100,100]}

00:36:01.090 --> 00:36:05.680
<v Speaker 2>list comprehension into do notation, just each drawn from turns

NOTE CONF {"raw":[100,100,87,79,100,100,100,100,100,100]}

00:36:05.680 --> 00:36:06.790
<v Speaker 2>into a bind.

NOTE CONF {"raw":[100,100,100]}

00:36:06.790 --> 00:36:09.970
<v Speaker 2>And then the thing at the beginning turns into return

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:09.970 --> 00:36:11.050
<v Speaker 2>of that thing.

NOTE CONF {"raw":[100,100,100]}

00:36:11.920 --> 00:36:17.260
<v Speaker 2>So bind bind bind bind bind bind return Return to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,98]}

00:36:17.260 --> 00:36:17.680
<v Speaker 2>value.

NOTE CONF {"raw":[100]}

00:36:17.680 --> 00:36:17.920
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:17.920 --> 00:36:18.130
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:18.130 --> 00:36:18.790
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:19.030 --> 00:36:19.450
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:19.450 --> 00:36:19.660
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:19.660 --> 00:36:20.110
<v Speaker 2>Bind.

NOTE CONF {"raw":[100]}

00:36:20.110 --> 00:36:20.650
<v Speaker 2>Return.

NOTE CONF {"raw":[100]}

00:36:21.340 --> 00:36:25.150
<v Speaker 2>And this is right here I and J makes use

NOTE CONF {"raw":[100,100,100,100,100,100,100,90,100,100]}

00:36:25.150 --> 00:36:27.880
<v Speaker 2>of things bound here to the right of it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:36:28.090 --> 00:36:30.340
<v Speaker 2>Here we read from left strictly from left to right.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:30.340 --> 00:36:32.800
<v Speaker 2>So we only use things have been bound earlier.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:36:32.800 --> 00:36:35.890
<v Speaker 2>So that's slightly easier from an engineering point of view.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:38.560 --> 00:36:39.640
<v Speaker 2>No question yet.

NOTE CONF {"raw":[100,73,97]}

00:36:39.640 --> 00:36:41.350
<v Speaker 2>Come on somebody ask a question.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:44.800 --> 00:36:46.450
<v Speaker 2>If you don't ask a question I'm going to have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:46.450 --> 00:36:48.220
<v Speaker 2>to show you how parsers work.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:49.420 --> 00:36:49.600
<v Speaker 2>Right.

NOTE CONF {"raw":[96]}

00:36:49.600 --> 00:36:50.440
<v Speaker 2>Do people want to see.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:50.440 --> 00:36:51.130
<v Speaker 2>Yes.

NOTE CONF {"raw":[100]}

00:36:56.590 --> 00:36:57.610
<v Speaker 0>Where's the function.

NOTE CONF {"raw":[99,99,95]}

00:36:57.610 --> 00:36:57.850
<v Speaker 2>Now?

NOTE CONF {"raw":[66]}

00:36:59.050 --> 00:37:02.890
<v Speaker 2>Where is the function in in here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:37:05.260 --> 00:37:07.090
<v Speaker 2>So I just speak a little louder because you're far

NOTE CONF {"raw":[100,88,100,100,100,100,100,100,100,100]}

00:37:07.090 --> 00:37:07.570
<v Speaker 2>away.

NOTE CONF {"raw":[100]}

00:37:10.060 --> 00:37:11.380
<v Speaker 2>Ah right.

NOTE CONF {"raw":[31,100]}

00:37:11.380 --> 00:37:14.980
<v Speaker 2>So here this is going to turn into use of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,51,100]}

00:37:14.980 --> 00:37:15.590
<v Speaker 2>bind.

NOTE CONF {"raw":[76]}

00:37:15.620 --> 00:37:16.700
<v Speaker 2>So what function is it?

NOTE CONF {"raw":[88,100,100,100,100]}

00:37:16.730 --> 00:37:19.820
<v Speaker 2>So the answer is it's the function lambda I followed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:19.820 --> 00:37:23.810
<v Speaker 2>by du of all of this okay.

NOTE CONF {"raw":[100,100,100,100,100,100,93]}

00:37:24.290 --> 00:37:27.050
<v Speaker 2>And it went by pretty quickly.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:27.350 --> 00:37:30.950
<v Speaker 2>But that's exactly what's written here.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:30.950 --> 00:37:33.920
<v Speaker 2>So when we write x drawn from e1 that means

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:33.920 --> 00:37:36.410
<v Speaker 2>e1 bind lambda x1.

NOTE CONF {"raw":[100,100,100,94]}

00:37:36.410 --> 00:37:40.250
<v Speaker 2>And then the translation of all the rest of that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:41.420 --> 00:37:41.630
<v Speaker 0>Right.

NOTE CONF {"raw":[61]}

00:37:42.260 --> 00:37:42.560
<v Speaker 2>Right.

NOTE CONF {"raw":[78]}

00:37:42.560 --> 00:37:43.520
<v Speaker 2>Good question.

NOTE CONF {"raw":[100,100]}

00:37:43.730 --> 00:37:44.420
<v Speaker 2>Excellent.

NOTE CONF {"raw":[87]}

00:37:44.450 --> 00:37:45.950
<v Speaker 2>Any other questions?

NOTE CONF {"raw":[100,100,100]}

00:37:48.620 --> 00:37:49.160
<v Speaker 2>Yeah.

NOTE CONF {"raw":[100]}

00:37:50.450 --> 00:37:51.590
<v Speaker 2>How do parsers work.

NOTE CONF {"raw":[100,77,100,100]}

00:37:51.590 --> 00:37:52.370
<v Speaker 2>All right.

NOTE CONF {"raw":[100,100]}

00:37:54.200 --> 00:37:56.510
<v Speaker 2>So now we've got the monad of lists.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:37:57.440 --> 00:38:00.740
<v Speaker 2>Oh I need to show you one other thing before

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:00.950 --> 00:38:06.200
<v Speaker 2>I show you parsers, which is there's some other things

NOTE CONF {"raw":[77,100,100,100,100,100,63,100,100,100]}

00:38:06.200 --> 00:38:07.850
<v Speaker 2>that you often find in a monad.

NOTE CONF {"raw":[100,100,100,100,100,90,87]}

00:38:07.850 --> 00:38:11.000
<v Speaker 2>So you often find a monad with a plus.

NOTE CONF {"raw":[83,94,100,100,100,100,100,100,100]}

00:38:11.300 --> 00:38:14.990
<v Speaker 2>So, um, these things form a monoid right?

NOTE CONF {"raw":[100,93,100,100,100,100,100,95]}

00:38:14.990 --> 00:38:17.930
<v Speaker 2>M0 is the unit m plus is the O plus.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,100]}

00:38:18.650 --> 00:38:21.110
<v Speaker 2>So M0 is just an m of A for arbitrary.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:21.140 --> 00:38:24.170
<v Speaker 2>A m plus takes two mas and gives us an

NOTE CONF {"raw":[100,97,100,100,99,99,100,100,100,100]}

00:38:24.170 --> 00:38:24.770
<v Speaker 2>Ma.

NOTE CONF {"raw":[100]}

00:38:24.920 --> 00:38:30.350
<v Speaker 2>And again um lists form a monad plus where m0

NOTE CONF {"raw":[100,100,100,99,100,94,100,100,100,100]}

00:38:30.350 --> 00:38:33.800
<v Speaker 2>is the empty list and m plus is concatenate.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:38:35.060 --> 00:38:35.930
<v Speaker 2>And the important.

NOTE CONF {"raw":[100,100,100]}

00:38:36.380 --> 00:38:39.140
<v Speaker 2>The important thing is that for any monad with plus

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:39.140 --> 00:38:40.910
<v Speaker 2>we can then define guard.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:42.230 --> 00:38:46.340
<v Speaker 2>So guard takes a bool and returns an m of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:46.340 --> 00:38:47.540
<v Speaker 2>the unit type again.

NOTE CONF {"raw":[100,100,100,100]}

00:38:47.540 --> 00:38:48.950
<v Speaker 2>So it only has a side effect.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:48.950 --> 00:38:50.990
<v Speaker 2>It doesn't return an interesting value.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:51.020 --> 00:38:54.770
<v Speaker 2>What we do is guard a false is M0 guard

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,90,100]}

00:38:54.770 --> 00:38:55.250
<v Speaker 2>of trues.

NOTE CONF {"raw":[100,38]}

00:38:55.250 --> 00:38:58.610
<v Speaker 2>Do nothing, just return the one thing you can return.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:59.780 --> 00:39:04.070
<v Speaker 2>We could also find m some, which takes a list

NOTE CONF {"raw":[100,50,100,100,98,100,100,100,100,100]}

00:39:04.070 --> 00:39:07.040
<v Speaker 2>of ma to an ma, and does that by doing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:07.040 --> 00:39:10.460
<v Speaker 2>a folder with m plus and m0.

NOTE CONF {"raw":[100,100,100,100,100,100,95]}

00:39:16.640 --> 00:39:18.290
<v Speaker 2>And one special case.

NOTE CONF {"raw":[100,100,100,100]}

00:39:23.930 --> 00:39:24.290
<v Speaker 2>Now.

NOTE CONF {"raw":[74]}

00:39:25.400 --> 00:39:29.840
<v Speaker 2>Um, so guards are very useful because they let you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:29.840 --> 00:39:31.070
<v Speaker 2>put conditions right.

NOTE CONF {"raw":[100,100,100]}

00:39:31.760 --> 00:39:34.700
<v Speaker 2>This generalises the notion of a guard from a list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:34.700 --> 00:39:37.280
<v Speaker 2>comprehension to an arbitrary monad.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:39.470 --> 00:39:41.420
<v Speaker 2>So now we could put a guard in there.

NOTE CONF {"raw":[100,100,100,85,100,100,100,100,100]}

00:39:41.420 --> 00:39:44.690
<v Speaker 2>So now I'm doing something like before, except just a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:44.690 --> 00:39:47.150
<v Speaker 2>different way of writing the same thing I drawn from

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:39:47.150 --> 00:39:49.910
<v Speaker 2>one to n j, drawn from one to n, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:50.000 --> 00:39:52.610
<v Speaker 2>have the condition that I should be less than j.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:53.240 --> 00:39:55.310
<v Speaker 2>So we would write that as I drawn from one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:55.310 --> 00:39:58.250
<v Speaker 2>to n j drawn from one to n guard I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:58.250 --> 00:40:01.490
<v Speaker 2>less than j, and then return I j.

NOTE CONF {"raw":[100,100,100,100,100,100,63,63]}

00:40:01.520 --> 00:40:05.330
<v Speaker 2>So this maps down to this, this maps down to

NOTE CONF {"raw":[100,100,99,100,100,100,100,100,100,100]}

00:40:05.330 --> 00:40:05.930
<v Speaker 2>this.

NOTE CONF {"raw":[100]}

00:40:06.380 --> 00:40:11.150
<v Speaker 2>And again this is going to return, uh, all pairs

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:11.150 --> 00:40:13.920
<v Speaker 2>where the first component is less than the second component.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:18.060 --> 00:40:18.720
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:40:19.200 --> 00:40:21.570
<v Speaker 2>Now I can answer your question.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:24.720 --> 00:40:30.300
<v Speaker 2>So a parser of type A, basically what we want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:30.300 --> 00:40:32.250
<v Speaker 2>to do is take a string and return a value

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:32.250 --> 00:40:33.090
<v Speaker 2>of type A.

NOTE CONF {"raw":[100,100,100]}

00:40:33.660 --> 00:40:36.840
<v Speaker 2>And for the top level that's fine.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:40:37.350 --> 00:40:40.320
<v Speaker 2>But if you think about it, when we're parsing something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:40.320 --> 00:40:42.420
<v Speaker 2>as we go through parsing, it will parse the first

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:40:42.420 --> 00:40:42.840
<v Speaker 2>bit.

NOTE CONF {"raw":[100]}

00:40:42.840 --> 00:40:44.760
<v Speaker 2>So we'll read some of the input and there'll be

NOTE CONF {"raw":[100,71,100,100,100,100,100,100,86,100]}

00:40:44.760 --> 00:40:46.050
<v Speaker 2>some input left.

NOTE CONF {"raw":[100,100,100]}

00:40:46.050 --> 00:40:47.550
<v Speaker 2>And then we'll parse the second bit.

NOTE CONF {"raw":[100,100,100,100,100,100,98]}

00:40:47.550 --> 00:40:49.290
<v Speaker 2>So we'll read that bit of input and there'll be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,58,100]}

00:40:49.290 --> 00:40:51.660
<v Speaker 2>some input left and so on.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:52.020 --> 00:40:54.330
<v Speaker 2>So you might think of it as something that okay

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:54.330 --> 00:40:57.090
<v Speaker 2>we give it the input, we return the value that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:57.090 --> 00:41:01.410
<v Speaker 2>we parsed and whatever bit of the input we did

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:01.410 --> 00:41:02.580
<v Speaker 2>not read yet.

NOTE CONF {"raw":[100,100,100]}

00:41:04.200 --> 00:41:04.860
<v Speaker 2>Okay.

NOTE CONF {"raw":[100]}

00:41:05.760 --> 00:41:11.580
<v Speaker 2>So this I have defined a side effect within Haskell

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:11.580 --> 00:41:12.450
<v Speaker 2>itself.

NOTE CONF {"raw":[100]}

00:41:12.900 --> 00:41:16.560
<v Speaker 2>So just using pure Haskell, no notion of side effect.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:16.560 --> 00:41:18.300
<v Speaker 2>This is my input string.

NOTE CONF {"raw":[100,100,100,100,100]}

00:41:18.570 --> 00:41:21.510
<v Speaker 2>This is the remainder of the input string after I've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:21.510 --> 00:41:22.560
<v Speaker 2>read some of it.

NOTE CONF {"raw":[100,100,100,100]}

00:41:22.980 --> 00:41:28.830
<v Speaker 2>In general you can simulate arbitrary state in this way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:28.830 --> 00:41:31.080
<v Speaker 2>So one kind of monad which I won't go into

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:31.080 --> 00:41:34.440
<v Speaker 2>today is the state monad, which lets you pass around

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:34.440 --> 00:41:36.660
<v Speaker 2>an arbitrary data type as state.

NOTE CONF {"raw":[100,100,100,100,57,100]}

00:41:36.660 --> 00:41:38.460
<v Speaker 2>Your state can be whatever you want.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:41:38.460 --> 00:41:42.210
<v Speaker 2>If you're playing, um, checkers it the state might be

NOTE CONF {"raw":[100,100,100,98,100,85,100,100,100,100]}

00:41:42.210 --> 00:41:44.220
<v Speaker 2>what's on the checkerboard currently.

NOTE CONF {"raw":[100,100,100,100,100]}

00:41:45.240 --> 00:41:45.450
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:41:45.450 --> 00:41:49.020
<v Speaker 2>But we've learned about everything in terms of pure functions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:49.020 --> 00:41:49.560
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:41:49.590 --> 00:41:50.430
<v Speaker 2>In the world.

NOTE CONF {"raw":[100,100,100]}

00:41:50.430 --> 00:41:50.670
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:41:50.670 --> 00:41:53.700
<v Speaker 2>You can the state is that this is in this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:53.700 --> 00:41:54.480
<v Speaker 2>place on the desk.

NOTE CONF {"raw":[100,100,100,100]}

00:41:54.480 --> 00:41:56.550
<v Speaker 2>I can pick it up and put it on that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:56.550 --> 00:41:57.630
<v Speaker 2>place on the desk.

NOTE CONF {"raw":[100,100,100,100]}

00:41:57.660 --> 00:42:00.780
<v Speaker 2>So for modelling the real world, having some notion of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:00.780 --> 00:42:02.100
<v Speaker 2>state can be useful.

NOTE CONF {"raw":[100,100,100,100]}

00:42:02.490 --> 00:42:04.020
<v Speaker 2>This is how you do it.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:04.140 --> 00:42:08.880
<v Speaker 2>Input state whatever value you want to compute paired with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:08.880 --> 00:42:10.260
<v Speaker 2>the output state.

NOTE CONF {"raw":[100,100,100]}

00:42:10.800 --> 00:42:14.280
<v Speaker 2>So Haskell is powerful enough that you can build into

NOTE CONF {"raw":[100,99,100,100,100,100,100,100,100,100]}

00:42:14.280 --> 00:42:16.890
<v Speaker 2>it modelling arbitrary states.

NOTE CONF {"raw":[100,98,100,100]}

00:42:16.980 --> 00:42:19.170
<v Speaker 2>So our state is going to be the bit of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:19.170 --> 00:42:23.910
<v Speaker 2>the string we haven't read yet, except for one thing.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:24.960 --> 00:42:27.030
<v Speaker 2>Parser doesn't always work, does it?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:27.180 --> 00:42:30.000
<v Speaker 2>And sometimes we've got arbitrary parses, and we're going to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:30.000 --> 00:42:32.010
<v Speaker 2>try them and pick the one that works.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:32.610 --> 00:42:35.070
<v Speaker 2>So we need to have some way of saying this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:35.070 --> 00:42:36.480
<v Speaker 2>parse didn't work.

NOTE CONF {"raw":[96,100,100]}

00:42:36.510 --> 00:42:39.120
<v Speaker 2>Or even for an ambiguous string.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:39.120 --> 00:42:41.250
<v Speaker 2>There might be multiple ways of parsing it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:41.430 --> 00:42:43.890
<v Speaker 2>So we might want to say here are three possible

NOTE CONF {"raw":[100,91,100,100,100,100,100,100,100,100]}

00:42:43.890 --> 00:42:44.280
<v Speaker 2>parses.

NOTE CONF {"raw":[98]}

00:42:44.280 --> 00:42:46.410
<v Speaker 2>So it's very important to be able to say no

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:42:46.410 --> 00:42:47.220
<v Speaker 2>parses.

NOTE CONF {"raw":[100]}

00:42:47.220 --> 00:42:48.630
<v Speaker 2>It did not work.

NOTE CONF {"raw":[100,100,100,100]}

00:42:48.900 --> 00:42:51.720
<v Speaker 2>Or to be able to say, well actually it worked

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:51.720 --> 00:42:52.440
<v Speaker 2>really well.

NOTE CONF {"raw":[100,100]}

00:42:52.440 --> 00:42:54.030
<v Speaker 2>Here are three different parses.

NOTE CONF {"raw":[100,100,100,100,100]}

00:42:54.030 --> 00:42:55.440
<v Speaker 2>Pick the one you like.

NOTE CONF {"raw":[100,100,100,100,100]}

00:42:56.010 --> 00:42:58.530
<v Speaker 2>So what we're going to do instead of just take

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:58.530 --> 00:43:02.400
<v Speaker 2>returning a value and the new state will take the

NOTE CONF {"raw":[100,100,100,100,100,100,100,86,100,100]}

00:43:02.400 --> 00:43:08.590
<v Speaker 2>input state and return pairs of the value we passed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,72]}

00:43:08.590 --> 00:43:11.350
<v Speaker 2>and the remaining state.

NOTE CONF {"raw":[100,100,100,100]}

00:43:11.350 --> 00:43:13.690
<v Speaker 2>And there will be a list of these things.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:43:15.100 --> 00:43:19.690
<v Speaker 2>And just as Haskell is powerful enough to model the

NOTE CONF {"raw":[100,100,100,91,91,100,100,100,100,100]}

00:43:19.690 --> 00:43:20.920
<v Speaker 2>notion of state.

NOTE CONF {"raw":[100,100,100]}

00:43:20.950 --> 00:43:23.950
<v Speaker 2>This shows us that Haskell is powerful enough to model

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:23.950 --> 00:43:26.710
<v Speaker 2>the notion of nondeterminism.

NOTE CONF {"raw":[100,100,100,58]}

00:43:27.280 --> 00:43:30.340
<v Speaker 2>We're going to do a kind of angelic nondeterminism.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,60]}

00:43:30.760 --> 00:43:33.640
<v Speaker 2>But you learned about non-deterministic state machines.

NOTE CONF {"raw":[100,89,100,100,65,100,100]}

00:43:33.670 --> 00:43:35.830
<v Speaker 2>This is how we modelled it, by having a list

NOTE CONF {"raw":[100,100,100,100,99,46,100,100,100,100]}

00:43:35.830 --> 00:43:39.910
<v Speaker 2>of results and the remaining, um, parsed, um, string going

NOTE CONF {"raw":[100,100,100,100,100,85,96,71,100,100]}

00:43:39.910 --> 00:43:40.990
<v Speaker 2>into the automaton.

NOTE CONF {"raw":[100,100,100]}

00:43:40.990 --> 00:43:45.160
<v Speaker 2>So we did exactly this before for nondeterministic automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,63,100]}

00:43:46.090 --> 00:43:48.580
<v Speaker 2>See, we take a string and we'll return a list

NOTE CONF {"raw":[63,100,100,100,100,100,100,100,98,100]}

00:43:48.580 --> 00:43:50.710
<v Speaker 2>of parse string pairs.

NOTE CONF {"raw":[100,95,100,100]}

00:43:50.740 --> 00:43:53.530
<v Speaker 2>And my colleague Graham Hutton turned this into a little

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:43:53.530 --> 00:43:54.250
<v Speaker 2>poem.

NOTE CONF {"raw":[100]}

00:43:54.370 --> 00:43:57.790
<v Speaker 2>A parser for things is a function from strings to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:57.790 --> 00:44:01.870
<v Speaker 2>lists of pairs of things and strings, not Doctor Zeus.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:01.900 --> 00:44:02.710
<v Speaker 2>Graham Houghton.

NOTE CONF {"raw":[98,50]}

00:44:08.410 --> 00:44:11.170
<v Speaker 2>Um, so we're going to find a module.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:44:11.320 --> 00:44:13.720
<v Speaker 2>We want parser to be an abstract type.

NOTE CONF {"raw":[88,100,91,100,100,100,100,100]}

00:44:13.720 --> 00:44:16.420
<v Speaker 2>So I just defined a data type a parser of

NOTE CONF {"raw":[100,100,100,93,100,100,100,100,100,100]}

00:44:16.420 --> 00:44:17.080
<v Speaker 2>a.

NOTE CONF {"raw":[100]}

00:44:17.260 --> 00:44:20.920
<v Speaker 2>This is a type constructor also named parser.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:44:21.340 --> 00:44:21.760
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:44:21.760 --> 00:44:24.220
<v Speaker 2>And just as the fourth string goes to the list

NOTE CONF {"raw":[100,100,100,73,60,100,100,100,54,100]}

00:44:24.220 --> 00:44:26.080
<v Speaker 2>of a string pairs.

NOTE CONF {"raw":[100,100,100,100]}

00:44:26.320 --> 00:44:28.420
<v Speaker 2>And then to apply a parser, we take a parser

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:28.420 --> 00:44:30.910
<v Speaker 2>of f and s and we just write apply f

NOTE CONF {"raw":[100,71,71,71,100,100,100,100,100,100]}

00:44:30.910 --> 00:44:32.770
<v Speaker 2>to s, and we get this list of a string

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:32.770 --> 00:44:33.460
<v Speaker 2>pairs.

NOTE CONF {"raw":[100]}

00:44:36.880 --> 00:44:40.750
<v Speaker 2>Um, and in particular what parse is going to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:41.500 --> 00:44:44.020
<v Speaker 2>Um, this is what you do for a successful parse.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:44.020 --> 00:44:47.380
<v Speaker 2>It applies the thing gets the list, checks that we've

NOTE CONF {"raw":[100,100,94,100,100,100,100,100,100,100]}

00:44:47.380 --> 00:44:50.860
<v Speaker 2>parsed the whole thing, and then returns the head of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:50.860 --> 00:44:51.550
<v Speaker 2>the list.

NOTE CONF {"raw":[100,100]}

00:44:51.550 --> 00:44:54.220
<v Speaker 2>So this succeeds if you parse the whole thing.

NOTE CONF {"raw":[100,100,100,100,61,63,100,100,100]}

00:44:54.220 --> 00:44:56.020
<v Speaker 2>And there is exactly one parse.

NOTE CONF {"raw":[100,100,67,100,100,100]}

00:44:56.080 --> 00:44:59.020
<v Speaker 2>So if you parse the whole input and was unambiguous,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:59.020 --> 00:45:00.880
<v Speaker 2>parse will return the result.

NOTE CONF {"raw":[89,100,100,100,100]}

00:45:05.410 --> 00:45:09.220
<v Speaker 2>So now we need to return, define return and bind.

NOTE CONF {"raw":[100,100,100,100,100,100,52,100,100,100]}

00:45:11.530 --> 00:45:15.940
<v Speaker 2>So return as a parser that takes the um un

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,50]}

00:45:15.940 --> 00:45:19.150
<v Speaker 2>parsed input and returns the value x and all the

NOTE CONF {"raw":[97,100,100,100,100,100,94,100,100,100]}

00:45:19.150 --> 00:45:21.340
<v Speaker 2>UN parsed inputs so it doesn't change the state at

NOTE CONF {"raw":[100,100,71,92,100,100,100,100,100,100]}

00:45:21.340 --> 00:45:21.910
<v Speaker 2>all.

NOTE CONF {"raw":[100]}

00:45:22.330 --> 00:45:24.730
<v Speaker 2>And m followed by k is.

NOTE CONF {"raw":[99,100,100,100,100,100]}

00:45:24.730 --> 00:45:29.350
<v Speaker 2>Take the current state, apply M to S, so that'll

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,90]}

00:45:29.350 --> 00:45:31.360
<v Speaker 2>give us a list of XT pairs.

NOTE CONF {"raw":[100,100,100,100,100,66,100]}

00:45:31.510 --> 00:45:33.160
<v Speaker 2>So x is our values.

NOTE CONF {"raw":[100,100,100,100,100]}

00:45:33.160 --> 00:45:35.890
<v Speaker 2>We apply k to x and then we apply that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:35.890 --> 00:45:38.080
<v Speaker 2>to t the new state.

NOTE CONF {"raw":[100,100,100,100,100]}

00:45:38.080 --> 00:45:41.440
<v Speaker 2>So original state we get a value and a new

NOTE CONF {"raw":[100,100,100,90,100,100,100,100,100,100]}

00:45:41.440 --> 00:45:46.330
<v Speaker 2>state apply k to k of x gives us our

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:46.330 --> 00:45:47.380
<v Speaker 2>new parser.

NOTE CONF {"raw":[100,100]}

00:45:47.380 --> 00:45:49.270
<v Speaker 2>Apply that in state T, get out.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:49.270 --> 00:45:52.780
<v Speaker 2>Finally, state u and return the final value of y

NOTE CONF {"raw":[100,100,88,100,98,100,100,100,100,100]}

00:45:52.780 --> 00:45:54.820
<v Speaker 2>and the final state U.

NOTE CONF {"raw":[100,100,100,100,95]}

00:45:59.650 --> 00:46:04.300
<v Speaker 2>And it's also very helpful to have a monad plus

NOTE CONF {"raw":[100,100,100,100,100,100,100,60,100,100]}

00:46:04.730 --> 00:46:05.270
<v Speaker 2>right?

NOTE CONF {"raw":[77]}

00:46:05.270 --> 00:46:08.450
<v Speaker 2>M0 is the parser that always fails.

NOTE CONF {"raw":[99,100,100,98,100,100,100]}

00:46:10.970 --> 00:46:11.420
<v Speaker 2>Right.

NOTE CONF {"raw":[91]}

00:46:11.810 --> 00:46:14.210
<v Speaker 2>Return is the parser that always succeeds.

NOTE CONF {"raw":[100,90,100,100,100,100,100]}

00:46:14.240 --> 00:46:17.900
<v Speaker 2>M0 is the parts of the always fails, and plus

NOTE CONF {"raw":[100,100,100,82,100,100,100,100,100,100]}

00:46:17.900 --> 00:46:23.960
<v Speaker 2>is parse m parse n combine the results.

NOTE CONF {"raw":[100,100,93,100,100,100,100,100]}

00:46:24.140 --> 00:46:27.200
<v Speaker 2>This is very important because if this one fails, it'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,57]}

00:46:27.200 --> 00:46:28.190
<v Speaker 2>give you this one.

NOTE CONF {"raw":[100,100,100,100]}

00:46:28.430 --> 00:46:30.980
<v Speaker 2>If this one fails, it will give you this one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:31.280 --> 00:46:34.040
<v Speaker 2>So you have two passes and you want two passes

NOTE CONF {"raw":[100,100,100,100,43,99,100,100,100,76]}

00:46:34.040 --> 00:46:35.300
<v Speaker 2>that you might want to apply.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:46:35.330 --> 00:46:36.740
<v Speaker 2>It lets you choose.

NOTE CONF {"raw":[100,100,100,100]}

00:46:41.360 --> 00:46:46.970
<v Speaker 2>So just parse a given one character is very easy

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:47.510 --> 00:46:47.810
<v Speaker 2>right?

NOTE CONF {"raw":[100]}

00:46:47.810 --> 00:46:51.260
<v Speaker 2>You'll be given your state is C followed by S,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:51.560 --> 00:46:57.380
<v Speaker 2>and just return um the value c paired with the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:57.380 --> 00:46:58.880
<v Speaker 2>remaining state's.

NOTE CONF {"raw":[100,100]}

00:46:58.880 --> 00:47:01.310
<v Speaker 2>So we take the first character off of the input

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:01.310 --> 00:47:01.940
<v Speaker 2>state.

NOTE CONF {"raw":[100]}

00:47:02.480 --> 00:47:05.720
<v Speaker 2>Um, return that as our as our value, and the

NOTE CONF {"raw":[99,80,100,100,100,100,100,100,100,100]}

00:47:05.720 --> 00:47:07.910
<v Speaker 2>output state is just the remaining string.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:08.420 --> 00:47:12.680
<v Speaker 2>And then spot takes a predicate over characters and it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,83]}

00:47:12.680 --> 00:47:15.980
<v Speaker 2>going to succeed if the character we read satisfies that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:15.980 --> 00:47:16.490
<v Speaker 2>predicate.

NOTE CONF {"raw":[100]}

00:47:16.490 --> 00:47:18.830
<v Speaker 2>So this is just like this.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:18.830 --> 00:47:21.800
<v Speaker 2>If the list is empty, fail here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:21.800 --> 00:47:25.790
<v Speaker 2>Also, if the list is empty, fail if it's non-empty

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,80]}

00:47:26.450 --> 00:47:29.300
<v Speaker 2>and p of C holds, then return the key pair

NOTE CONF {"raw":[100,100,100,95,100,100,88,100,32,100]}

00:47:29.300 --> 00:47:30.920
<v Speaker 2>and otherwise fail.

NOTE CONF {"raw":[100,100,100]}

00:47:31.160 --> 00:47:34.460
<v Speaker 2>And then token says read a particular character.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:47:34.460 --> 00:47:36.740
<v Speaker 2>That's just spot for equal c.

NOTE CONF {"raw":[100,100,100,100,88,93]}

00:47:37.160 --> 00:47:39.200
<v Speaker 2>So like if I want to read an open bracket,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:39.200 --> 00:47:41.750
<v Speaker 2>that would just be token open closed.

NOTE CONF {"raw":[100,100,100,100,100,100,86]}

00:47:42.260 --> 00:47:47.330
<v Speaker 2>Um quote open parentheses which is spot of equal of

NOTE CONF {"raw":[83,100,100,50,100,100,100,100,100,100]}

00:47:47.330 --> 00:47:48.500
<v Speaker 2>open parenthesis.

NOTE CONF {"raw":[100,66]}

00:47:53.390 --> 00:47:56.840
<v Speaker 2>And then matching an entire given string more than one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:56.840 --> 00:47:58.610
<v Speaker 2>character would just be.

NOTE CONF {"raw":[100,100,100,100]}

00:47:58.610 --> 00:48:01.340
<v Speaker 2>Well the first one must be x.

NOTE CONF {"raw":[100,100,100,100,100,100,83]}

00:48:01.520 --> 00:48:05.220
<v Speaker 2>The remainder much match XS and then we return that.

NOTE CONF {"raw":[94,100,100,91,51,100,100,100,100,100]}

00:48:06.240 --> 00:48:08.970
<v Speaker 2>And notice that when we do a token, the character

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:08.970 --> 00:48:12.510
<v Speaker 2>we return is the one that we had to have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:12.510 --> 00:48:12.960
<v Speaker 2>read.

NOTE CONF {"raw":[58]}

00:48:16.260 --> 00:48:21.090
<v Speaker 2>And now we can do interesting things like parse um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,100]}

00:48:21.090 --> 00:48:23.070
<v Speaker 2>zero or more things.

NOTE CONF {"raw":[100,100,100,100]}

00:48:23.460 --> 00:48:26.730
<v Speaker 2>So if plus is one or more things than we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:26.730 --> 00:48:30.900
<v Speaker 2>do plus of p m plus return empty.

NOTE CONF {"raw":[100,100,62,100,100,100,100,100]}

00:48:32.130 --> 00:48:35.400
<v Speaker 2>So it might return one or more things, or it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:35.400 --> 00:48:36.930
<v Speaker 2>might be returned to the empty list.

NOTE CONF {"raw":[100,100,100,95,100,100,100]}

00:48:36.930 --> 00:48:38.250
<v Speaker 2>It parsed nothing at all.

NOTE CONF {"raw":[100,100,100,100,100]}

00:48:38.880 --> 00:48:42.210
<v Speaker 2>And then plus of P is going to be read

NOTE CONF {"raw":[100,100,100,84,100,100,100,100,100,100]}

00:48:42.210 --> 00:48:46.950
<v Speaker 2>a p, read zero or more things and return the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:46.950 --> 00:48:49.380
<v Speaker 2>list formed by concatenating those together.

NOTE CONF {"raw":[100,62,100,100,100,100]}

00:48:50.550 --> 00:48:55.440
<v Speaker 2>So now I can do interesting stuff like how do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:55.440 --> 00:48:56.940
<v Speaker 2>I parse the natural number?

NOTE CONF {"raw":[100,52,67,100,100]}

00:48:57.120 --> 00:49:01.230
<v Speaker 2>It's just plus of spot of is digit Right.

NOTE CONF {"raw":[69,100,100,74,100,100,100,100,90]}

00:49:02.130 --> 00:49:06.150
<v Speaker 2>One or more digits is going to be a natural.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:07.260 --> 00:49:09.300
<v Speaker 2>And let's just see that at work.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:49:29.490 --> 00:49:33.660
<v Speaker 2>So this defines all the different things that we just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:33.660 --> 00:49:34.260
<v Speaker 2>saw.

NOTE CONF {"raw":[100]}

00:49:37.800 --> 00:49:39.570
<v Speaker 2>And so now I could do.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:49:42.780 --> 00:49:49.920
<v Speaker 2>Apply of plus of is digit.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:49:52.590 --> 00:49:54.180
<v Speaker 2>To 123.

NOTE CONF {"raw":[100,100]}

00:49:54.210 --> 00:49:55.710
<v Speaker 2>A b c d e.

NOTE CONF {"raw":[100,100,100,100,96]}

00:49:57.840 --> 00:49:58.380
<v Speaker 2>What.

NOTE CONF {"raw":[100]}

00:50:01.380 --> 00:50:02.280
<v Speaker 2>Number expect.

NOTE CONF {"raw":[97,92]}

00:50:02.280 --> 00:50:04.350
<v Speaker 2>Oh, I'm not running in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:50:04.500 --> 00:50:05.820
<v Speaker 2>Maybe I should run in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:50:05.820 --> 00:50:06.810
<v Speaker 2>That might be better.

NOTE CONF {"raw":[100,100,100,100]}

00:50:10.500 --> 00:50:10.920
<v Speaker 2>Uh oh.

NOTE CONF {"raw":[100,100]}

00:50:11.460 --> 00:50:12.270
<v Speaker 2>It's broken.

NOTE CONF {"raw":[100,100]}

00:50:14.820 --> 00:50:16.320
<v Speaker 2>Ah, I know what's wrong.

NOTE CONF {"raw":[83,100,100,56,100]}

00:50:19.080 --> 00:50:19.500
<v Speaker 2>That's okay.

NOTE CONF {"raw":[100,100]}

00:50:19.500 --> 00:50:20.640
<v Speaker 2>We're at time.

NOTE CONF {"raw":[100,100,100]}

00:50:20.760 --> 00:50:22.350
<v Speaker 2>No demo for you.

NOTE CONF {"raw":[100,100,100,100]}

00:50:24.180 --> 00:50:24.990
<v Speaker 2>That's okay.

NOTE CONF {"raw":[100,100]}

00:50:25.620 --> 00:50:28.590
<v Speaker 2>Um, but this would, if given the string one, two,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,79]}

00:50:28.590 --> 00:50:31.890
<v Speaker 2>three a, b c, we return a list of a

NOTE CONF {"raw":[100,74,74,74,74,100,100,100,100,100]}

00:50:31.890 --> 00:50:34.770
<v Speaker 2>pair in the first element that the pair is the

NOTE CONF {"raw":[100,60,100,100,92,67,100,99,99,100]}

00:50:34.770 --> 00:50:37.890
<v Speaker 2>number one is the string one, two, three, and the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:37.890 --> 00:50:39.450
<v Speaker 2>remainder would be a b, c.

NOTE CONF {"raw":[100,100,100,88,88,88]}

00:50:42.240 --> 00:50:46.350
<v Speaker 2>And we could generalise that to do expressions right.

NOTE CONF {"raw":[100,100,86,100,100,100,100,100,100]}

00:50:46.350 --> 00:50:49.710
<v Speaker 2>So an expression is either a literal or sum of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,91,100]}

00:50:49.710 --> 00:50:52.290
<v Speaker 2>two expressions or product of two expressions.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:52.650 --> 00:50:55.740
<v Speaker 2>If I want to parse those, I just do parse

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,97]}

00:50:55.740 --> 00:50:57.810
<v Speaker 2>the literal m plus, right?

NOTE CONF {"raw":[97,100,88,100,74]}

00:50:57.810 --> 00:50:59.020
<v Speaker 2>Do one or the other.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:59.140 --> 00:51:05.230
<v Speaker 2>Parsing a sum or partial multiplication and literal is just

NOTE CONF {"raw":[33,100,100,100,99,100,100,100,100,100]}

00:51:05.350 --> 00:51:10.510
<v Speaker 2>passing an integer, and add is read an open parenthesis.

NOTE CONF {"raw":[98,73,100,100,92,100,100,98,100,85]}

00:51:10.510 --> 00:51:13.360
<v Speaker 2>Pass an expression, read a plus.

NOTE CONF {"raw":[51,100,100,100,100,100]}

00:51:13.570 --> 00:51:14.950
<v Speaker 2>Parse an expression.

NOTE CONF {"raw":[72,100,100]}

00:51:14.950 --> 00:51:16.600
<v Speaker 2>Read a close parenthesis.

NOTE CONF {"raw":[100,94,100,98]}

00:51:16.600 --> 00:51:18.790
<v Speaker 2>Return d plus e.

NOTE CONF {"raw":[100,70,70,71]}

00:51:18.820 --> 00:51:23.110
<v Speaker 2>Using our constructor for expressions and model is very similar.

NOTE CONF {"raw":[100,100,100,100,100,100,58,88,100,100]}

00:51:23.110 --> 00:51:24.850
<v Speaker 2>Read an open parenthesis.

NOTE CONF {"raw":[97,97,100,93]}

00:51:26.920 --> 00:51:28.240
<v Speaker 2>Read an expression.

NOTE CONF {"raw":[100,100,100]}

00:51:29.410 --> 00:51:30.490
<v Speaker 2>Read a times.

NOTE CONF {"raw":[100,49,100]}

00:51:30.490 --> 00:51:31.510
<v Speaker 2>Read another expression.

NOTE CONF {"raw":[100,100,100]}

00:51:31.510 --> 00:51:34.420
<v Speaker 2>Read a closed parenthesis and return d times e.

NOTE CONF {"raw":[100,100,49,97,100,100,100,100,100]}

00:51:34.510 --> 00:51:38.800
<v Speaker 2>So you've seen we can build very powerful languages within

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:38.800 --> 00:51:39.430
<v Speaker 2>Haskell.

NOTE CONF {"raw":[100]}

00:51:39.430 --> 00:51:42.520
<v Speaker 2>Here's a language for describing parsers.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:51:47.080 --> 00:51:50.140
<v Speaker 2>And for example if you do parsecs of one two,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:50.140 --> 00:51:52.060
<v Speaker 2>three give you one plus two.

NOTE CONF {"raw":[100,95,100,100,100,100]}

00:51:52.090 --> 00:51:55.390
<v Speaker 2>Sorry one plus two times three gives you one plus

NOTE CONF {"raw":[100,100,100,100,100,100,97,100,100,100]}

00:51:55.390 --> 00:51:56.950
<v Speaker 2>two times three.

NOTE CONF {"raw":[100,100,100]}

00:52:00.010 --> 00:52:00.820
<v Speaker 2>Right.

NOTE CONF {"raw":[100]}

00:52:01.270 --> 00:52:04.900
<v Speaker 2>There's a paper somebody wrote once called A brief, Incomplete

NOTE CONF {"raw":[100,100,100,100,100,73,100,100,100,100]}

00:52:04.900 --> 00:52:08.470
<v Speaker 2>and Mostly Wrong History of Programming Languages, where he poked

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:08.470 --> 00:52:11.470
<v Speaker 2>fun at lots of programming language developers.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:52:12.490 --> 00:52:13.840
<v Speaker 2>One of them was me.

NOTE CONF {"raw":[100,100,100,100,100]}

00:52:15.280 --> 00:52:18.550
<v Speaker 2>So among all these different entries.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:52:18.940 --> 00:52:20.320
<v Speaker 2>One of them said.

NOTE CONF {"raw":[100,100,100,100]}

00:52:22.570 --> 00:52:27.460
<v Speaker 2>So he's got Alonzo Church and Lambda Calculus and Alan

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:27.460 --> 00:52:28.600
<v Speaker 2>Turing and so on.

NOTE CONF {"raw":[100,100,100,100]}

00:52:28.720 --> 00:52:33.430
<v Speaker 2>And this one, in 1990, a committee formed by Simon

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:33.430 --> 00:52:37.690
<v Speaker 2>Peyton Jones, Paul Hudak, Philip Wadler, Ashton Kutcher and people

NOTE CONF {"raw":[96,100,100,100,61,99,100,100,100,100]}

00:52:37.690 --> 00:52:39.880
<v Speaker 2>for the Ethical Treatment of Animals, four of those are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:39.880 --> 00:52:40.540
<v Speaker 2>correct.

NOTE CONF {"raw":[100]}

00:52:41.500 --> 00:52:42.910
<v Speaker 2>Um, creates Haskell.

NOTE CONF {"raw":[98,78,100]}

00:52:44.110 --> 00:52:45.100
<v Speaker 2>Uh oh.

NOTE CONF {"raw":[100,100]}

00:52:45.100 --> 00:52:45.820
<v Speaker 2>Three of those are correct.

NOTE CONF {"raw":[100,100,100,100,100]}

00:52:45.850 --> 00:52:47.140
<v Speaker 2>He left out John Hughes.

NOTE CONF {"raw":[100,100,100,100,100]}

00:52:47.140 --> 00:52:48.700
<v Speaker 2>How could he leave out John Hughes?

NOTE CONF {"raw":[100,87,100,100,100,100,100]}

00:52:48.730 --> 00:52:49.390
<v Speaker 2>All right.

NOTE CONF {"raw":[100,100]}

00:52:50.230 --> 00:52:53.560
<v Speaker 2>Um, creates Haskell a pure, non strict functional language.

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100]}

00:52:53.590 --> 00:52:56.800
<v Speaker 2>Haskell, get some resistance due to the complexity of using

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:56.800 --> 00:53:00.550
<v Speaker 2>monads to control side effects, Wadler tries to appease critics

NOTE CONF {"raw":[100,100,100,100,100,98,100,100,100,100]}

00:53:00.550 --> 00:53:04.870
<v Speaker 2>by explaining that quote A monad is a monoid in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:53:04.870 --> 00:53:06.910
<v Speaker 2>the category of endo functors.

NOTE CONF {"raw":[100,100,100,94,100]}

00:53:07.060 --> 00:53:08.470
<v Speaker 2>What's the problem?

NOTE CONF {"raw":[100,100,100]}

00:53:11.020 --> 00:53:12.040
<v Speaker 2>I will stop there.

NOTE CONF {"raw":[100,100,100,100]}

00:53:12.040 --> 00:53:12.730
<v Speaker 2>Thank you.

NOTE CONF {"raw":[100,100]}

00:53:21.460 --> 00:53:25.060
<v Speaker 2>So I will also be giving the guest lecture next

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:53:25.060 --> 00:53:28.660
<v Speaker 2>Monday on propositions as types.

NOTE CONF {"raw":[100,100,100,100,100]}

00:53:28.750 --> 00:53:31.690
<v Speaker 2>That's a fairly famous talk, so I hope to see

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:53:31.690 --> 00:53:32.260
<v Speaker 2>you there.

NOTE CONF {"raw":[100,100]}

00:54:28.100 --> 00:54:28.460
<v Speaker 0>Hi.

NOTE CONF {"raw":[100]}

00:54:29.060 --> 00:54:30.350
<v Speaker 0>Thank you very much.

NOTE CONF {"raw":[100,100,100,100]}

00:54:30.710 --> 00:54:31.520
<v Speaker 0>Oh, thanks.

NOTE CONF {"raw":[100,100]}

00:54:32.090 --> 00:54:33.380
<v Speaker 0>So you ask the question now.

NOTE CONF {"raw":[100,100,98,94,66,92]}

00:54:33.590 --> 00:54:36.110
<v Speaker 3>Does anybody else do any other functional languages?

NOTE CONF {"raw":[99,100,100,100,100,100,96,100]}

00:54:36.230 --> 00:54:38.360
<v Speaker 3>And, um.

NOTE CONF {"raw":[95,73]}

00:54:38.420 --> 00:54:38.930
<v Speaker 3>Oh.

NOTE CONF {"raw":[100]}
