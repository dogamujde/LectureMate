WEBVTT

00:00:28.770 --> 00:00:30.060
<v Speaker 0>Well, it's good afternoon.

NOTE CONF {"raw":[56,36,100,100]}

00:00:38.880 --> 00:00:41.790
<v Speaker 0>Your reps have asked me to make an announcement.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:00:42.660 --> 00:00:46.140
<v Speaker 0>I imagine that you.

NOTE CONF {"raw":[100,100,100,100]}

00:00:46.140 --> 00:00:46.890
<v Speaker 0>Well, I don't know.

NOTE CONF {"raw":[100,100,100,100]}

00:00:46.890 --> 00:00:49.710
<v Speaker 0>You should be the people who the announcement is directed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:49.710 --> 00:00:51.900
<v Speaker 0>to, but I just thought you don't need it anyway.

NOTE CONF {"raw":[100,100,83,78,100,100,100,100,100,100]}

00:00:51.900 --> 00:00:54.870
<v Speaker 0>Apparently some of you are having difficulty finding places to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:54.870 --> 00:00:59.610
<v Speaker 0>work when you're stuck hanging around here between activities, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:00:59.610 --> 00:01:02.190
<v Speaker 0>the reps asked me to point out that this building

NOTE CONF {"raw":[100,98,100,100,100,100,100,97,100,100]}

00:01:02.190 --> 00:01:03.750
<v Speaker 0>is the most crowded building.

NOTE CONF {"raw":[100,100,100,100,100]}

00:01:03.750 --> 00:01:08.880
<v Speaker 0>There are many other buildings on this campus, and GMB

NOTE CONF {"raw":[100,78,100,100,100,100,100,100,100,69]}

00:01:09.360 --> 00:01:13.440
<v Speaker 0>apparently has screens showing you where working areas are, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:13.440 --> 00:01:16.890
<v Speaker 0>the upper floors of GMB are often relatively empty.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:01:17.550 --> 00:01:19.410
<v Speaker 0>GMB is a very interesting place.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:01:19.410 --> 00:01:21.720
<v Speaker 0>I spent 20 years there and there are still bits

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:21.720 --> 00:01:24.690
<v Speaker 0>of it that I haven't been to, so you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:24.690 --> 00:01:26.760
<v Speaker 0>go and work in there and find all the little

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:26.760 --> 00:01:29.130
<v Speaker 0>corners that nobody else will ever find.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:01:29.340 --> 00:01:31.560
<v Speaker 0>Just make sure you take a ball of string to

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:01:31.560 --> 00:01:32.430
<v Speaker 0>get out again.

NOTE CONF {"raw":[100,100,100]}

00:01:34.710 --> 00:01:36.420
<v Speaker 0>Are there any questions from yesterday?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:01:36.420 --> 00:01:40.350
<v Speaker 0>There was a lot of concept and notation yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:01:41.730 --> 00:01:42.720
<v Speaker 0>You're all gone through it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:01:42.720 --> 00:01:46.500
<v Speaker 0>Or shall I just continue straight on assuming everything is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:46.500 --> 00:01:47.280
<v Speaker 0>fine?

NOTE CONF {"raw":[100]}

00:01:52.470 --> 00:01:54.030
<v Speaker 0>Now what if we'll just go straight on?

NOTE CONF {"raw":[95,100,100,100,100,100,100,100]}

00:01:54.030 --> 00:01:56.820
<v Speaker 0>So let me remind you what we did yesterday.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:01:57.990 --> 00:02:03.740
<v Speaker 0>We introduced a slightly weird notion of non-deterministic automaton, which

NOTE CONF {"raw":[100,98,60,100,100,100,100,67,100,100]}

00:02:03.740 --> 00:02:06.530
<v Speaker 0>we can basically think of as an automaton, where we're

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:06.530 --> 00:02:11.780
<v Speaker 0>exploring lots of possibilities simultaneously, and all we require is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:11.780 --> 00:02:12.830
<v Speaker 0>that one of them works.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:12.830 --> 00:02:14.900
<v Speaker 0>One of them turns up with the good answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:16.670 --> 00:02:19.280
<v Speaker 0>And I told you, the reason we would do doing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:19.280 --> 00:02:22.070
<v Speaker 0>that is because they're easier to work with in practice.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:22.070 --> 00:02:24.800
<v Speaker 0>But I haven't yet given you a convincing explanation of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:24.800 --> 00:02:26.990
<v Speaker 0>why we want to work with them in practice.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:27.170 --> 00:02:30.020
<v Speaker 0>So that's where I'm hoping to get to today.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:31.970 --> 00:02:34.910
<v Speaker 0>But before we do that, I'm going to introduce yet

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:34.910 --> 00:02:37.970
<v Speaker 0>another refinement, yet another extension.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:38.360 --> 00:02:42.950
<v Speaker 0>It's another slightly unnatural thing, but also very useful for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:42.950 --> 00:02:44.990
<v Speaker 0>reasons that will become obvious.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:46.610 --> 00:02:50.930
<v Speaker 0>I'm going to define something called an epsilon NFA.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:02:52.040 --> 00:02:54.710
<v Speaker 0>By now you should all have learnt your Greek alphabet,

NOTE CONF {"raw":[100,100,100,100,100,100,88,100,100,100]}

00:02:55.070 --> 00:02:56.990
<v Speaker 0>so you should know epsilon.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:58.640 --> 00:03:02.750
<v Speaker 0>And this is a notion of automaton which has a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:02.750 --> 00:03:06.170
<v Speaker 0>special symbol, epsilon, which is not part of the input

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:06.170 --> 00:03:10.430
<v Speaker 0>alphabet, but we can write epsilon transitions.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:03:15.800 --> 00:03:19.070
<v Speaker 0>So I can write an epsilon transition between two states.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:20.540 --> 00:03:22.190
<v Speaker 0>And what does that mean?

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:22.640 --> 00:03:25.340
<v Speaker 0>Well, it means that the machine can, just of its

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:25.340 --> 00:03:28.730
<v Speaker 0>own accord, decide to move between these two states without

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:28.730 --> 00:03:30.740
<v Speaker 0>actually reading any input.

NOTE CONF {"raw":[100,100,100,100]}

00:03:31.460 --> 00:03:32.630
<v Speaker 0>Now, I just said decide.

NOTE CONF {"raw":[67,100,100,100,100]}

00:03:32.630 --> 00:03:34.370
<v Speaker 0>Of course it doesn't decide anything.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:03:34.370 --> 00:03:36.290
<v Speaker 0>This is just non-deterministic.

NOTE CONF {"raw":[100,100,100,60]}

00:03:36.290 --> 00:03:40.040
<v Speaker 0>So at any point in the execution of the machine,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:40.040 --> 00:03:43.490
<v Speaker 0>you have the possibility of moving along an epsilon arrow

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:43.490 --> 00:03:45.320
<v Speaker 0>or staying where you are.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:47.690 --> 00:03:53.120
<v Speaker 0>And as with the previous explanation yesterday, all possibilities are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:53.120 --> 00:03:54.020
<v Speaker 0>explored.

NOTE CONF {"raw":[100]}

00:03:54.050 --> 00:03:55.070
<v Speaker 0>So.

NOTE CONF {"raw":[100]}

00:04:04.040 --> 00:04:08.030
<v Speaker 0>If I draw this machine and it reads an A.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:08.180 --> 00:04:10.280
<v Speaker 0>There are a couple of things that might happen.

NOTE CONF {"raw":[100,91,100,100,100,100,100,100,100]}

00:04:10.310 --> 00:04:14.090
<v Speaker 0>It might read an A and end up here or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:14.090 --> 00:04:16.280
<v Speaker 0>before reading the A might run.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:04:16.549 --> 00:04:19.310
<v Speaker 0>It might just go to this state and then read

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:19.310 --> 00:04:20.600
<v Speaker 0>the A and end up there.

NOTE CONF {"raw":[100,100,86,100,100,100]}

00:04:21.109 --> 00:04:25.550
<v Speaker 0>So remember, things are good if any of the possibility

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:25.550 --> 00:04:26.780
<v Speaker 0>ends up in a good state.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:04:26.780 --> 00:04:32.660
<v Speaker 0>So that particular epsilon automaton accepts the single input a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:34.370 --> 00:04:35.780
<v Speaker 0>why do we do this?

NOTE CONF {"raw":[100,100,100,100,100]}

00:04:36.020 --> 00:04:38.090
<v Speaker 0>It's a technical tool.

NOTE CONF {"raw":[100,100,100,100]}

00:04:38.150 --> 00:04:42.320
<v Speaker 0>It makes life much easier to build machines that recognise

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,88]}

00:04:42.320 --> 00:04:46.160
<v Speaker 0>the concatenation of two strings, or that recognise the repetition

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:04:46.160 --> 00:04:48.770
<v Speaker 0>of strings, and that is something we do a lot

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:48.770 --> 00:04:49.430
<v Speaker 0>in practice.

NOTE CONF {"raw":[100,100]}

00:04:49.430 --> 00:04:52.850
<v Speaker 0>So I will show you this fairly shortly.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:54.740 --> 00:04:56.810
<v Speaker 0>Have I made it more difficult?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:04:57.200 --> 00:04:57.560
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:04:57.560 --> 00:04:58.640
<v Speaker 0>Not really.

NOTE CONF {"raw":[100,100]}

00:04:59.570 --> 00:05:02.840
<v Speaker 0>Everything we've done so far goes through.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:02.840 --> 00:05:05.930
<v Speaker 0>If you just pay a little bit of attention to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:05.930 --> 00:05:06.890
<v Speaker 0>the details.

NOTE CONF {"raw":[100,100]}

00:05:07.160 --> 00:05:10.250
<v Speaker 0>Um, goes through a very dangerous mathematical phrase.

NOTE CONF {"raw":[62,100,100,58,100,100,100,100]}

00:05:10.250 --> 00:05:12.380
<v Speaker 0>Mathematicians will say, oh, yes.

NOTE CONF {"raw":[100,100,100,100,100]}

00:05:12.380 --> 00:05:14.300
<v Speaker 0>I make the slight adjustment to the definition.

NOTE CONF {"raw":[100,100,57,100,100,65,100,100]}

00:05:14.510 --> 00:05:15.950
<v Speaker 0>Everything goes through.

NOTE CONF {"raw":[100,100,100]}

00:05:16.910 --> 00:05:20.030
<v Speaker 0>Um, what they mean is somebody, hopefully them, has done

NOTE CONF {"raw":[100,100,100,100,100,79,100,92,100,100]}

00:05:20.030 --> 00:05:22.550
<v Speaker 0>the work of checking that everything still works.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:23.630 --> 00:05:27.920
<v Speaker 0>In particular, the subset construction that we did yesterday where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:27.920 --> 00:05:32.900
<v Speaker 0>we built a deterministic machine by taking the states of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:32.900 --> 00:05:35.840
<v Speaker 0>the deterministic machine to be the sets of states of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:35.840 --> 00:05:38.960
<v Speaker 0>the nondeterministic machine still works.

NOTE CONF {"raw":[100,68,100,100,100]}

00:05:39.200 --> 00:05:42.080
<v Speaker 0>So we haven't really added any power.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:42.110 --> 00:05:45.650
<v Speaker 0>We just added a gimmick that is useful in practice.

NOTE CONF {"raw":[76,100,100,100,100,100,100,100,100,100]}

00:05:45.650 --> 00:05:49.310
<v Speaker 0>And we can still determine I's an automaton and we

NOTE CONF {"raw":[100,100,100,100,100,51,100,100,100,100]}

00:05:49.310 --> 00:05:52.280
<v Speaker 0>still recognise regular languages.

NOTE CONF {"raw":[100,86,100,100]}

00:05:54.760 --> 00:05:57.880
<v Speaker 0>So what do I mean by everything goes through?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:58.330 --> 00:06:01.570
<v Speaker 0>Well, we can still build a product of two automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:02.230 --> 00:06:05.920
<v Speaker 0>There's a little bit of work to be done with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:05.920 --> 00:06:08.140
<v Speaker 0>the epsilon transition.

NOTE CONF {"raw":[100,100,100]}

00:06:08.620 --> 00:06:11.170
<v Speaker 0>You can find the details in the book.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:06:13.330 --> 00:06:13.750
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:06:16.690 --> 00:06:18.910
<v Speaker 0>So product works just like Dfas.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:06:18.910 --> 00:06:21.160
<v Speaker 0>And whether you have epsilons or not is just a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,92]}

00:06:21.160 --> 00:06:22.270
<v Speaker 0>small detail.

NOTE CONF {"raw":[100,100]}

00:06:22.780 --> 00:06:24.490
<v Speaker 0>What was the other thing that we did with the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:24.490 --> 00:06:26.140
<v Speaker 0>deterministic automata?

NOTE CONF {"raw":[100,100]}

00:06:26.500 --> 00:06:29.260
<v Speaker 0>We said it was easy to complement them.

NOTE CONF {"raw":[100,100,100,100,100,100,60,100]}

00:06:29.380 --> 00:06:32.200
<v Speaker 0>We can recognise the strings that are not in a

NOTE CONF {"raw":[100,100,98,100,100,100,100,100,100,100]}

00:06:32.200 --> 00:06:32.980
<v Speaker 0>language.

NOTE CONF {"raw":[100]}

00:06:34.150 --> 00:06:36.520
<v Speaker 0>This is the big thing that we have lost by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:36.520 --> 00:06:37.930
<v Speaker 0>adding nondeterminism.

NOTE CONF {"raw":[100,55]}

00:06:38.530 --> 00:06:40.360
<v Speaker 0>So why have we lost it?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:06:42.460 --> 00:06:46.330
<v Speaker 0>Yesterday I asked you could we have decided made any

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:46.330 --> 00:06:49.750
<v Speaker 0>different choice than saying we accept if any one ends

NOTE CONF {"raw":[100,100,100,100,100,100,100,92,92,100]}

00:06:49.750 --> 00:06:51.010
<v Speaker 0>up in a good state?

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:51.310 --> 00:06:55.840
<v Speaker 0>One of the alternatives was any was all ones end

NOTE CONF {"raw":[100,100,100,100,100,84,100,100,90,100]}

00:06:55.840 --> 00:06:56.950
<v Speaker 0>up in a good state.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:57.340 --> 00:06:59.110
<v Speaker 0>That's obviously not the same thing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:00.310 --> 00:07:04.270
<v Speaker 0>Why can't we complement a nondeterministic automaton?

NOTE CONF {"raw":[100,100,100,75,100,62,97]}

00:07:04.300 --> 00:07:05.230
<v Speaker 0>Well, exactly.

NOTE CONF {"raw":[100,100]}

00:07:05.230 --> 00:07:09.340
<v Speaker 0>Because we say that an NFA accepts if any of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:09.340 --> 00:07:11.110
<v Speaker 0>the executions is good.

NOTE CONF {"raw":[100,100,100,100]}

00:07:11.350 --> 00:07:13.990
<v Speaker 0>So if we complemented it, we can't just flip the

NOTE CONF {"raw":[100,100,100,96,100,100,100,100,100,100]}

00:07:13.990 --> 00:07:17.170
<v Speaker 0>accepting states, because we would also need to say, look,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:17.170 --> 00:07:21.460
<v Speaker 0>all the executions end up in the new accepting states.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:21.460 --> 00:07:23.200
<v Speaker 0>That is the old bad states.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:23.740 --> 00:07:27.520
<v Speaker 0>And that's not how non-deterministic automata work, because they require

NOTE CONF {"raw":[100,100,100,100,62,100,100,100,100,100]}

00:07:27.520 --> 00:07:29.410
<v Speaker 0>any execution to succeed.

NOTE CONF {"raw":[100,100,100,100]}

00:07:30.220 --> 00:07:33.490
<v Speaker 0>Um, what this says is not exists is the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:33.490 --> 00:07:37.330
<v Speaker 0>as for all, which by now you all should know.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:39.910 --> 00:07:44.320
<v Speaker 0>So we can't make an easy, obvious compliment construction on

NOTE CONF {"raw":[100,100,100,100,100,100,100,74,100,100]}

00:07:44.320 --> 00:07:46.270
<v Speaker 0>a non-deterministic automaton.

NOTE CONF {"raw":[100,69,100]}

00:07:47.020 --> 00:07:50.830
<v Speaker 0>How could we build an automaton that recognises the complement

NOTE CONF {"raw":[100,100,100,100,100,100,100,79,100,100]}

00:07:50.830 --> 00:07:53.020
<v Speaker 0>of a nondeterministic automata.

NOTE CONF {"raw":[100,100,92,87]}

00:07:53.470 --> 00:07:54.250
<v Speaker 0>Automatons.

NOTE CONF {"raw":[100]}

00:07:54.250 --> 00:07:54.970
<v Speaker 0>Language.

NOTE CONF {"raw":[99]}

00:08:11.530 --> 00:08:12.190
<v Speaker 0>Anybody?

NOTE CONF {"raw":[100]}

00:08:14.530 --> 00:08:15.940
<v Speaker 0>Well, what can we do?

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:17.620 --> 00:08:20.380
<v Speaker 0>We know we can convert it to a DFA, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:20.500 --> 00:08:24.160
<v Speaker 0>Yesterday we did a conversion to a DFA.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:08:25.510 --> 00:08:28.150
<v Speaker 0>Um, and we know that we can write the complement

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:28.150 --> 00:08:29.200
<v Speaker 0>of a DFA.

NOTE CONF {"raw":[100,100,100]}

00:08:29.590 --> 00:08:32.229
<v Speaker 0>So in the worst case, if we can't think of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:32.229 --> 00:08:35.530
<v Speaker 0>anything clever to do, we can always turn the NFA

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:35.530 --> 00:08:40.630
<v Speaker 0>into a DFA, do the complement from last week, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:40.630 --> 00:08:42.190
<v Speaker 0>then we have the result.

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:42.190 --> 00:08:48.700
<v Speaker 0>So the problem with that is that when you do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:48.700 --> 00:08:51.720
<v Speaker 0>the determination process that we did yesterday.

NOTE CONF {"raw":[100,84,100,100,100,100,100]}

00:08:51.870 --> 00:08:54.000
<v Speaker 0>You're dealing with sets of states, so the size of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:54.000 --> 00:08:56.790
<v Speaker 0>the automaton typically blows up exponentially.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:08:57.210 --> 00:09:01.530
<v Speaker 0>And generally speaking, we like to think of negation as

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:01.530 --> 00:09:02.880
<v Speaker 0>a nice, simple operation.

NOTE CONF {"raw":[100,100,100,100]}

00:09:02.880 --> 00:09:05.280
<v Speaker 0>We don't expect it to lead to an exponential blow

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,72]}

00:09:05.280 --> 00:09:05.730
<v Speaker 0>up.

NOTE CONF {"raw":[72]}

00:09:07.080 --> 00:09:08.970
<v Speaker 0>However, it's a fact of life.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:08.970 --> 00:09:12.330
<v Speaker 0>Well, it's a fact of mathematics that when you introduce

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:12.330 --> 00:09:17.970
<v Speaker 0>this kind of non-deterministic idea, then complementation gets complicated.

NOTE CONF {"raw":[100,100,100,88,100,100,100,100,100]}

00:09:18.240 --> 00:09:18.750
<v Speaker 0>Exactly.

NOTE CONF {"raw":[100]}

00:09:18.750 --> 00:09:23.010
<v Speaker 0>Because Nondeterminism says there exists a path that works.

NOTE CONF {"raw":[100,71,100,100,100,100,100,100,100]}

00:09:23.250 --> 00:09:25.260
<v Speaker 0>And so if we negate it, we have to say

NOTE CONF {"raw":[99,100,100,100,100,100,100,100,100,100]}

00:09:25.260 --> 00:09:29.550
<v Speaker 0>for all paths that work, and then we have to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:29.550 --> 00:09:30.930
<v Speaker 0>look at all of them.

NOTE CONF {"raw":[100,100,100,100,100]}

00:09:36.780 --> 00:09:38.070
<v Speaker 0>Um, yeah.

NOTE CONF {"raw":[100,100]}

00:09:38.070 --> 00:09:40.410
<v Speaker 0>So questions about that.

NOTE CONF {"raw":[100,100,100,100]}

00:09:44.370 --> 00:09:47.460
<v Speaker 0>And you might wonder how often do we actually want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:47.460 --> 00:09:51.960
<v Speaker 0>to do complementation in practice, not all that often, but

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:51.960 --> 00:09:53.220
<v Speaker 0>occasionally it's useful.

NOTE CONF {"raw":[100,99,100]}

00:09:53.220 --> 00:09:55.530
<v Speaker 0>But usually when we want to do complement, we want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:55.530 --> 00:09:57.450
<v Speaker 0>to complement something very small.

NOTE CONF {"raw":[89,97,100,100,100]}

00:09:57.450 --> 00:10:01.440
<v Speaker 0>We want to say things like, um, I want to

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:10:01.440 --> 00:10:04.920
<v Speaker 0>see a word that does not begin with a.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:10:05.190 --> 00:10:07.560
<v Speaker 0>And that's an easy thing to complement.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:11.340 --> 00:10:13.230
<v Speaker 0>What else can we do with Nsfas?

NOTE CONF {"raw":[100,100,100,100,100,100,56]}

00:10:14.310 --> 00:10:17.190
<v Speaker 0>Well, we can build the sum we saw how to

NOTE CONF {"raw":[100,100,100,100,100,57,100,100,100,100]}

00:10:17.190 --> 00:10:18.090
<v Speaker 0>build the sum.

NOTE CONF {"raw":[100,100,100]}

00:10:18.960 --> 00:10:22.920
<v Speaker 0>We just put them side by side and take the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:22.920 --> 00:10:26.550
<v Speaker 0>union of the states.

NOTE CONF {"raw":[100,100,100,100]}

00:10:27.150 --> 00:10:28.920
<v Speaker 0>So we did that yesterday.

NOTE CONF {"raw":[100,100,100,100,100]}

00:10:29.490 --> 00:10:32.580
<v Speaker 0>We don't need to do anything fancy.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:32.580 --> 00:10:33.930
<v Speaker 0>We don't need to build a product.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:10:33.930 --> 00:10:36.540
<v Speaker 0>We just take the two amata two automata, draw them

NOTE CONF {"raw":[100,100,100,100,99,50,100,100,100,100]}

00:10:36.540 --> 00:10:39.120
<v Speaker 0>on the same piece of paper and say the union

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:39.120 --> 00:10:39.870
<v Speaker 0>works.

NOTE CONF {"raw":[100]}

00:10:41.790 --> 00:10:43.050
<v Speaker 0>Um, lots of notations.

NOTE CONF {"raw":[100,100,100,65]}

00:10:43.050 --> 00:10:48.090
<v Speaker 0>Some people write that the thing that the epsilon automata

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:48.090 --> 00:10:52.110
<v Speaker 0>have brought us is that we can build things that

NOTE CONF {"raw":[100,51,100,100,100,100,100,100,100,100]}

00:10:52.110 --> 00:10:55.260
<v Speaker 0>recognise the concatenation of two languages.

NOTE CONF {"raw":[65,100,100,100,100,100]}

00:10:56.100 --> 00:10:58.170
<v Speaker 0>And what do I mean by the concatenation of two

NOTE CONF {"raw":[88,100,100,100,100,100,100,100,100,100]}

00:10:58.170 --> 00:10:59.070
<v Speaker 0>languages?

NOTE CONF {"raw":[100]}

00:10:59.160 --> 00:11:02.280
<v Speaker 0>If L is one language and L is another, then

NOTE CONF {"raw":[100,99,100,100,100,100,100,100,100,100]}

00:11:02.280 --> 00:11:06.030
<v Speaker 0>the concatenation is simply things that have a string in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:06.030 --> 00:11:09.660
<v Speaker 0>the first language, followed by a string in the second

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:09.660 --> 00:11:10.410
<v Speaker 0>language.

NOTE CONF {"raw":[100]}

00:11:12.090 --> 00:11:15.120
<v Speaker 0>And that's something that we use a great deal in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:15.120 --> 00:11:16.950
<v Speaker 0>the applications of this stuff.

NOTE CONF {"raw":[100,100,100,100,100]}

00:11:16.950 --> 00:11:22.380
<v Speaker 0>Because if you're recognising Haskell syntax or any other language,

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:11:22.380 --> 00:11:25.230
<v Speaker 0>then you are doing a lot of saying a sentence

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:25.230 --> 00:11:27.780
<v Speaker 0>is a noun phrase followed by a verb phrase, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:27.780 --> 00:11:32.160
<v Speaker 0>a noun phrase is a determiner followed by some adjectives,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:32.160 --> 00:11:34.110
<v Speaker 0>followed by a noun or whatever.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:35.070 --> 00:11:37.980
<v Speaker 0>Or the equivalent in programming languages.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:37.980 --> 00:11:42.510
<v Speaker 0>So concatenation is the one the single most used operation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:42.510 --> 00:11:45.000
<v Speaker 0>when we're actually doing language processing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:45.180 --> 00:11:47.400
<v Speaker 0>So it would be nice if it were very easy

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:47.400 --> 00:11:48.120
<v Speaker 0>to do it.

NOTE CONF {"raw":[100,100,100]}

00:11:49.680 --> 00:11:53.940
<v Speaker 0>You should take a little time to think how you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:53.940 --> 00:11:55.470
<v Speaker 0>do it deterministically.

NOTE CONF {"raw":[100,100,100]}

00:11:55.620 --> 00:11:59.460
<v Speaker 0>It's not hard, but it's just needs a little bit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:59.460 --> 00:12:01.620
<v Speaker 0>of attention to the way you plug the two machines

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:01.620 --> 00:12:02.280
<v Speaker 0>together.

NOTE CONF {"raw":[100]}

00:12:03.390 --> 00:12:07.320
<v Speaker 0>When we go non-deterministic, then it's not quite so obvious

NOTE CONF {"raw":[100,100,100,82,100,100,100,100,100,100]}

00:12:07.320 --> 00:12:07.890
<v Speaker 0>how to do it.

NOTE CONF {"raw":[100,100,100,100]}

00:12:07.890 --> 00:12:10.740
<v Speaker 0>If you think about a non-deterministic automaton and how to

NOTE CONF {"raw":[100,100,100,100,100,84,100,100,100,100]}

00:12:10.740 --> 00:12:11.700
<v Speaker 0>plug it together.

NOTE CONF {"raw":[100,100,100]}

00:12:11.880 --> 00:12:14.430
<v Speaker 0>Then you will find that the details get a bit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:14.430 --> 00:12:15.090
<v Speaker 0>fiddly.

NOTE CONF {"raw":[100]}

00:12:16.590 --> 00:12:21.120
<v Speaker 0>But if we have these epsilon transitions, we can make

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:21.120 --> 00:12:23.670
<v Speaker 0>it very, very straightforward.

NOTE CONF {"raw":[100,100,100,100]}

00:12:25.830 --> 00:12:28.110
<v Speaker 0>So there's a formal definition.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:29.670 --> 00:12:35.370
<v Speaker 0>So here I've got my two epsilon non-deterministic finite automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,69,100,100]}

00:12:36.240 --> 00:12:38.370
<v Speaker 0>And they have different sets of states.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:38.370 --> 00:12:40.350
<v Speaker 0>So I stick the states together.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:40.620 --> 00:12:43.380
<v Speaker 0>The transitions are the unions the final states.

NOTE CONF {"raw":[100,85,72,100,100,100,100,100]}

00:12:43.380 --> 00:12:45.090
<v Speaker 0>Well what are the final states.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:45.680 --> 00:12:50.510
<v Speaker 0>And then I add some extra transitions.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:50.510 --> 00:12:52.580
<v Speaker 0>So these are the transitions in one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:52.580 --> 00:12:54.380
<v Speaker 0>These are the transitions in the other.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:54.380 --> 00:12:56.750
<v Speaker 0>And then I'm adding more transitions.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:56.930 --> 00:12:59.690
<v Speaker 0>These are all epsilons I'll give you a picture in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:59.690 --> 00:13:01.790
<v Speaker 0>a moment because the picture is much clearer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:13:02.060 --> 00:13:05.510
<v Speaker 0>And the epsilons are just joining the accepting states of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:05.510 --> 00:13:09.110
<v Speaker 0>automaton one to the initial states of automaton two.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:13:09.800 --> 00:13:12.020
<v Speaker 0>That should make sense, because what is.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:12.380 --> 00:13:17.090
<v Speaker 0>If you want to see strings in this language, followed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:17.090 --> 00:13:20.600
<v Speaker 0>by strings in this language, you run the string on

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:20.600 --> 00:13:21.410
<v Speaker 0>automaton one.

NOTE CONF {"raw":[100,100]}

00:13:21.410 --> 00:13:22.280
<v Speaker 0>It accepts.

NOTE CONF {"raw":[100,100]}

00:13:22.280 --> 00:13:23.300
<v Speaker 0>Then you start this.

NOTE CONF {"raw":[100,100,100,81]}

00:13:23.300 --> 00:13:25.190
<v Speaker 0>The rest of the string on automaton two.

NOTE CONF {"raw":[100,100,100,100,100,58,100,98]}

00:13:25.220 --> 00:13:28.130
<v Speaker 0>If that accepts, you've got a concatenation of the two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:28.130 --> 00:13:28.850
<v Speaker 0>strings.

NOTE CONF {"raw":[100]}

00:13:29.900 --> 00:13:32.420
<v Speaker 0>But when things are non-deterministic, it sounds a little bit

NOTE CONF {"raw":[100,100,100,100,91,100,100,100,100,100]}

00:13:32.420 --> 00:13:34.460
<v Speaker 0>more complicated, because what if you end up in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:34.460 --> 00:13:35.720
<v Speaker 0>wrong kind of state?

NOTE CONF {"raw":[100,100,100,100]}

00:13:37.160 --> 00:13:39.110
<v Speaker 0>So let me put this in words.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:39.920 --> 00:13:42.380
<v Speaker 0>Put the two machines side by side.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:42.380 --> 00:13:45.170
<v Speaker 0>For example this one and this one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:13:46.730 --> 00:13:48.230
<v Speaker 0>So what does this one do?

NOTE CONF {"raw":[100,100,88,100,100,100]}

00:13:48.230 --> 00:13:49.460
<v Speaker 0>This reads.

NOTE CONF {"raw":[100,100]}

00:13:51.500 --> 00:13:54.980
<v Speaker 0>This accepts strings that begin with two A's or begin

NOTE CONF {"raw":[98,55,100,100,100,100,100,100,100,100]}

00:13:54.980 --> 00:13:56.330
<v Speaker 0>with two B's.

NOTE CONF {"raw":[100,100,97]}

00:13:56.930 --> 00:13:59.870
<v Speaker 0>And this one is the one that accepts a string

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,98,100]}

00:13:59.870 --> 00:14:01.700
<v Speaker 0>that ends with a b.

NOTE CONF {"raw":[100,100,100,100,100]}

00:14:02.120 --> 00:14:05.960
<v Speaker 0>So hopefully if we stick these two machines together, we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:05.960 --> 00:14:08.690
<v Speaker 0>want to get something that accepts strings that start with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:08.690 --> 00:14:15.350
<v Speaker 0>two A's or two B's, and that afterwards end with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,68,100]}

00:14:15.350 --> 00:14:16.730
<v Speaker 0>an A and a B.

NOTE CONF {"raw":[100,100,100,97,100]}

00:14:19.040 --> 00:14:21.770
<v Speaker 0>To do that, I want to join the accepting states

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:21.770 --> 00:14:23.330
<v Speaker 0>to the initial states.

NOTE CONF {"raw":[100,100,100,100]}

00:14:23.630 --> 00:14:26.810
<v Speaker 0>But I want to avoid confusing matters by making this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:26.810 --> 00:14:27.770
<v Speaker 0>state accepting.

NOTE CONF {"raw":[100,100]}

00:14:27.770 --> 00:14:29.930
<v Speaker 0>So you might think, can't I just glue these two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:29.930 --> 00:14:31.670
<v Speaker 0>states together into one?

NOTE CONF {"raw":[100,100,100,100]}

00:14:31.670 --> 00:14:34.310
<v Speaker 0>But then I will get confused about what's accepting and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:34.310 --> 00:14:35.210
<v Speaker 0>what's not.

NOTE CONF {"raw":[100,100]}

00:14:36.290 --> 00:14:42.800
<v Speaker 0>So what I can do is to just draw some

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:42.800 --> 00:14:46.670
<v Speaker 0>arrows from the good states here into the initial state

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:46.670 --> 00:14:47.240
<v Speaker 0>here.

NOTE CONF {"raw":[100]}

00:14:47.840 --> 00:14:50.900
<v Speaker 0>So in this one, which doesn't have any epsilons to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:50.900 --> 00:14:51.740
<v Speaker 0>start with.

NOTE CONF {"raw":[100,100]}

00:14:52.100 --> 00:14:54.530
<v Speaker 0>It could have, but it doesn't at the moment.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:14:55.160 --> 00:14:56.540
<v Speaker 0>I read my string.

NOTE CONF {"raw":[100,100,100,100]}

00:14:56.540 --> 00:15:00.320
<v Speaker 0>And in the States where I have successfully read a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:00.320 --> 00:15:03.890
<v Speaker 0>string from the first one, I can jump to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:03.890 --> 00:15:06.560
<v Speaker 0>start of the second one and start looking for string

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,95]}

00:15:06.560 --> 00:15:09.080
<v Speaker 0>for the rest of the string, ending with AB.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,71]}

00:15:11.180 --> 00:15:12.590
<v Speaker 0>And that's nice and easy.

NOTE CONF {"raw":[100,100,100,100,100]}

00:15:12.950 --> 00:15:15.470
<v Speaker 0>So the notation is a bit fiddly, but the picture

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:15.470 --> 00:15:16.250
<v Speaker 0>is easy.

NOTE CONF {"raw":[100,100]}

00:15:16.310 --> 00:15:16.730
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:15:19.040 --> 00:15:21.950
<v Speaker 0>Um, as I said, go away and think about what

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:21.950 --> 00:15:24.410
<v Speaker 0>you would do if you didn't have epsilon transitions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:15:24.410 --> 00:15:26.540
<v Speaker 0>How would you glue these together and make sure that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:26.540 --> 00:15:27.740
<v Speaker 0>it worked precisely?

NOTE CONF {"raw":[100,98,100]}

00:15:29.870 --> 00:15:32.720
<v Speaker 0>And the thing that really gets much easier is something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:32.720 --> 00:15:36.680
<v Speaker 0>that we also want to do a lot, which is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:36.680 --> 00:15:39.350
<v Speaker 0>to recognise lots of copies of a string.

NOTE CONF {"raw":[100,90,100,100,100,100,100,100]}

00:15:39.830 --> 00:15:44.920
<v Speaker 0>So a typical piece of discourse or piece of text

NOTE CONF {"raw":[100,100,100,100,100,100,48,100,100,100]}

00:15:45.310 --> 00:15:48.340
<v Speaker 0>has many copies of whatever your thing is.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:15:48.340 --> 00:15:49.720
<v Speaker 0>Lots of sentences.

NOTE CONF {"raw":[100,100,100]}

00:15:51.010 --> 00:15:55.150
<v Speaker 0>Programming language is a lot of repetitions of the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:55.150 --> 00:15:56.050
<v Speaker 0>construct.

NOTE CONF {"raw":[100]}

00:15:56.140 --> 00:16:01.390
<v Speaker 0>So if you remember a little while back, I introduced

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:01.390 --> 00:16:02.680
<v Speaker 0>the star notation.

NOTE CONF {"raw":[100,100,100]}

00:16:02.680 --> 00:16:05.260
<v Speaker 0>Star is arbitrary repetition of something.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:06.370 --> 00:16:10.090
<v Speaker 0>That's something that we want to recognise a lot.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:16:10.870 --> 00:16:14.560
<v Speaker 0>So here's the machine that recognises A, B or BA.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:16.720 --> 00:16:19.690
<v Speaker 0>Here's the machine that recognises strings that are made up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:19.690 --> 00:16:21.190
<v Speaker 0>of sequences of a, b.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:21.640 --> 00:16:25.780
<v Speaker 0>So you can you see a ba a b a

NOTE CONF {"raw":[100,100,100,100,100,94,84,100,100,90]}

00:16:25.780 --> 00:16:29.350
<v Speaker 0>a any number of repetitions of either of these two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:29.350 --> 00:16:30.100
<v Speaker 0>things.

NOTE CONF {"raw":[100]}

00:16:31.540 --> 00:16:34.360
<v Speaker 0>And this is quite neat because I haven't had to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:34.360 --> 00:16:39.190
<v Speaker 0>do anything except jump from the final states to the

NOTE CONF {"raw":[100,100,100,100,100,100,100,99,100,100]}

00:16:39.190 --> 00:16:40.240
<v Speaker 0>initial state.

NOTE CONF {"raw":[100,100]}

00:16:40.450 --> 00:16:42.490
<v Speaker 0>And again, you can go away and try to do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:42.490 --> 00:16:47.560
<v Speaker 0>this with deterministic automata or non-deterministic or better non-deterministic automata

NOTE CONF {"raw":[100,100,100,100,100,98,100,100,55,100]}

00:16:47.560 --> 00:16:48.850
<v Speaker 0>without epsilons.

NOTE CONF {"raw":[100,100]}

00:16:49.060 --> 00:16:51.340
<v Speaker 0>And you'll find it's hard at work.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:16:51.820 --> 00:16:53.050
<v Speaker 0>Of course it's not impossible.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:53.050 --> 00:16:55.660
<v Speaker 0>It's just Fiddler to write down correctly.

NOTE CONF {"raw":[100,100,56,100,100,100,100]}

00:16:59.050 --> 00:16:59.680
<v Speaker 0>Right.

NOTE CONF {"raw":[100]}

00:16:59.680 --> 00:17:05.470
<v Speaker 0>So that's a couple of several things I've introduced complement

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:05.470 --> 00:17:08.290
<v Speaker 0>product some concatenation and looping.

NOTE CONF {"raw":[94,100,100,100,100]}

00:17:08.290 --> 00:17:11.110
<v Speaker 0>So I should pause and say do you want me

NOTE CONF {"raw":[100,100,100,100,100,100,73,100,100,100]}

00:17:11.110 --> 00:17:13.120
<v Speaker 0>to say more about any of these?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:17:14.050 --> 00:17:14.530
<v Unknown>Yeah.

NOTE CONF {"raw":[98]}

00:17:17.140 --> 00:17:21.400
<v Unknown>Say that the section of the empty set.

NOTE CONF {"raw":[82,97,100,100,100,95,85,88]}

00:17:22.300 --> 00:17:22.900
<v Unknown>Why is that.

NOTE CONF {"raw":[100,98,52]}

00:17:25.480 --> 00:17:27.579
<v Speaker 0>So if for some I say what?

NOTE CONF {"raw":[65,38,100,100,100,100,100]}

00:17:27.579 --> 00:17:28.300
<v Speaker 0>Oh, here.

NOTE CONF {"raw":[99,100]}

00:17:29.290 --> 00:17:31.300
<v Speaker 0>Um, that's just a technical detail.

NOTE CONF {"raw":[75,100,100,100,100,100]}

00:17:31.300 --> 00:17:33.700
<v Speaker 0>I'm saying that these are two distinct automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:17:34.300 --> 00:17:36.490
<v Speaker 0>If that weren't true, then I would be talking about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:36.490 --> 00:17:38.800
<v Speaker 0>two automata that have a state in common.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:17:42.370 --> 00:17:44.980
<v Speaker 0>So it's purely a notational fiddle.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:17:44.980 --> 00:17:46.480
<v Speaker 0>Mathematical precision.

NOTE CONF {"raw":[100,100]}

00:17:47.080 --> 00:17:50.560
<v Speaker 0>We never think about taking two automata that happened share

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:50.560 --> 00:17:53.110
<v Speaker 0>a state, because that's what we're building.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:17:56.470 --> 00:18:00.850
<v Speaker 0>Um, so if you're if you're a mathematician, then you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:00.850 --> 00:18:02.050
<v Speaker 0>might write it differently.

NOTE CONF {"raw":[100,100,100,100]}

00:18:02.050 --> 00:18:04.480
<v Speaker 0>You could write disjoint union or something.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:18:04.900 --> 00:18:06.190
<v Speaker 0>So I could write.

NOTE CONF {"raw":[100,100,100,100]}

00:18:06.310 --> 00:18:09.160
<v Speaker 0>Yeah, I could write disjoint union there if you're happier.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,100]}

00:18:11.560 --> 00:18:15.220
<v Speaker 0>In fact maybe I should, but I'm never sure whether

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:15.220 --> 00:18:17.710
<v Speaker 0>everybody actually knows what I mean.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:18:17.710 --> 00:18:19.960
<v Speaker 0>If I write down the disjoint union sign.

NOTE CONF {"raw":[100,100,100,100,73,100,100,100]}

00:18:22.810 --> 00:18:23.200
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:18:23.560 --> 00:18:27.820
<v Speaker 0>Any other questions about the sum.

NOTE CONF {"raw":[100,100,100,100,100,97]}

00:18:30.310 --> 00:18:31.570
<v Speaker 0>Or the concatenation.

NOTE CONF {"raw":[100,100,100]}

00:18:31.570 --> 00:18:36.310
<v Speaker 0>So that's I think intuitively very easy to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:18:36.340 --> 00:18:38.980
<v Speaker 0>Can't get much easier than just sticking the final states

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:38.980 --> 00:18:44.250
<v Speaker 0>to the accepting states and looping is even easier.

NOTE CONF {"raw":[79,100,100,100,100,100,100,100,100]}

00:18:51.180 --> 00:18:51.870
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:18:53.910 --> 00:18:57.210
<v Speaker 0>Do we write down automata in practice when we actually

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:57.210 --> 00:18:58.560
<v Speaker 0>want to recognise languages?

NOTE CONF {"raw":[100,100,95,100]}

00:18:58.590 --> 00:18:59.940
<v Speaker 0>No, of course we don't.

NOTE CONF {"raw":[100,100,100,100,100]}

00:19:00.390 --> 00:19:04.680
<v Speaker 0>So how do we actually write down regular languages when

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:04.680 --> 00:19:08.250
<v Speaker 0>we are writing something to parse a program?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:19:08.580 --> 00:19:11.310
<v Speaker 0>So if you're trying to recognise a piece of Haskell,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:11.700 --> 00:19:15.420
<v Speaker 0>what do you do when you write the program that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:15.420 --> 00:19:18.810
<v Speaker 0>analyses a sequence of characters and says, This is Haskell?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:19.920 --> 00:19:22.110
<v Speaker 0>Well, actually it gets quite complicated.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:19:22.110 --> 00:19:26.220
<v Speaker 0>And if you will do courses on this in third

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:26.220 --> 00:19:31.350
<v Speaker 0>year compiling techniques, um, a bit of advanced warning.

NOTE CONF {"raw":[100,100,100,96,100,100,100,58,100]}

00:19:31.350 --> 00:19:34.740
<v Speaker 0>Compiling techniques has always been one of the hardest courses

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:34.740 --> 00:19:35.790
<v Speaker 0>for most people.

NOTE CONF {"raw":[100,100,100]}

00:19:35.820 --> 00:19:40.320
<v Speaker 0>I hated it, but I had to do it because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:40.320 --> 00:19:42.900
<v Speaker 0>there's lots of technical stuff and it all looks like

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:42.900 --> 00:19:44.730
<v Speaker 0>this, but harder.

NOTE CONF {"raw":[100,100,100]}

00:19:45.720 --> 00:19:48.840
<v Speaker 0>Um, what you want to do is to be able

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:48.840 --> 00:19:52.230
<v Speaker 0>to write a nice, simple textual notation that describes the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:52.230 --> 00:19:57.330
<v Speaker 0>language you're trying to recognise and have some tool, some

NOTE CONF {"raw":[100,100,100,100,91,100,100,100,61,100]}

00:19:57.330 --> 00:20:00.240
<v Speaker 0>program, do the work of turning it into automata and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:00.240 --> 00:20:01.440
<v Speaker 0>running them for you.

NOTE CONF {"raw":[100,100,100,100]}

00:20:03.150 --> 00:20:07.410
<v Speaker 0>So this is where we introduce something that is actually

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:07.410 --> 00:20:09.600
<v Speaker 0>useful in practice.

NOTE CONF {"raw":[100,100,100]}

00:20:09.600 --> 00:20:12.330
<v Speaker 0>So I use these every day pretty much.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:20:13.290 --> 00:20:14.010
<v Speaker 0>Is that true?

NOTE CONF {"raw":[100,100,100]}

00:20:14.040 --> 00:20:15.240
<v Speaker 0>Well, almost every day.

NOTE CONF {"raw":[100,100,100,100]}

00:20:17.340 --> 00:20:20.250
<v Speaker 0>There are things that we call regular expressions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:20:21.870 --> 00:20:27.210
<v Speaker 0>Um, there is a dispute about what the right abbreviation

NOTE CONF {"raw":[100,100,100,73,100,100,100,100,100,100]}

00:20:27.210 --> 00:20:28.800
<v Speaker 0>for regular expression is.

NOTE CONF {"raw":[100,100,100,100]}

00:20:29.130 --> 00:20:32.340
<v Speaker 0>Some people will say regex, which has the advantage of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:32.340 --> 00:20:34.200
<v Speaker 0>being a pronounceable English word.

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:34.590 --> 00:20:38.070
<v Speaker 0>Some people will say regexp, which has the disadvantage of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:38.070 --> 00:20:39.750
<v Speaker 0>not being a proper English word.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:41.880 --> 00:20:47.310
<v Speaker 0>And what they are is a simple, simple programming language

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:47.310 --> 00:20:50.100
<v Speaker 0>with a very simple textual programming language.

NOTE CONF {"raw":[78,100,100,100,100,100,100]}

00:20:50.460 --> 00:20:53.040
<v Speaker 0>And I think I asked you last week whether you'd

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:53.040 --> 00:20:54.720
<v Speaker 0>seen them and a few people have.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:20:55.710 --> 00:20:59.370
<v Speaker 0>I suggested that you go out and find about using

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:59.370 --> 00:21:03.750
<v Speaker 0>them because they will make your life much easier, particularly

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:03.750 --> 00:21:06.570
<v Speaker 0>when you're writing programs and you want to change something.

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:21:06.570 --> 00:21:10.560
<v Speaker 0>So you've all used find and replace in your word

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:10.560 --> 00:21:12.990
<v Speaker 0>processor or your text editor, right?

NOTE CONF {"raw":[100,100,100,100,100,97]}

00:21:15.690 --> 00:21:18.480
<v Speaker 0>I mean, I imagine everybody has used find and replace.

NOTE CONF {"raw":[100,100,100,100,100,87,100,100,100,100]}

00:21:19.110 --> 00:21:22.590
<v Speaker 0>Um, find and replace can be very simple minded.

NOTE CONF {"raw":[69,100,100,100,100,100,100,100,100]}

00:21:23.580 --> 00:21:27.720
<v Speaker 0>So it might just say I want to replace every

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:27.720 --> 00:21:30.660
<v Speaker 0>occurrence of the word foo by the word bar.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:21:30.660 --> 00:21:34.050
<v Speaker 0>But when you have regular expressions and a powerful editor,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:34.050 --> 00:21:38.610
<v Speaker 0>then you can do much more complicated things and replace

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:38.610 --> 00:21:41.100
<v Speaker 0>lots of words at once with a constant part and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,86]}

00:21:41.100 --> 00:21:45.180
<v Speaker 0>a varying part by saying something like.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:49.410 --> 00:21:51.690
<v Speaker 0>Oh, I shouldn't wife over there because it's not visible

NOTE CONF {"raw":[60,100,100,66,100,100,100,100,100,100]}

00:21:51.690 --> 00:21:52.440
<v Speaker 0>online.

NOTE CONF {"raw":[100]}

00:22:21.510 --> 00:22:24.210
<v Speaker 0>Um, don't mean that.

NOTE CONF {"raw":[98,58,76,76]}

00:22:25.680 --> 00:22:26.970
<v Speaker 0>Actually, I didn't mean to do that.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:27.840 --> 00:22:28.590
<v Speaker 0>Forget that.

NOTE CONF {"raw":[100,100]}

00:22:35.660 --> 00:22:39.050
<v Speaker 0>So this is a simple thing.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:39.740 --> 00:22:43.430
<v Speaker 0>Suppose for some reason known best myself.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:45.740 --> 00:22:48.110
<v Speaker 0>Have the audio gone or not?

NOTE CONF {"raw":[41,100,100,100,100,100]}

00:22:49.460 --> 00:22:49.670
<v Speaker 0>Um.

NOTE CONF {"raw":[64]}

00:22:49.670 --> 00:22:52.700
<v Speaker 0>Suppose for some reason known best myself, I've all named

NOTE CONF {"raw":[100,100,100,100,100,100,100,54,100,100]}

00:22:52.700 --> 00:22:57.050
<v Speaker 0>all my variables starting foo, and my boss comes along

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:57.050 --> 00:22:58.730
<v Speaker 0>and says that's not the standard.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:58.730 --> 00:23:01.430
<v Speaker 0>This project names all variables starting bar.

NOTE CONF {"raw":[100,100,100,100,100,100,96]}

00:23:02.390 --> 00:23:03.470
<v Speaker 0>What do I do?

NOTE CONF {"raw":[100,100,100,100]}

00:23:03.500 --> 00:23:06.170
<v Speaker 0>Well, I don't want to go through doing a search

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:06.170 --> 00:23:08.210
<v Speaker 0>and replace on every variable.

NOTE CONF {"raw":[100,100,100,100,100]}

00:23:09.200 --> 00:23:12.230
<v Speaker 0>But what I can do is say look for every

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:12.230 --> 00:23:15.530
<v Speaker 0>word that has the form foo followed by some letters

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:15.740 --> 00:23:17.660
<v Speaker 0>and replace it by.

NOTE CONF {"raw":[100,100,100,100]}

00:23:18.440 --> 00:23:19.700
<v Speaker 0>That should now be one.

NOTE CONF {"raw":[69,100,100,100,100]}

00:23:26.360 --> 00:23:30.230
<v Speaker 0>And replace it by bar, followed by the sequence that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:30.230 --> 00:23:31.190
<v Speaker 0>I found.

NOTE CONF {"raw":[100,100]}

00:23:31.190 --> 00:23:34.160
<v Speaker 0>So that's the kind of thing that one does in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:34.160 --> 00:23:35.060
<v Speaker 0>editors.

NOTE CONF {"raw":[100]}

00:23:37.880 --> 00:23:38.570
<v Speaker 0>A lot.

NOTE CONF {"raw":[100,100]}

00:23:42.170 --> 00:23:44.330
<v Speaker 0>And I'll explain a little bit about the syntax of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:44.330 --> 00:23:45.200
<v Speaker 0>these things.

NOTE CONF {"raw":[100,100]}

00:23:47.450 --> 00:23:49.700
<v Speaker 0>Um, of course, sometimes it's easier just to do the

NOTE CONF {"raw":[72,100,100,100,100,100,100,100,100,100]}

00:23:49.700 --> 00:23:53.630
<v Speaker 0>thing by hand anyway, but it's generally more fun to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:53.630 --> 00:23:55.280
<v Speaker 0>try to work out how to do it with a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:55.280 --> 00:23:57.020
<v Speaker 0>regular expression search.

NOTE CONF {"raw":[100,100,100]}

00:24:00.200 --> 00:24:05.330
<v Speaker 0>Um, now, this is supposed to be partly a theory

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:05.330 --> 00:24:10.460
<v Speaker 0>course, and it's an unfortunate fact that there's a traditional

NOTE CONF {"raw":[100,100,100,100,100,100,100,75,100,100]}

00:24:10.460 --> 00:24:14.420
<v Speaker 0>way of teaching regular expressions in theory courses using one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:14.420 --> 00:24:15.260
<v Speaker 0>notation.

NOTE CONF {"raw":[100]}

00:24:15.260 --> 00:24:18.800
<v Speaker 0>And that notation is not the notation that everybody uses

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:18.800 --> 00:24:22.700
<v Speaker 0>in actual practice in programming languages and editors and everything

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:22.700 --> 00:24:23.210
<v Speaker 0>else.

NOTE CONF {"raw":[100]}

00:24:24.500 --> 00:24:27.410
<v Speaker 0>So I thought I might as well just use the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:27.410 --> 00:24:30.500
<v Speaker 0>programming language editor notation, because that's what you're going to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:30.500 --> 00:24:33.980
<v Speaker 0>use whenever you actually use a regular expression.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:34.160 --> 00:24:36.290
<v Speaker 0>So be aware that if you go and look at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:36.290 --> 00:24:39.080
<v Speaker 0>books, you will find an alternative notation.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:40.430 --> 00:24:41.690
<v Speaker 0>What's the main difference?

NOTE CONF {"raw":[100,100,100,100]}

00:24:41.690 --> 00:24:44.870
<v Speaker 0>When we're doing theory, people tend to write union, whereas

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:24:44.870 --> 00:24:47.930
<v Speaker 0>in programming languages people tend to write a vertical bar

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:47.930 --> 00:24:49.160
<v Speaker 0>symbol for all.

NOTE CONF {"raw":[100,100,35]}

00:24:49.970 --> 00:24:54.290
<v Speaker 0>Um, and in programming languages, we have lots of stuff

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:54.290 --> 00:24:56.960
<v Speaker 0>that makes it shorter and easier to write things.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:24:58.040 --> 00:25:00.860
<v Speaker 0>Have you heard the phrase syntactic sugar before?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:25:03.290 --> 00:25:03.770
<v Speaker 0>Nope.

NOTE CONF {"raw":[90]}

00:25:04.010 --> 00:25:05.360
<v Speaker 0>One or a few people.

NOTE CONF {"raw":[71,62,80,100,100]}

00:25:05.360 --> 00:25:07.070
<v Speaker 0>So syntactic sugar is useful.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:07.070 --> 00:25:07.850
<v Speaker 0>What does it mean?

NOTE CONF {"raw":[100,100,100,100]}

00:25:07.850 --> 00:25:11.810
<v Speaker 0>So it's sweet because it makes everything sweeter and easier

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,100]}

00:25:11.810 --> 00:25:12.590
<v Speaker 0>to do.

NOTE CONF {"raw":[100,100]}

00:25:12.980 --> 00:25:16.250
<v Speaker 0>And it's also unnecessary like sugar.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:25:17.120 --> 00:25:21.770
<v Speaker 0>So syntactic sugar is bits of syntax that make things

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:21.770 --> 00:25:24.440
<v Speaker 0>shorter and easier to write, but which you don't, strictly

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:24.440 --> 00:25:25.580
<v Speaker 0>speaking, need.

NOTE CONF {"raw":[100,100]}

00:25:27.200 --> 00:25:30.410
<v Speaker 0>And most programming languages have quite a lot.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:25:30.410 --> 00:25:33.610
<v Speaker 0>So when you study programming languages that more or less

NOTE CONF {"raw":[100,100,100,100,100,100,50,100,100,100]}

00:25:33.610 --> 00:25:38.020
<v Speaker 0>any level, you will find out that you don't need

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,97,100]}

00:25:38.020 --> 00:25:41.770
<v Speaker 0>for loops, you don't need for loops, because you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:41.770 --> 00:25:45.070
<v Speaker 0>always turn a for loop into a while loop and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:45.070 --> 00:25:45.970
<v Speaker 0>vice versa.

NOTE CONF {"raw":[100,100]}

00:25:46.330 --> 00:25:48.940
<v Speaker 0>So why do we have for loops and while loops?

NOTE CONF {"raw":[100,100,100,100,100,96,100,100,100,100]}

00:25:48.940 --> 00:25:51.970
<v Speaker 0>It's because it's easier sometimes to think about while and

NOTE CONF {"raw":[100,100,100,100,99,100,100,100,100,100]}

00:25:51.970 --> 00:25:57.610
<v Speaker 0>easier to think about for and languages who are designed

NOTE CONF {"raw":[100,100,100,100,94,100,100,100,100,100]}

00:25:57.610 --> 00:25:57.790
<v Speaker 0>for.

NOTE CONF {"raw":[100]}

00:25:57.790 --> 00:26:02.140
<v Speaker 0>People with extreme laziness have more sugar.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:26:02.140 --> 00:26:05.680
<v Speaker 0>So I mentioned my favourite programming language, Perl.

NOTE CONF {"raw":[100,100,100,100,89,100,100,92]}

00:26:05.800 --> 00:26:08.560
<v Speaker 0>It's notable for many things, and it has vast amounts

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:08.560 --> 00:26:12.640
<v Speaker 0>of syntactic sugar and lots of slightly different constructs which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:12.640 --> 00:26:13.750
<v Speaker 0>can confuse you.

NOTE CONF {"raw":[100,100,100]}

00:26:16.000 --> 00:26:22.570
<v Speaker 0>Um, so here's the programming language definition of what a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:22.570 --> 00:26:24.130
<v Speaker 0>regular expression is.

NOTE CONF {"raw":[100,100,100]}

00:26:25.360 --> 00:26:28.630
<v Speaker 0>I'm going to define it in a vaguely mathematical way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:28.720 --> 00:26:30.670
<v Speaker 0>So I'm saying I've got an alphabet.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:26:30.700 --> 00:26:32.950
<v Speaker 0>This is the input alphabet of your automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:26:33.310 --> 00:26:36.670
<v Speaker 0>And I'm going to define the class of regular expressions

NOTE CONF {"raw":[83,100,100,100,100,100,100,100,100,100]}

00:26:36.670 --> 00:26:39.610
<v Speaker 0>in a mathematical way, which is basically the same as

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:39.610 --> 00:26:42.250
<v Speaker 0>defining them in Haskell by a big recursion.

NOTE CONF {"raw":[100,90,91,100,100,100,100,100]}

00:26:44.020 --> 00:26:46.720
<v Speaker 0>And each time I define a new type of regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:46.720 --> 00:26:50.050
<v Speaker 0>expression, I will define the language accepted by them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:26:51.760 --> 00:26:54.010
<v Speaker 0>So my base case is.

NOTE CONF {"raw":[100,100,100,100,100]}

00:26:54.010 --> 00:26:56.710
<v Speaker 0>If a is one of my input symbols, then a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:56.740 --> 00:26:58.810
<v Speaker 0>by itself is a regular expression.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:27:00.100 --> 00:27:01.030
<v Speaker 0>And what's the language?

NOTE CONF {"raw":[100,100,100,100]}

00:27:01.030 --> 00:27:05.080
<v Speaker 0>It accepts a okay.

NOTE CONF {"raw":[100,100,100,88]}

00:27:06.460 --> 00:27:10.480
<v Speaker 0>Epsilon is a regular expression.

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:10.480 --> 00:27:12.220
<v Speaker 0>It's a very special regular expression.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:27:12.220 --> 00:27:14.320
<v Speaker 0>It accepts the empty string.

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:14.890 --> 00:27:16.210
<v Speaker 0>No input at all.

NOTE CONF {"raw":[100,100,100,100]}

00:27:21.460 --> 00:27:21.850
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:27:21.850 --> 00:27:25.360
<v Speaker 0>And the language it accepts is only the empty string.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:29.020 --> 00:27:31.990
<v Speaker 0>Then I'm going to define ways of sticking to regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:31.990 --> 00:27:33.340
<v Speaker 0>expressions together.

NOTE CONF {"raw":[100,100]}

00:27:33.340 --> 00:27:36.340
<v Speaker 0>And this does exactly what you expect it to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:36.340 --> 00:27:39.010
<v Speaker 0>If I've got two regular expressions, r and s and

NOTE CONF {"raw":[100,100,100,100,100,100,98,98,100,100]}

00:27:39.010 --> 00:27:42.310
<v Speaker 0>I write r s, then what I expect to happen

NOTE CONF {"raw":[100,100,89,89,100,100,100,100,100,100]}

00:27:42.310 --> 00:27:45.760
<v Speaker 0>is that it's the strings that have something in R

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:45.760 --> 00:27:48.910
<v Speaker 0>followed by something in S, it's the concatenation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:50.560 --> 00:27:54.130
<v Speaker 0>So if r and s or regex is, then r

NOTE CONF {"raw":[100,100,100,100,95,83,96,96,100,100]}

00:27:54.130 --> 00:27:57.550
<v Speaker 0>s is a regex and the language it accepts is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:57.550 --> 00:28:01.300
<v Speaker 0>the concatenation of the two languages as defined earlier.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:01.300 --> 00:28:07.030
<v Speaker 0>Remember, this means exactly anything that is a string in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:07.030 --> 00:28:09.400
<v Speaker 0>L of are followed by a string in L of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:09.400 --> 00:28:09.940
<v Speaker 0>S.

NOTE CONF {"raw":[100]}

00:28:13.180 --> 00:28:16.000
<v Speaker 0>If I've got two regular expressions, then I can form

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:16.000 --> 00:28:17.890
<v Speaker 0>the sum or the union.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:18.100 --> 00:28:21.520
<v Speaker 0>So this is exactly the same as the automaton.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:21.520 --> 00:28:22.930
<v Speaker 0>Some construction.

NOTE CONF {"raw":[100,100]}

00:28:23.290 --> 00:28:28.330
<v Speaker 0>As I said, most all programming languages I can think

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:28.330 --> 00:28:31.000
<v Speaker 0>of right now, although there must be exceptions, right?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,67]}

00:28:31.000 --> 00:28:33.370
<v Speaker 0>A vertical bar for the all symbol.

NOTE CONF {"raw":[100,100,100,100,100,100,96]}

00:28:34.330 --> 00:28:36.490
<v Speaker 0>And the way you remember that is that it's just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:36.490 --> 00:28:38.500
<v Speaker 0>like the logical or so we're saying.

NOTE CONF {"raw":[100,100,100,95,100,100,100]}

00:28:38.500 --> 00:28:41.830
<v Speaker 0>We're looking for a string that is recognised either by

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:28:41.830 --> 00:28:43.090
<v Speaker 0>R or by S.

NOTE CONF {"raw":[98,100,100,100]}

00:28:46.720 --> 00:28:49.540
<v Speaker 0>Um, finally there's the star.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:50.860 --> 00:28:53.980
<v Speaker 0>So this is the cleaning star that I introduced and

NOTE CONF {"raw":[100,100,100,100,72,100,100,100,100,100]}

00:28:53.980 --> 00:28:55.570
<v Speaker 0>this is the looping operator.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:56.530 --> 00:28:57.700
<v Speaker 0>What do I mean by that?

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:28:57.700 --> 00:29:03.580
<v Speaker 0>I mean it recognises any string that is any number

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:03.580 --> 00:29:09.490
<v Speaker 0>of repetitions including zero of a string recognised by R.

NOTE CONF {"raw":[100,100,100,100,100,100,100,96,100,91]}

00:29:09.490 --> 00:29:13.570
<v Speaker 0>So strings in the language of are repeated any number

NOTE CONF {"raw":[100,100,100,100,100,100,72,100,100,100]}

00:29:13.570 --> 00:29:16.360
<v Speaker 0>of times, different string each time, of course.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:16.360 --> 00:29:20.020
<v Speaker 0>And the zero repetition means that the star operator always

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:20.020 --> 00:29:23.350
<v Speaker 0>includes the empty string, because the zero repetition is just

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:23.350 --> 00:29:24.370
<v Speaker 0>the empty string.

NOTE CONF {"raw":[100,100,100]}

00:29:28.140 --> 00:29:28.380
<v Speaker 0>Um.

NOTE CONF {"raw":[92]}

00:29:29.040 --> 00:29:31.650
<v Speaker 0>That's the kind of formal definition, but it's.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:34.080 --> 00:29:35.370
<v Speaker 0>Relatively obvious.

NOTE CONF {"raw":[100,100]}

00:29:36.330 --> 00:29:36.750
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:29:36.750 --> 00:29:41.220
<v Speaker 0>So that's really just notational definition relating it to automaton.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:41.250 --> 00:29:43.410
<v Speaker 0>Any questions about the notation.

NOTE CONF {"raw":[100,100,100,100,100]}

00:29:51.300 --> 00:29:52.770
<v Speaker 0>A couple of examples.

NOTE CONF {"raw":[95,100,100,100]}

00:29:54.480 --> 00:30:00.750
<v Speaker 0>So the language from a couple of slides ago where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:00.750 --> 00:30:03.930
<v Speaker 0>I was looking for strings that were a sequence of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:04.080 --> 00:30:05.370
<v Speaker 0>a, B or BA.

NOTE CONF {"raw":[100,100,100,100]}

00:30:05.370 --> 00:30:08.520
<v Speaker 0>So that was the automaton where I had a b

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:08.670 --> 00:30:09.390
<v Speaker 0>ba.

NOTE CONF {"raw":[76]}

00:30:09.390 --> 00:30:12.990
<v Speaker 0>And then I looked back in regular expression terms.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:12.990 --> 00:30:17.520
<v Speaker 0>That's just this thing either a, B or bei or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,41,100]}

00:30:17.520 --> 00:30:19.650
<v Speaker 0>ba and I looped them.

NOTE CONF {"raw":[88,100,100,68,100]}

00:30:19.740 --> 00:30:22.500
<v Speaker 0>So the star operator is essentially looping.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:30:24.330 --> 00:30:28.710
<v Speaker 0>This is the one that demonstrated the concatenation of two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:28.710 --> 00:30:30.720
<v Speaker 0>languages as well as some looping.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:30:31.140 --> 00:30:33.960
<v Speaker 0>So this is the one where strings have to start

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:33.960 --> 00:30:35.730
<v Speaker 0>with either A or B.

NOTE CONF {"raw":[100,100,92,100,87]}

00:30:36.570 --> 00:30:38.970
<v Speaker 0>After that, they can do anything as long as they

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:38.970 --> 00:30:40.260
<v Speaker 0>end with a b.

NOTE CONF {"raw":[100,100,100,100]}

00:30:41.970 --> 00:30:44.550
<v Speaker 0>And this kind of expression is about the level of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:44.550 --> 00:30:47.730
<v Speaker 0>complexity that you will typically be working in practice.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:49.950 --> 00:30:54.330
<v Speaker 0>This one is extremely hard to work out, so I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:54.330 --> 00:30:56.250
<v Speaker 0>have to admit that I did not work this out

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:56.250 --> 00:30:56.940
<v Speaker 0>by myself.

NOTE CONF {"raw":[100,100]}

00:30:56.940 --> 00:30:58.680
<v Speaker 0>I tried for a while and then I gave up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:58.680 --> 00:30:59.340
<v Speaker 0>and googled it.

NOTE CONF {"raw":[100,100,100]}

00:31:00.210 --> 00:31:02.160
<v Speaker 0>Um, it is possible to.

NOTE CONF {"raw":[98,100,100,100,100]}

00:31:02.190 --> 00:31:07.110
<v Speaker 0>We know that we can write down a deterministic finite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:07.110 --> 00:31:10.380
<v Speaker 0>automaton for the language with an even number of zeros.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,86]}

00:31:10.410 --> 00:31:14.100
<v Speaker 0>We did that early last week, and therefore there must

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:14.100 --> 00:31:17.520
<v Speaker 0>be a regular expression describing it, but it turns out

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:17.520 --> 00:31:19.230
<v Speaker 0>not to be at all simple.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:20.130 --> 00:31:23.820
<v Speaker 0>So you might like to go away and think about

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:24.450 --> 00:31:29.640
<v Speaker 0>Why it is that this regular expression is so much

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:29.640 --> 00:31:33.900
<v Speaker 0>more complicated than the very simple DFA that we were

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:33.900 --> 00:31:35.550
<v Speaker 0>able to write last week.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:35.910 --> 00:31:37.890
<v Speaker 0>And to think about that, go and look at the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:37.890 --> 00:31:41.310
<v Speaker 0>DFA and then think about trying to turn it into

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:41.310 --> 00:31:44.850
<v Speaker 0>a regular expression, just by using your native wit and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,89,100]}

00:31:44.850 --> 00:31:47.460
<v Speaker 0>following your nose and seeing where you end up.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:31:50.310 --> 00:31:50.700
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:31:53.340 --> 00:31:55.380
<v Speaker 0>So this is not the kind of thing that you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:55.380 --> 00:31:58.620
<v Speaker 0>typically write down in a programming language.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:31:59.160 --> 00:32:01.830
<v Speaker 0>If you need, if when you're writing a parser, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:01.830 --> 00:32:04.140
<v Speaker 0>actually need to look at strings with an even number

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:04.140 --> 00:32:04.950
<v Speaker 0>of zeros in it.

NOTE CONF {"raw":[100,87,100,100]}

00:32:04.980 --> 00:32:07.590
<v Speaker 0>You'll probably have a separate function to count it, because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:07.590 --> 00:32:10.920
<v Speaker 0>that's less work than actually writing this regular expression.

NOTE CONF {"raw":[100,100,100,86,100,100,100,100,100]}

00:32:13.650 --> 00:32:14.040
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:32:16.500 --> 00:32:19.170
<v Speaker 0>So regular regular expressions are syntax.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:32:19.170 --> 00:32:20.400
<v Speaker 0>What can they do?

NOTE CONF {"raw":[100,100,100,100]}

00:32:20.730 --> 00:32:28.010
<v Speaker 0>Well, regular expressions are constructed by reference to automata.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:28.010 --> 00:32:32.750
<v Speaker 0>So the constructions I gave you for regular expressions were

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:32.750 --> 00:32:34.130
<v Speaker 0>concatenation.

NOTE CONF {"raw":[100]}

00:32:34.160 --> 00:32:35.270
<v Speaker 0>Some.

NOTE CONF {"raw":[100]}

00:32:37.310 --> 00:32:38.240
<v Speaker 0>Looping.

NOTE CONF {"raw":[100]}

00:32:39.740 --> 00:32:40.370
<v Speaker 0>Was that it?

NOTE CONF {"raw":[100,100,100]}

00:32:40.370 --> 00:32:41.030
<v Speaker 0>That was it.

NOTE CONF {"raw":[100,100,100]}

00:32:41.240 --> 00:32:45.230
<v Speaker 0>So these are the same operations that we had for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:45.230 --> 00:32:47.450
<v Speaker 0>non-deterministic finite automata.

NOTE CONF {"raw":[52,100,100]}

00:32:48.590 --> 00:32:53.660
<v Speaker 0>And therefore it's completely straightforward to take a regular expression

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:53.660 --> 00:32:57.050
<v Speaker 0>and draw its automaton as long as you're drawing a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:57.050 --> 00:32:58.730
<v Speaker 0>non-deterministic automaton.

NOTE CONF {"raw":[62,100]}

00:32:59.360 --> 00:33:01.610
<v Speaker 0>And I claim that it's so easy that it wasn't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:01.610 --> 00:33:05.990
<v Speaker 0>even worth my while spelling it out in detail because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:05.990 --> 00:33:09.890
<v Speaker 0>you just match plus to, plus sorry bar to plus

NOTE CONF {"raw":[100,100,100,100,88,100,100,89,100,100]}

00:33:10.190 --> 00:33:13.190
<v Speaker 0>concatenation to concatenation, and star to loop.

NOTE CONF {"raw":[100,100,100,100,96,100,100]}

00:33:14.690 --> 00:33:16.940
<v Speaker 0>If you really need to see it spelt out in

NOTE CONF {"raw":[100,100,100,100,100,100,100,68,100,100]}

00:33:16.940 --> 00:33:19.400
<v Speaker 0>detail, then the details are in the book because the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:19.400 --> 00:33:20.900
<v Speaker 0>book has all the details.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:22.730 --> 00:33:25.040
<v Speaker 0>What does that let us conclude?

NOTE CONF {"raw":[100,100,100,51,51,100]}

00:33:26.210 --> 00:33:32.900
<v Speaker 0>Well, we know now that if we have a regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:32.900 --> 00:33:37.940
<v Speaker 0>expression, it's language, the language that is recognised by the

NOTE CONF {"raw":[100,100,100,100,100,100,100,86,100,100]}

00:33:37.940 --> 00:33:39.170
<v Speaker 0>regular expression.

NOTE CONF {"raw":[100,100]}

00:33:39.440 --> 00:33:43.820
<v Speaker 0>Is the language recognised by a nondeterministic finite automaton.

NOTE CONF {"raw":[100,100,100,92,100,100,68,100,100]}

00:33:43.940 --> 00:33:45.800
<v Speaker 0>And that means it's a regular language.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:45.800 --> 00:33:49.910
<v Speaker 0>So it's also the language recognised by a deterministic automaton.

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:33:49.910 --> 00:33:52.220
<v Speaker 0>So if we wanted we could determine size it and

NOTE CONF {"raw":[100,100,100,100,100,100,100,45,100,100]}

00:33:52.220 --> 00:33:53.180
<v Speaker 0>blah blah blah.

NOTE CONF {"raw":[100,100,100]}

00:33:54.350 --> 00:33:59.210
<v Speaker 0>So everything is the same regular expressions dfas nfus.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,50]}

00:33:59.210 --> 00:34:03.230
<v Speaker 0>They all recognise the same classes of language, which is

NOTE CONF {"raw":[100,100,94,100,100,100,100,100,100,100]}

00:34:03.230 --> 00:34:06.350
<v Speaker 0>a reason why the regular languages are a very nice

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:06.350 --> 00:34:08.870
<v Speaker 0>class, a nice and simple class.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:34:11.659 --> 00:34:18.560
<v Speaker 0>Um, so you can think about one thing you might

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:18.560 --> 00:34:19.310
<v Speaker 0>want to think about.

NOTE CONF {"raw":[100,100,100,100]}

00:34:19.310 --> 00:34:21.740
<v Speaker 0>This is just a little exercise to do afterwards.

NOTE CONF {"raw":[100,73,100,95,100,100,100,100,100]}

00:34:22.310 --> 00:34:24.590
<v Speaker 0>Take this regular expression a b.

NOTE CONF {"raw":[100,100,100,100,97,96]}

00:34:24.590 --> 00:34:28.639
<v Speaker 0>So view this as a regular expression and apply the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:28.639 --> 00:34:32.210
<v Speaker 0>constructions to it and see what you come up with.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:32.389 --> 00:34:34.790
<v Speaker 0>And then just write down the automaton that you would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:34.790 --> 00:34:37.460
<v Speaker 0>naturally write and think about why they're different.

NOTE CONF {"raw":[100,100,100,100,100,100,95,100]}

00:34:40.730 --> 00:34:42.980
<v Speaker 0>Um, actually, I'm going to do it for you, so

NOTE CONF {"raw":[100,78,100,100,100,100,100,100,100,100]}

00:34:42.980 --> 00:34:45.379
<v Speaker 0>I'm going to hastily skip over it and let you

NOTE CONF {"raw":[100,100,93,100,100,100,100,100,100,100]}

00:34:45.379 --> 00:34:46.100
<v Speaker 0>think about it.

NOTE CONF {"raw":[100,100,100]}

00:34:46.520 --> 00:34:47.780
<v Speaker 0>Don't look at the slide.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:50.090 --> 00:34:55.490
<v Speaker 0>Um, it shouldn't be surprising to you that this was

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:55.490 --> 00:34:56.389
<v Speaker 0>a two way thing.

NOTE CONF {"raw":[100,100,100,100]}

00:34:56.389 --> 00:35:00.350
<v Speaker 0>So a regular expression describes a language that is regular.

NOTE CONF {"raw":[100,100,100,100,100,97,100,100,100,100]}

00:35:01.280 --> 00:35:04.910
<v Speaker 0>If I take any regular language, I can build a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:04.910 --> 00:35:06.950
<v Speaker 0>regular expression to describe it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:09.020 --> 00:35:11.570
<v Speaker 0>You might think that this should be easy as well.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:11.690 --> 00:35:13.730
<v Speaker 0>Unfortunately, it isn't easy.

NOTE CONF {"raw":[100,100,100,100]}

00:35:13.760 --> 00:35:20.720
<v Speaker 0>It requires work, and there are two ways to do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:20.720 --> 00:35:21.260
<v Speaker 0>it.

NOTE CONF {"raw":[100]}

00:35:21.860 --> 00:35:26.810
<v Speaker 0>The book describes, first of all, the way that I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:26.810 --> 00:35:29.090
<v Speaker 0>think is harder to understand.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:29.690 --> 00:35:31.850
<v Speaker 0>Therefore, I'm going to give you the other way because

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:31.850 --> 00:35:34.310
<v Speaker 0>I think it's much easier to understand, and it's also

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:34.310 --> 00:35:35.780
<v Speaker 0>easier to do in practice.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:37.100 --> 00:35:41.930
<v Speaker 0>So the way in the book basically proceeds by solving

NOTE CONF {"raw":[100,100,100,100,100,100,100,67,100,100]}

00:35:41.930 --> 00:35:46.400
<v Speaker 0>equations in regular expressions, which is another level of conceptual

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:46.400 --> 00:35:48.590
<v Speaker 0>burden that I don't think we need.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:49.700 --> 00:35:52.070
<v Speaker 0>Whereas there is a way where you can do it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:52.070 --> 00:35:55.520
<v Speaker 0>just by mashing things together until you get the answer.

NOTE CONF {"raw":[100,100,65,100,100,100,100,100,100,100]}

00:35:57.350 --> 00:36:02.090
<v Speaker 0>So my problem is, given an automaton, how do I

NOTE CONF {"raw":[100,100,100,100,100,83,100,100,100,100]}

00:36:02.090 --> 00:36:06.890
<v Speaker 0>compute the regular expression that accepts exactly the same language?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:08.870 --> 00:36:13.490
<v Speaker 0>And essentially the idea is to introduce a more complicated

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:13.490 --> 00:36:18.170
<v Speaker 0>notion of transition and start smashing states together and instead

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:18.170 --> 00:36:20.740
<v Speaker 0>writing more complicated transition labels.

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:20.890 --> 00:36:23.530
<v Speaker 0>So the fundamental example of doing this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:23.830 --> 00:36:26.500
<v Speaker 0>Here's an automaton that accepts a b.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:36:26.500 --> 00:36:28.810
<v Speaker 0>So this is the one I would naturally write down

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:28.810 --> 00:36:30.070
<v Speaker 0>to represent a b.

NOTE CONF {"raw":[100,100,87,87]}

00:36:32.110 --> 00:36:34.780
<v Speaker 0>And I want to turn this into a regular expression.

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:36:34.960 --> 00:36:36.640
<v Speaker 0>Well I look at this state.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:36:37.390 --> 00:36:40.450
<v Speaker 0>I observe that I could just delete it and say

NOTE CONF {"raw":[100,65,100,100,100,100,100,100,100,100]}

00:36:40.450 --> 00:36:42.880
<v Speaker 0>that I can write an arrow that is labelled by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,100]}

00:36:42.880 --> 00:36:46.180
<v Speaker 0>a b, because if I see a B, I have

NOTE CONF {"raw":[71,71,100,100,100,98,100,100,100,100]}

00:36:46.180 --> 00:36:47.140
<v Speaker 0>to go through this state.

NOTE CONF {"raw":[100,100,100,93,100]}

00:36:47.140 --> 00:36:49.510
<v Speaker 0>So I might just as well say there's a single

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:49.510 --> 00:36:52.990
<v Speaker 0>arrow which reads A and B it in sequence all

NOTE CONF {"raw":[100,100,100,100,100,100,81,100,100,100]}

00:36:52.990 --> 00:36:53.770
<v Speaker 0>at once.

NOTE CONF {"raw":[100,100]}

00:36:55.780 --> 00:36:57.940
<v Speaker 0>Where does life get complicated?

NOTE CONF {"raw":[100,100,100,100,100]}

00:36:58.150 --> 00:37:02.380
<v Speaker 0>Well, life gets a little bit complicated if there are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,97]}

00:37:02.380 --> 00:37:04.420
<v Speaker 0>loops, but not very hard.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:04.960 --> 00:37:07.900
<v Speaker 0>So self loops are often tricky.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:07.930 --> 00:37:11.860
<v Speaker 0>We've written this construction often this is strings that start

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:11.860 --> 00:37:14.770
<v Speaker 0>with an A and end with a B with anything

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:14.770 --> 00:37:15.610
<v Speaker 0>in between.

NOTE CONF {"raw":[100,100]}

00:37:16.030 --> 00:37:18.430
<v Speaker 0>Well, self loops turn out to be very easy to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:18.430 --> 00:37:21.280
<v Speaker 0>describe because they just look like this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:37:22.660 --> 00:37:25.300
<v Speaker 0>I look at the symbols on this arrow that's A

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:25.300 --> 00:37:27.280
<v Speaker 0>and B, and then I say I can just do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:27.280 --> 00:37:28.960
<v Speaker 0>those any number of times.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:31.540 --> 00:37:34.690
<v Speaker 0>Um, so far so good.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:34.720 --> 00:37:36.670
<v Speaker 0>Notice that I've used several constructions.

NOTE CONF {"raw":[100,100,100,100,100,71]}

00:37:36.670 --> 00:37:40.390
<v Speaker 0>So I've used concatenation to concatenate.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:37:41.050 --> 00:37:45.550
<v Speaker 0>And I've used or here to combine a multiple transitions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,67,100,99]}

00:37:45.580 --> 00:37:48.400
<v Speaker 0>Remember this is really a shortcut for two arrows one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:48.400 --> 00:37:50.320
<v Speaker 0>labelled A and one labelled B.

NOTE CONF {"raw":[100,86,100,100,94,100]}

00:37:50.320 --> 00:37:52.780
<v Speaker 0>And I've combined them together with or.

NOTE CONF {"raw":[100,100,98,100,100,100,67]}

00:37:53.950 --> 00:37:56.500
<v Speaker 0>And then I've used the looping construct because this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:56.500 --> 00:37:58.510
<v Speaker 0>a loop that I can go around any number of

NOTE CONF {"raw":[100,100,100,100,100,100,83,100,100,100]}

00:37:58.510 --> 00:38:00.340
<v Speaker 0>times, including none at all.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:02.770 --> 00:38:05.260
<v Speaker 0>Um, but it's maybe a bit harder to see.

NOTE CONF {"raw":[100,100,95,95,100,100,100,100,100]}

00:38:05.260 --> 00:38:07.330
<v Speaker 0>What do we do if there are loops here in

NOTE CONF {"raw":[100,100,100,100,100,100,67,100,100,100]}

00:38:07.330 --> 00:38:08.080
<v Speaker 0>the initial state?

NOTE CONF {"raw":[100,100,100]}

00:38:08.080 --> 00:38:09.610
<v Speaker 0>What do we do if they were loops in the

NOTE CONF {"raw":[100,100,100,100,100,62,89,100,100,100]}

00:38:09.610 --> 00:38:10.720
<v Speaker 0>final state?

NOTE CONF {"raw":[100,100]}

00:38:13.870 --> 00:38:17.170
<v Speaker 0>Um, that's a slightly harder problem to deal with.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:38:17.170 --> 00:38:19.450
<v Speaker 0>If you try to do the obvious thing, you'll find

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:19.450 --> 00:38:20.530
<v Speaker 0>it doesn't work.

NOTE CONF {"raw":[100,100,100]}

00:38:22.030 --> 00:38:26.080
<v Speaker 0>So what we do is use epsilon transitions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:38:26.710 --> 00:38:30.940
<v Speaker 0>Here's an automaton which has some initial states and some

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:30.940 --> 00:38:32.050
<v Speaker 0>final states.

NOTE CONF {"raw":[100,100]}

00:38:32.530 --> 00:38:35.410
<v Speaker 0>It would be easier if there were just one initial

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:35.410 --> 00:38:38.290
<v Speaker 0>state, which there is, and just one final state which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:38.290 --> 00:38:39.070
<v Speaker 0>there isn't.

NOTE CONF {"raw":[100,100]}

00:38:39.430 --> 00:38:43.450
<v Speaker 0>With Epsilon, we can take any automaton and make a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:43.450 --> 00:38:47.110
<v Speaker 0>special initial state that is distinct from the original automaton,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:47.230 --> 00:38:49.840
<v Speaker 0>and a special final state that is distinct from the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:49.840 --> 00:38:53.830
<v Speaker 0>original automaton, so that we only have one beginning and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:53.830 --> 00:38:55.360
<v Speaker 0>one end to worry about.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:55.480 --> 00:38:58.390
<v Speaker 0>So all I'm doing here is saying I'm adding a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:58.390 --> 00:39:01.600
<v Speaker 0>new dummy state, which then leads to the original real

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:01.600 --> 00:39:06.100
<v Speaker 0>initial state, and I'm adding a new dummy final state,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:06.100 --> 00:39:08.800
<v Speaker 0>which all the original final states lead to.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:39:09.970 --> 00:39:13.870
<v Speaker 0>Once you've done this, then these things can be concatenated

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:13.870 --> 00:39:17.340
<v Speaker 0>very straightforwardly just by gluing together this state with that

NOTE CONF {"raw":[100,100,100,100,96,100,100,100,100,100]}

00:39:17.340 --> 00:39:17.940
<v Speaker 0>state.

NOTE CONF {"raw":[100]}

00:39:21.240 --> 00:39:24.090
<v Speaker 0>So now we repeat.

NOTE CONF {"raw":[100,100,100,100]}

00:39:24.090 --> 00:39:26.430
<v Speaker 0>So in this one I would start by I would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:26.430 --> 00:39:30.030
<v Speaker 0>remove that state and replace it by an ab arrow.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,64,83]}

00:39:30.180 --> 00:39:32.550
<v Speaker 0>I would remove that state and replace it by a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:32.580 --> 00:39:34.080
<v Speaker 0>bar arrow.

NOTE CONF {"raw":[37,78]}

00:39:34.230 --> 00:39:37.170
<v Speaker 0>Then I would union these two transitions to get a

NOTE CONF {"raw":[100,98,98,100,100,100,100,100,100,100]}

00:39:37.200 --> 00:39:39.390
<v Speaker 0>BA or a B and so on.

NOTE CONF {"raw":[100,100,94,94,100,100,100]}

00:39:41.130 --> 00:39:44.100
<v Speaker 0>It's straightforward and it's easy to program and it's quite

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,99]}

00:39:44.220 --> 00:39:46.110
<v Speaker 0>we don't ask you to program it I don't think,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:46.110 --> 00:39:47.730
<v Speaker 0>but it's quite a good exercise.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:47.760 --> 00:39:50.400
<v Speaker 0>What we end up with when we do this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:50.400 --> 00:39:55.200
<v Speaker 0>one arrow from the dummy initial to the dummy end

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:55.200 --> 00:39:57.690
<v Speaker 0>with an enormous regular expression on it, which is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:57.690 --> 00:40:00.690
<v Speaker 0>one we want, which describes all the strings accepted.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:40:02.580 --> 00:40:07.260
<v Speaker 0>So that procedure, I think, is quite easy to understand

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:07.260 --> 00:40:08.100
<v Speaker 0>and do.

NOTE CONF {"raw":[100,100]}

00:40:08.400 --> 00:40:12.420
<v Speaker 0>And that means that we have proved that the regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:12.420 --> 00:40:15.870
<v Speaker 0>expressions describe exactly the regular language.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:16.380 --> 00:40:19.890
<v Speaker 0>Every regular language has a regular expression, and every regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:19.890 --> 00:40:22.410
<v Speaker 0>expression describes a regular language.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:24.090 --> 00:40:26.730
<v Speaker 0>Um, as I said, the book describes the other technique,

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:40:26.730 --> 00:40:28.890
<v Speaker 0>which is the one that I was taught when I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:28.890 --> 00:40:31.050
<v Speaker 0>did this kind, of course, as a student.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:32.040 --> 00:40:36.120
<v Speaker 0>Um, it might be easier to program, but I found

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:40:36.120 --> 00:40:38.700
<v Speaker 0>it much harder to understand intuitively.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:39.120 --> 00:40:39.900
<v Speaker 0>Do go away.

NOTE CONF {"raw":[100,100,100]}

00:40:39.900 --> 00:40:40.830
<v Speaker 0>Have a look at it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:40.830 --> 00:40:42.600
<v Speaker 0>You might think differently from me.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:43.470 --> 00:40:48.090
<v Speaker 0>And as I say, if you're feeling relatively strong, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:48.090 --> 00:40:49.260
<v Speaker 0>have enough coffee inside.

NOTE CONF {"raw":[100,100,100,100]}

00:40:49.260 --> 00:40:52.140
<v Speaker 0>You try doing this technique on the even odds and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:52.140 --> 00:40:54.810
<v Speaker 0>even one machine, and see whether you end up with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:54.810 --> 00:40:56.580
<v Speaker 0>that regular expression or not.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:59.310 --> 00:41:01.860
<v Speaker 0>Okay, so that's quite a lot of new notation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:41:01.860 --> 00:41:04.410
<v Speaker 0>Again, this has been a very heavy week for notation,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:04.410 --> 00:41:07.860
<v Speaker 0>which maybe not the ideal way to end the core

NOTE CONF {"raw":[95,83,100,100,100,100,100,100,100,100]}

00:41:07.860 --> 00:41:10.260
<v Speaker 0>content of a course, but hey, we have to teach

NOTE CONF {"raw":[100,100,58,100,100,94,100,100,100,100]}

00:41:10.260 --> 00:41:10.590
<v Speaker 0>it.

NOTE CONF {"raw":[100]}

00:41:10.920 --> 00:41:13.350
<v Speaker 0>Any questions on this stuff.

NOTE CONF {"raw":[100,100,100,100,100]}

00:41:17.100 --> 00:41:19.290
<v Speaker 0>We do, of course, have next week for you to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:19.290 --> 00:41:20.820
<v Speaker 0>ask questions if you need it.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:22.200 --> 00:41:26.580
<v Speaker 0>Um, I want to finish off this topic by saying

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:26.580 --> 00:41:29.190
<v Speaker 0>a little bit about a little bit more about regular

NOTE CONF {"raw":[100,100,100,75,100,100,100,100,100,100]}

00:41:29.190 --> 00:41:30.870
<v Speaker 0>expressions in real life.

NOTE CONF {"raw":[100,100,100,100]}

00:41:31.050 --> 00:41:33.090
<v Speaker 0>I said they had syntactic sugar.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:33.120 --> 00:41:35.760
<v Speaker 0>I haven't introduced much syntactic sugar.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:35.910 --> 00:41:42.060
<v Speaker 0>So for your practical education, rather than your theory education,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:42.060 --> 00:41:43.980
<v Speaker 0>let me mention a few of the things that you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:43.980 --> 00:41:48.390
<v Speaker 0>will see in most actual implementations of regular expressions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:41:51.000 --> 00:41:55.680
<v Speaker 0>So these are things that pretty much every implementation has

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:55.860 --> 00:41:57.000
<v Speaker 0>in fact.

NOTE CONF {"raw":[100,100]}

00:41:58.230 --> 00:42:02.340
<v Speaker 0>Um, though is pretty much a standard implementation of regular

NOTE CONF {"raw":[96,41,74,100,100,100,100,100,100,100]}

00:42:02.340 --> 00:42:02.790
<v Speaker 0>expressions.

NOTE CONF {"raw":[67]}

00:42:02.820 --> 00:42:05.130
<v Speaker 0>Well, there are two standards because you can never have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:05.130 --> 00:42:06.420
<v Speaker 0>enough standards, right?

NOTE CONF {"raw":[100,100,100]}

00:42:06.930 --> 00:42:09.030
<v Speaker 0>So anybody heard of Posix?

NOTE CONF {"raw":[100,100,100,100,100]}

00:42:11.040 --> 00:42:11.700
<v Speaker 0>No.

NOTE CONF {"raw":[98]}

00:42:11.720 --> 00:42:12.230
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:42:12.230 --> 00:42:16.700
<v Speaker 0>So Posix is an international standard for Unix like operating

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,100]}

00:42:16.700 --> 00:42:21.530
<v Speaker 0>systems and most operating systems.

NOTE CONF {"raw":[100,100,100,100,100]}

00:42:21.530 --> 00:42:24.740
<v Speaker 0>So it's the operating system and the whole programming environment.

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,100,100]}

00:42:25.160 --> 00:42:26.660
<v Speaker 0>And it was designed for Unix.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:42:26.660 --> 00:42:29.750
<v Speaker 0>But these days almost everything else has a Posix compatible

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:29.750 --> 00:42:31.340
<v Speaker 0>mode, even windows.

NOTE CONF {"raw":[100,100,100]}

00:42:31.700 --> 00:42:35.480
<v Speaker 0>And one of the things that Posix does, Posix does

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:35.480 --> 00:42:39.380
<v Speaker 0>is define regular expressions in what was the traditional Unix

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:39.380 --> 00:42:40.010
<v Speaker 0>way.

NOTE CONF {"raw":[100]}

00:42:41.330 --> 00:42:41.570
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:42:42.620 --> 00:42:47.150
<v Speaker 0>However, I mentioned my favourite programming language, Perl, many times,

NOTE CONF {"raw":[100,100,100,100,90,100,100,100,100,100]}

00:42:47.150 --> 00:42:50.360
<v Speaker 0>and one of the really striking features of Perl is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:50.360 --> 00:42:53.330
<v Speaker 0>that it has regular expressions on steroids.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:42:53.870 --> 00:42:57.680
<v Speaker 0>Not so much on steroids as on every illegal drug

NOTE CONF {"raw":[100,100,100,100,100,76,100,100,100,100]}

00:42:57.680 --> 00:42:59.810
<v Speaker 0>you can think of, and then some that you haven't

NOTE CONF {"raw":[100,90,100,100,100,100,100,100,100,100]}

00:42:59.810 --> 00:43:02.450
<v Speaker 0>thought of because they're very, very useful.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:43:02.660 --> 00:43:06.350
<v Speaker 0>And actually, Perl's regular expressions are not regular expressions.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:43:06.350 --> 00:43:07.880
<v Speaker 0>They're much more powerful.

NOTE CONF {"raw":[100,100,100,100]}

00:43:07.880 --> 00:43:09.740
<v Speaker 0>And that's something I have a talk about, which I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:09.740 --> 00:43:11.510
<v Speaker 0>probably won't have time to do next week, but you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:11.510 --> 00:43:12.230
<v Speaker 0>never know.

NOTE CONF {"raw":[100,100]}

00:43:12.860 --> 00:43:18.470
<v Speaker 0>Um, and people like them so much that almost all

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:18.470 --> 00:43:21.920
<v Speaker 0>regular expression libraries, including the ones used in your browsers

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:21.920 --> 00:43:24.770
<v Speaker 0>and so on, now have a mode where they support

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:24.770 --> 00:43:28.910
<v Speaker 0>P-series Perl compatible regular expressions.

NOTE CONF {"raw":[58,100,100,100,100]}

00:43:30.950 --> 00:43:32.030
<v Speaker 0>These are not PCR.

NOTE CONF {"raw":[100,100,100,89]}

00:43:32.270 --> 00:43:34.520
<v Speaker 0>These are quite old fashioned ones.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:35.210 --> 00:43:37.010
<v Speaker 0>Well, these are also pieces.

NOTE CONF {"raw":[96,100,100,100,98]}

00:43:37.730 --> 00:43:40.760
<v Speaker 0>So one of the very common ones is something we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:40.760 --> 00:43:43.790
<v Speaker 0>want to do a lot is to say I want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:43.790 --> 00:43:46.400
<v Speaker 0>to look at words starting with a vowel, starting with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:46.400 --> 00:43:50.660
<v Speaker 0>a consonant, or starting with some other bunch of characters.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:50.870 --> 00:43:53.330
<v Speaker 0>And it would be a real pain to write down

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:53.330 --> 00:43:55.640
<v Speaker 0>A or B, or C.

NOTE CONF {"raw":[100,100,100,100,100]}

00:43:55.670 --> 00:43:57.890
<v Speaker 0>Well, I can just write down a, b, c in

NOTE CONF {"raw":[96,100,100,100,100,100,82,82,82,99]}

00:43:57.890 --> 00:43:58.880
<v Speaker 0>square brackets.

NOTE CONF {"raw":[100,100]}

00:43:59.270 --> 00:44:02.780
<v Speaker 0>So the square bracket notation is used a lot.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:44:04.640 --> 00:44:06.770
<v Speaker 0>It's a real pain to write down a, b, c,

NOTE CONF {"raw":[100,100,100,100,100,100,100,74,74,74]}

00:44:06.800 --> 00:44:08.900
<v Speaker 0>d, e, f when you can just write down a

NOTE CONF {"raw":[74,43,74,100,100,100,100,100,100,100]}

00:44:08.930 --> 00:44:12.950
<v Speaker 0>to F, so that we use a lot in programming

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:12.950 --> 00:44:16.400
<v Speaker 0>language syntax analysis.

NOTE CONF {"raw":[100,100,100]}

00:44:17.870 --> 00:44:20.450
<v Speaker 0>This is an example of a simple regular expression, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:20.450 --> 00:44:24.320
<v Speaker 0>we want to complement a lot because we often want

NOTE CONF {"raw":[100,100,100,85,100,100,100,100,100,100]}

00:44:24.320 --> 00:44:24.950
<v Speaker 0>to talk about.

NOTE CONF {"raw":[100,100,100]}

00:44:24.950 --> 00:44:28.670
<v Speaker 0>I want my piece of syntax to contain any character

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:28.670 --> 00:44:29.870
<v Speaker 0>except something.

NOTE CONF {"raw":[100,100]}

00:44:30.800 --> 00:44:34.970
<v Speaker 0>Um, how many of you have been annoyed by inventing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:34.970 --> 00:44:37.610
<v Speaker 0>a password for some site and it telling you it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:37.610 --> 00:44:41.630
<v Speaker 0>is not a valid password without explaining why it's not

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:41.630 --> 00:44:42.260
<v Speaker 0>valid?

NOTE CONF {"raw":[100]}

00:44:43.040 --> 00:44:45.290
<v Speaker 0>Now, if only they would tell you the regular expression

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:45.290 --> 00:44:46.100
<v Speaker 0>you had to match.

NOTE CONF {"raw":[100,100,100,100]}

00:44:46.100 --> 00:44:49.010
<v Speaker 0>You could do it because there is a regular expression

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:49.010 --> 00:44:51.650
<v Speaker 0>in there somewhere, which is it is matching against.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:44:54.320 --> 00:44:57.980
<v Speaker 0>So negated character classes are very common.

NOTE CONF {"raw":[100,100,100,100,97,100,100]}

00:44:58.970 --> 00:45:01.010
<v Speaker 0>Optionality is useful.

NOTE CONF {"raw":[100,100,100]}

00:45:01.010 --> 00:45:05.120
<v Speaker 0>So we often want to say I want a word

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:05.120 --> 00:45:07.370
<v Speaker 0>optionally followed by some other word.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:45:07.940 --> 00:45:10.820
<v Speaker 0>We can write that as the empty string or the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:10.820 --> 00:45:13.700
<v Speaker 0>word itself, but we do it so often that we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:13.700 --> 00:45:18.500
<v Speaker 0>have a question mark saying optional regular expression, optional expression.

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100,100]}

00:45:20.480 --> 00:45:22.910
<v Speaker 0>Um, we also quite often want to say I want

NOTE CONF {"raw":[87,100,100,100,100,100,100,100,100,100]}

00:45:22.910 --> 00:45:26.990
<v Speaker 0>at least one of something that happens all the time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:27.140 --> 00:45:30.440
<v Speaker 0>So that's exactly the same as writing down R followed

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,87,100]}

00:45:30.440 --> 00:45:33.590
<v Speaker 0>by R star, because this is one followed by at

NOTE CONF {"raw":[100,90,100,100,100,100,100,100,100,100]}

00:45:33.590 --> 00:45:34.850
<v Speaker 0>least zero of them.

NOTE CONF {"raw":[100,100,100,100]}

00:45:35.480 --> 00:45:39.500
<v Speaker 0>But we do it so often that almost every expression

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:39.500 --> 00:45:42.020
<v Speaker 0>library lets you just write our plus.

NOTE CONF {"raw":[100,97,100,100,100,60,97]}

00:45:44.630 --> 00:45:49.910
<v Speaker 0>And something that is used a great deal is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:49.910 --> 00:45:52.040
<v Speaker 0>single wildcard character.

NOTE CONF {"raw":[100,100,100]}

00:45:54.050 --> 00:45:56.090
<v Speaker 0>In most libraries it's a dot.

NOTE CONF {"raw":[100,100,100,100,100,81]}

00:45:56.090 --> 00:45:58.490
<v Speaker 0>So full stop doesn't mean full stop.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:58.490 --> 00:46:00.590
<v Speaker 0>Full stop means any character.

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:02.510 --> 00:46:05.270
<v Speaker 0>It gets a little bit more complicated because in programming

NOTE CONF {"raw":[100,100,100,100,75,100,100,100,100,100]}

00:46:05.270 --> 00:46:07.480
<v Speaker 0>languages and text processing.

NOTE CONF {"raw":[100,100,100,100]}

00:46:07.960 --> 00:46:11.230
<v Speaker 0>We often work on a line by line basis, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:11.230 --> 00:46:14.320
<v Speaker 0>quite often we don't actually want to match new lines.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:14.560 --> 00:46:16.030
<v Speaker 0>When we write a dot.

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:16.060 --> 00:46:19.780
<v Speaker 0>So in most libraries, the wildcard means pretty much means

NOTE CONF {"raw":[100,100,100,100,100,56,100,100,100,100]}

00:46:19.780 --> 00:46:23.050
<v Speaker 0>any character except an end of line.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:25.300 --> 00:46:28.690
<v Speaker 0>Um, there are lots and lots more of these.

NOTE CONF {"raw":[97,100,100,100,100,100,100,100,100]}

00:46:30.220 --> 00:46:32.650
<v Speaker 0>That's supposed to be wild card.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:46:32.680 --> 00:46:39.730
<v Speaker 0>There isn't yet a green vegetable in regular expressions.

NOTE CONF {"raw":[46,97,100,70,100,100,100,100,100]}

00:46:42.010 --> 00:46:45.130
<v Speaker 0>Um, but the nice thing about regular expressions is that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:45.130 --> 00:46:49.000
<v Speaker 0>with this set, you can write quickly and concisely regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:49.000 --> 00:46:51.250
<v Speaker 0>expressions for most things that you're going to meet in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:51.250 --> 00:46:52.000
<v Speaker 0>practice.

NOTE CONF {"raw":[100]}

00:46:53.950 --> 00:46:57.370
<v Speaker 0>So all of these things are syntactic sugar.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:46:57.370 --> 00:46:59.200
<v Speaker 0>They don't add any power.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:00.460 --> 00:47:04.300
<v Speaker 0>But as I said, modern languages often give you a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:04.300 --> 00:47:05.680
<v Speaker 0>great deal extra.

NOTE CONF {"raw":[100,100,100]}

00:47:07.330 --> 00:47:09.580
<v Speaker 0>And then there's something I did up there, which I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:09.580 --> 00:47:12.280
<v Speaker 0>will explain finally.

NOTE CONF {"raw":[100,100,100]}

00:47:14.770 --> 00:47:18.370
<v Speaker 0>In real life, when we match against a regular expression,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:18.370 --> 00:47:21.220
<v Speaker 0>we're not usually interested in whether the string matches the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:21.220 --> 00:47:25.600
<v Speaker 0>regular expression we want to know does some bit of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:25.600 --> 00:47:27.880
<v Speaker 0>the string, because we're searching for something in a bigger

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:27.880 --> 00:47:28.600
<v Speaker 0>string.

NOTE CONF {"raw":[100]}

00:47:28.600 --> 00:47:31.510
<v Speaker 0>And usually we also want to know what was it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:31.510 --> 00:47:34.180
<v Speaker 0>that matched the regular expression we were looking for?

NOTE CONF {"raw":[100,50,100,100,100,100,100,100,100]}

00:47:35.650 --> 00:47:38.410
<v Speaker 0>So there are a couple of things you can do

NOTE CONF {"raw":[100,100,81,100,100,100,100,100,100,100]}

00:47:38.410 --> 00:47:40.030
<v Speaker 0>to achieve these aims.

NOTE CONF {"raw":[100,100,100,100]}

00:47:40.390 --> 00:47:43.930
<v Speaker 0>One thing is that in the most implementations, if you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:43.930 --> 00:47:48.940
<v Speaker 0>write down a regular expression, then the system automatically assumes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:48.940 --> 00:47:52.030
<v Speaker 0>that you meant plus anything before and anything after.

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100]}

00:47:52.150 --> 00:47:55.900
<v Speaker 0>And the way to avoid that happening is usually to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:55.900 --> 00:47:57.610
<v Speaker 0>use the carrot and the dollar.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:57.610 --> 00:48:01.540
<v Speaker 0>Carrot means beginning of line and dollar means end of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:01.540 --> 00:48:02.170
<v Speaker 0>line.

NOTE CONF {"raw":[100]}

00:48:04.270 --> 00:48:10.030
<v Speaker 0>And if you want to know which substring you want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:10.030 --> 00:48:13.450
<v Speaker 0>to know, you're looking for a particular regular expression in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:13.450 --> 00:48:15.490
<v Speaker 0>a big piece of text, you want to know which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:15.490 --> 00:48:18.670
<v Speaker 0>string matched it, and if you have a complex regular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:18.670 --> 00:48:21.010
<v Speaker 0>expression, you might not want to know which bits of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:21.010 --> 00:48:24.160
<v Speaker 0>your target string match the bits, so you can then

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:48:24.190 --> 00:48:25.390
<v Speaker 0>do stuff to them.

NOTE CONF {"raw":[100,100,100,100]}

00:48:25.840 --> 00:48:34.750
<v Speaker 0>So typically we do that by writing brackets around stuff

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,87,100]}

00:48:34.750 --> 00:48:37.840
<v Speaker 0>and then allowing your replacement text to talk about, for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:37.840 --> 00:48:41.650
<v Speaker 0>example backslash one or dollar one or something to mean

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:41.650 --> 00:48:44.680
<v Speaker 0>whatever bit was matched by the first bracket and whatever

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:44.680 --> 00:48:46.780
<v Speaker 0>bit was matched by the second bracket.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:48:46.990 --> 00:48:49.570
<v Speaker 0>So these again are things that you can learn to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:49.570 --> 00:48:54.220
<v Speaker 0>use, and they will save you time in replacing errors

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:54.220 --> 00:48:55.330
<v Speaker 0>in your code.

NOTE CONF {"raw":[100,100,100]}

00:48:57.430 --> 00:49:00.280
<v Speaker 0>Um, it all gets more complicated.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:49:00.280 --> 00:49:03.010
<v Speaker 0>I'm just about to run out of time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:49:03.010 --> 00:49:08.490
<v Speaker 0>So the last thing I will mention is one of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:08.490 --> 00:49:12.150
<v Speaker 0>the problems is that we've talked about regexp as a

NOTE CONF {"raw":[100,100,100,100,100,100,100,92,100,100]}

00:49:12.150 --> 00:49:14.730
<v Speaker 0>description of non-deterministic automata.

NOTE CONF {"raw":[100,100,45,100]}

00:49:15.300 --> 00:49:19.620
<v Speaker 0>But non-deterministic automata are not real, right?

NOTE CONF {"raw":[100,63,100,100,100,100,96]}

00:49:20.280 --> 00:49:22.020
<v Speaker 0>They don't have a physical meaning.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:49:22.260 --> 00:49:25.590
<v Speaker 0>So programming language is determinism.

NOTE CONF {"raw":[100,100,56,56,98]}

00:49:27.390 --> 00:49:33.720
<v Speaker 0>If I give you a string like a star, a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:33.720 --> 00:49:38.940
<v Speaker 0>star, according to the way we've defined things that should

NOTE CONF {"raw":[100,100,100,100,100,100,62,100,100,100]}

00:49:38.940 --> 00:49:41.280
<v Speaker 0>match any string of A's followed by any string of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:41.280 --> 00:49:42.900
<v Speaker 0>A's, and it can match it in any way you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:42.900 --> 00:49:43.440
<v Speaker 0>like.

NOTE CONF {"raw":[100]}

00:49:43.440 --> 00:49:47.310
<v Speaker 0>The first bit could match zero, and the second bit

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:47.310 --> 00:49:48.510
<v Speaker 0>could match all the A's.

NOTE CONF {"raw":[100,100,100,100,100]}

00:49:48.540 --> 00:49:50.550
<v Speaker 0>The other way round they could split in the middle

NOTE CONF {"raw":[100,100,100,89,100,100,100,100,100,100]}

00:49:50.550 --> 00:49:51.630
<v Speaker 0>as they choose.

NOTE CONF {"raw":[100,100,100]}

00:49:51.630 --> 00:49:53.670
<v Speaker 0>And all of those are good matches.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:49:54.720 --> 00:49:57.000
<v Speaker 0>It's very hard to do text processing if you've got

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:57.000 --> 00:49:59.130
<v Speaker 0>a huge range of possible matches and you don't know

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:59.130 --> 00:50:00.000
<v Speaker 0>which one.

NOTE CONF {"raw":[100,100]}

00:50:00.240 --> 00:50:05.430
<v Speaker 0>So programming languages turn all these non-deterministic things into deterministic

NOTE CONF {"raw":[100,100,100,100,100,100,66,100,100,100]}

00:50:05.430 --> 00:50:06.090
<v Speaker 0>things.

NOTE CONF {"raw":[100]}

00:50:06.270 --> 00:50:08.940
<v Speaker 0>And the way they do that is to say that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:09.750 --> 00:50:13.890
<v Speaker 0>this star operator, which is swallowing up input, is what

NOTE CONF {"raw":[90,100,100,100,100,100,100,100,100,100]}

00:50:13.890 --> 00:50:15.060
<v Speaker 0>is called greedy.

NOTE CONF {"raw":[100,100,100]}

00:50:15.270 --> 00:50:19.980
<v Speaker 0>So when you see a star, the regular expression matcher

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:19.980 --> 00:50:23.070
<v Speaker 0>says, I will take as many A's as I possibly

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:23.070 --> 00:50:26.340
<v Speaker 0>can, and then I will go on and try to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:26.340 --> 00:50:27.390
<v Speaker 0>match the rest.

NOTE CONF {"raw":[100,100,100]}

00:50:27.810 --> 00:50:31.380
<v Speaker 0>Now that can get complicated, because you might swallow up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:31.380 --> 00:50:33.930
<v Speaker 0>a lot of A's, go on and try to match

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:33.930 --> 00:50:35.790
<v Speaker 0>the rest and find that you can't.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:36.180 --> 00:50:38.520
<v Speaker 0>But maybe if you had eaten so many of the

NOTE CONF {"raw":[100,100,100,100,63,100,100,100,100,100]}

00:50:38.520 --> 00:50:40.590
<v Speaker 0>initial A's, you would be able to match the second

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:40.590 --> 00:50:41.160
<v Speaker 0>half.

NOTE CONF {"raw":[100]}

00:50:41.190 --> 00:50:43.140
<v Speaker 0>So they do backtracking.

NOTE CONF {"raw":[100,100,100,100]}

00:50:43.500 --> 00:50:47.220
<v Speaker 0>They swallow up as much as possible and then look

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:47.220 --> 00:50:48.270
<v Speaker 0>for the rest of it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:48.270 --> 00:50:50.730
<v Speaker 0>And if that doesn't work, they backtrack one step and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:50.730 --> 00:50:52.110
<v Speaker 0>say, I ate too much.

NOTE CONF {"raw":[100,100,100,100,100]}

00:50:52.230 --> 00:50:54.630
<v Speaker 0>This is going to get a bit unpleasant, isn't it?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:54.660 --> 00:50:58.890
<v Speaker 0>If I carry this metaphor forward, um, so they backtrack.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:50:59.430 --> 00:51:02.400
<v Speaker 0>If that doesn't work, they backtrack Backtracked further, and that's

NOTE CONF {"raw":[100,100,100,100,100,100,77,100,100,100]}

00:51:02.400 --> 00:51:03.990
<v Speaker 0>an expensive operation.

NOTE CONF {"raw":[100,100,100]}

00:51:03.990 --> 00:51:08.520
<v Speaker 0>So in the old days, when computers were slow, it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:08.520 --> 00:51:12.060
<v Speaker 0>was possible to write apps that could take noticeable time

NOTE CONF {"raw":[100,100,100,100,73,100,100,100,100,100]}

00:51:12.060 --> 00:51:13.680
<v Speaker 0>to work on some texts.

NOTE CONF {"raw":[100,100,100,100,68]}

00:51:13.680 --> 00:51:15.960
<v Speaker 0>Then you could rewrite them to work much better.

NOTE CONF {"raw":[87,100,100,100,100,100,100,100,100]}

00:51:17.400 --> 00:51:19.860
<v Speaker 0>And there's a whole lot of stuff you can do

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:20.190 --> 00:51:23.880
<v Speaker 0>to play around with Perl's regex and much more complicated

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:23.880 --> 00:51:24.210
<v Speaker 0>stuff.

NOTE CONF {"raw":[100]}

00:51:24.210 --> 00:51:28.770
<v Speaker 0>But to be honest, Perl is a write only language.

NOTE CONF {"raw":[100,100,100,100,100,100,100,98,100,100]}

00:51:29.880 --> 00:51:32.340
<v Speaker 0>You can write programs in Perl, but reading them is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,99]}

00:51:32.340 --> 00:51:35.190
<v Speaker 0>a problem and therefore people don't use the fancy stuff.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:36.060 --> 00:51:37.950
<v Speaker 0>Um, when I give the talk about this, I show

NOTE CONF {"raw":[86,100,100,100,100,100,100,100,100,100]}

00:51:37.950 --> 00:51:40.110
<v Speaker 0>you some of the fancy stuff and I have searched

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:40.110 --> 00:51:42.360
<v Speaker 0>through every piece of code I have in my directory,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:42.360 --> 00:51:45.090
<v Speaker 0>which is some 40 years worth of writing code, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:45.090 --> 00:51:47.730
<v Speaker 0>I don't see any instances of any of the complicated

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:47.730 --> 00:51:48.330
<v Speaker 0>things.

NOTE CONF {"raw":[100]}

00:51:48.930 --> 00:51:51.480
<v Speaker 0>They're just too hard to think about, but they aren't

NOTE CONF {"raw":[91,100,100,100,100,100,100,100,100,100]}

00:51:51.480 --> 00:51:52.200
<v Speaker 0>half fun.

NOTE CONF {"raw":[100,100]}

00:51:52.980 --> 00:51:56.160
<v Speaker 0>Okay, so that's the end of the core part of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:51:56.160 --> 00:51:56.640
<v Speaker 0>the course.

NOTE CONF {"raw":[100,100]}

00:51:56.640 --> 00:52:00.240
<v Speaker 0>As I said, I'll stick on the website the plan

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,47,100]}

00:52:00.240 --> 00:52:04.470
<v Speaker 0>for next week's lectures and see you there or not

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:52:04.470 --> 00:52:05.520
<v Speaker 0>as you choose.

NOTE CONF {"raw":[100,100,100]}
