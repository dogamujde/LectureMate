WEBVTT

00:00:26.730 --> 00:00:28.770
<v Unknown>Hip hip hip hip.

NOTE CONF {"raw":[100,100,100,100]}

00:00:43.020 --> 00:00:43.380
<v Unknown>Hooray!

NOTE CONF {"raw":[100]}

00:00:56.430 --> 00:00:56.970
<v Speaker 0>Right.

NOTE CONF {"raw":[100]}

00:00:57.930 --> 00:00:58.650
<v Speaker 1>Hello?

NOTE CONF {"raw":[100]}

00:00:58.920 --> 00:01:00.030
<v Speaker 1>Good afternoon.

NOTE CONF {"raw":[100,100]}

00:01:01.290 --> 00:01:05.400
<v Speaker 1>Uh, I've been asked to show this to you before

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:05.400 --> 00:01:06.390
<v Speaker 1>my lecture today.

NOTE CONF {"raw":[100,100,100]}

00:01:06.390 --> 00:01:10.140
<v Speaker 1>There's an event, uh, careers event at the beginning of

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:01:10.140 --> 00:01:10.950
<v Speaker 1>October.

NOTE CONF {"raw":[100]}

00:01:11.280 --> 00:01:16.170
<v Speaker 1>Um, um, you might think in first year this is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:16.170 --> 00:01:18.660
<v Speaker 1>a little early for you, but anyway, there's there's, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,50]}

00:01:18.660 --> 00:01:21.810
<v Speaker 1>employers coming to look for you when you're, when you're

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:21.810 --> 00:01:22.710
<v Speaker 1>graduated.

NOTE CONF {"raw":[100]}

00:01:22.710 --> 00:01:26.910
<v Speaker 1>And also during the summers in between now and graduation.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:26.910 --> 00:01:30.390
<v Speaker 1>So there's, um, this is taking place in MacEwan Hall,

NOTE CONF {"raw":[100,100,88,100,100,100,100,100,52,100]}

00:01:30.690 --> 00:01:33.180
<v Speaker 1>uh, which is not mentioned on the, on this thing

NOTE CONF {"raw":[96,100,100,100,100,100,100,100,100,100]}

00:01:33.180 --> 00:01:33.450
<v Speaker 1>here.

NOTE CONF {"raw":[100]}

00:01:33.450 --> 00:01:35.700
<v Speaker 1>And it's also not mentioned if you click through to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:35.700 --> 00:01:36.930
<v Speaker 1>the thing on the QR code.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:01:36.930 --> 00:01:39.240
<v Speaker 1>But I have just discovered that that's where it is.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:39.240 --> 00:01:43.830
<v Speaker 1>So, um, this thing is taking place and, um, there

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:43.830 --> 00:01:49.470
<v Speaker 1>are recruiters coming to see you and um, uh, they

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,97,100]}

00:01:49.470 --> 00:01:54.720
<v Speaker 1>are recruiting for internships as well as for jobs and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:01:54.720 --> 00:01:55.770
<v Speaker 1>some informatics.

NOTE CONF {"raw":[100,100]}

00:01:55.770 --> 00:01:58.690
<v Speaker 1>When students do internships in the summer, so might be

NOTE CONF {"raw":[69,100,100,100,100,100,100,100,100,100]}

00:01:58.690 --> 00:01:59.800
<v Speaker 1>worth going along.

NOTE CONF {"raw":[100,100,100]}

00:01:59.800 --> 00:02:00.610
<v Speaker 1>Having a look.

NOTE CONF {"raw":[100,100,100]}

00:02:00.610 --> 00:02:06.130
<v Speaker 1>Okay, so, uh, QR code there.

NOTE CONF {"raw":[100,100,94,100,100,100]}

00:02:07.510 --> 00:02:07.960
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:02:07.960 --> 00:02:10.600
<v Speaker 1>If you want to or just or just type in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:10.600 --> 00:02:14.020
<v Speaker 1>Discovered Careers Edinburgh and you'll get to the web page.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,84,84]}

00:02:14.140 --> 00:02:14.830
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:02:15.250 --> 00:02:16.450
<v Speaker 1>So that's that.

NOTE CONF {"raw":[100,100,100]}

00:02:16.840 --> 00:02:20.440
<v Speaker 1>Um, the lecture today is about recursion.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:20.440 --> 00:02:21.910
<v Speaker 1>More about recursion.

NOTE CONF {"raw":[100,100,100]}

00:02:23.920 --> 00:02:32.080
<v Speaker 1>On Friday I explained recursion on lists, recursion and defining

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:32.080 --> 00:02:36.070
<v Speaker 1>functions by recursion with pattern matching is one of the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:36.070 --> 00:02:37.870
<v Speaker 1>one of the main things you're going to be doing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:37.870 --> 00:02:38.410
<v Speaker 1>in this course.

NOTE CONF {"raw":[100,100,100]}

00:02:38.410 --> 00:02:40.990
<v Speaker 1>So this is something you really need to understand get

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:40.990 --> 00:02:41.770
<v Speaker 1>used to.

NOTE CONF {"raw":[100,100]}

00:02:41.770 --> 00:02:43.960
<v Speaker 1>And so this lecture I'm going to be showing you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:43.960 --> 00:02:48.130
<v Speaker 1>some more examples of recursion that goes beyond the thing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:48.130 --> 00:02:49.900
<v Speaker 1>that I showed you in the last lecture.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:02:49.900 --> 00:02:51.940
<v Speaker 1>So different patterns of recursion.

NOTE CONF {"raw":[100,100,100,100,100]}

00:02:51.940 --> 00:02:55.210
<v Speaker 1>So you get used to to doing this and seeing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:02:55.210 --> 00:02:57.700
<v Speaker 1>it done you know different different ways.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:02:58.060 --> 00:02:58.690
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:02:58.690 --> 00:03:03.460
<v Speaker 1>The, um, and I will be also showing you a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:03.460 --> 00:03:06.610
<v Speaker 1>couple of functional programming techniques you use to solve certain

NOTE CONF {"raw":[100,100,100,100,100,100,91,100,100,100]}

00:03:06.610 --> 00:03:08.920
<v Speaker 1>kinds of problems that arise a lot.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:03:09.460 --> 00:03:12.820
<v Speaker 1>Um, and I'm going to start here with examples that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:12.820 --> 00:03:19.120
<v Speaker 1>have to do with, um, um, recursion on integers, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,80]}

00:03:19.120 --> 00:03:21.820
<v Speaker 1>because you can do recursion on different sorts of data.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:21.820 --> 00:03:23.950
<v Speaker 1>So lists I showed you last time, this time it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:23.950 --> 00:03:26.380
<v Speaker 1>going to be integers or in fact natural numbers.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:03:26.380 --> 00:03:30.490
<v Speaker 1>So natural numbers are integers from zero on up.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:03:30.940 --> 00:03:31.720
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:03:32.140 --> 00:03:35.950
<v Speaker 1>Um and here's an example.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:37.360 --> 00:03:43.540
<v Speaker 1>Uh, this is a function that, um, underlies a Haskell

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:43.540 --> 00:03:44.500
<v Speaker 1>notation.

NOTE CONF {"raw":[100]}

00:03:45.070 --> 00:03:47.260
<v Speaker 1>Um, this sort of Haskell notation where you have a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:47.260 --> 00:03:50.380
<v Speaker 1>list, square brackets, and then you have a, a lower

NOTE CONF {"raw":[100,100,100,100,87,100,100,95,100,100]}

00:03:50.380 --> 00:03:53.140
<v Speaker 1>bound dot dot upper bound.

NOTE CONF {"raw":[100,100,100,100,100]}

00:03:53.140 --> 00:03:58.400
<v Speaker 1>So for example, 1.. 3 or 1 ..1 hundred or

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:03:58.400 --> 00:03:58.940
<v Speaker 1>whatever.

NOTE CONF {"raw":[100]}

00:03:58.940 --> 00:04:01.850
<v Speaker 1>It gives you the list of all the numbers from

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:01.850 --> 00:04:03.740
<v Speaker 1>the lower bound up to the upper bound.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:04:04.040 --> 00:04:06.770
<v Speaker 1>Uh, you know, in order one, two, three or whatever

NOTE CONF {"raw":[94,100,100,100,100,100,100,100,100,100]}

00:04:06.770 --> 00:04:07.160
<v Speaker 1>it is.

NOTE CONF {"raw":[100,100]}

00:04:07.190 --> 00:04:07.610
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:07.610 --> 00:04:09.260
<v Speaker 1>So that's this notation.

NOTE CONF {"raw":[100,100,100,100]}

00:04:09.260 --> 00:04:11.240
<v Speaker 1>I've mentioned that before.

NOTE CONF {"raw":[87,100,100,100]}

00:04:11.600 --> 00:04:15.200
<v Speaker 1>Um, uh, it is, in fact, a call to a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:15.200 --> 00:04:20.150
<v Speaker 1>function that's built into Haskell called enum from two with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:20.150 --> 00:04:22.490
<v Speaker 1>the lower bound and the upper bound.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:04:23.360 --> 00:04:23.840
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:23.840 --> 00:04:28.040
<v Speaker 1>So so this happens to be built in, uh, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:28.610 --> 00:04:31.130
<v Speaker 1>I tell you this because I can show you the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:31.130 --> 00:04:32.120
<v Speaker 1>code for it.

NOTE CONF {"raw":[100,100,100]}

00:04:32.120 --> 00:04:33.740
<v Speaker 1>And this uses recursion.

NOTE CONF {"raw":[100,100,100,100]}

00:04:34.370 --> 00:04:35.090
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:04:35.810 --> 00:04:38.150
<v Speaker 1>So this is on numbers not on lists.

NOTE CONF {"raw":[100,100,100,98,100,100,100,100]}

00:04:38.150 --> 00:04:41.840
<v Speaker 1>And so the, the type, uh takes two integers and

NOTE CONF {"raw":[100,100,100,100,100,80,100,100,100,100]}

00:04:41.840 --> 00:04:43.280
<v Speaker 1>gives you a list of integers.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:04:44.480 --> 00:04:49.250
<v Speaker 1>And uh, so if you take the integers m and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:49.250 --> 00:04:51.470
<v Speaker 1>n there are two cases.

NOTE CONF {"raw":[100,100,100,100,100]}

00:04:52.460 --> 00:04:57.800
<v Speaker 1>Um case one the base case is where m is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:57.800 --> 00:04:59.840
<v Speaker 1>greater than n, so you're counting from M up to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:04:59.840 --> 00:05:00.380
<v Speaker 1>N.

NOTE CONF {"raw":[100]}

00:05:01.010 --> 00:05:05.900
<v Speaker 1>If you've already gotten past N, then you're finished, right?

NOTE CONF {"raw":[100,100,100,73,100,100,100,100,100,86]}

00:05:06.050 --> 00:05:09.530
<v Speaker 1>So in that case, you've got an empty list of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:09.530 --> 00:05:10.220
<v Speaker 1>numbers.

NOTE CONF {"raw":[100]}

00:05:11.960 --> 00:05:12.470
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:05:12.500 --> 00:05:13.250
<v Speaker 1>Is that clear?

NOTE CONF {"raw":[100,100,100]}

00:05:14.090 --> 00:05:18.800
<v Speaker 1>Um, in the second case, you haven't yet gone past

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:18.800 --> 00:05:23.000
<v Speaker 1>N, so that is to say, M is not greater

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:23.000 --> 00:05:23.450
<v Speaker 1>than N.

NOTE CONF {"raw":[100,100]}

00:05:23.450 --> 00:05:24.740
<v Speaker 1>It's less than or equal to n.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:24.770 --> 00:05:26.960
<v Speaker 1>You could also have written otherwise here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:05:27.950 --> 00:05:30.710
<v Speaker 1>And in that case you have work to do.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:05:30.740 --> 00:05:35.810
<v Speaker 1>You you take the, the lower bound m and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:36.290 --> 00:05:38.720
<v Speaker 1>the result is m cons.

NOTE CONF {"raw":[100,100,100,100,93]}

00:05:39.260 --> 00:05:44.660
<v Speaker 1>Uh, the recursive call and the recursive call is the

NOTE CONF {"raw":[83,100,100,100,100,100,100,100,100,100]}

00:05:44.660 --> 00:05:47.810
<v Speaker 1>numbers from m plus one up to n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:49.280 --> 00:05:49.730
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:05:49.730 --> 00:05:52.850
<v Speaker 1>So uh, you're starting from m going up to n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:05:52.850 --> 00:05:55.260
<v Speaker 1>So the first element is m and then you go

NOTE CONF {"raw":[100,100,100,100,100,94,100,100,100,100]}

00:05:55.260 --> 00:05:57.810
<v Speaker 1>from m plus one up to n okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:05:57.810 --> 00:06:02.010
<v Speaker 1>That's the that's the um the function.

NOTE CONF {"raw":[100,100,100,100,98,100,100]}

00:06:02.010 --> 00:06:06.420
<v Speaker 1>So it's counting up from M to n clear.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:06:09.450 --> 00:06:10.710
<v Speaker 1>And so I'll just show you this.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:10.710 --> 00:06:13.620
<v Speaker 1>Um, this sort of computation sequence looks like this.

NOTE CONF {"raw":[100,93,100,100,100,100,100,100,100]}

00:06:14.100 --> 00:06:15.960
<v Speaker 1>So here's the code again up here.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:20.190 --> 00:06:22.770
<v Speaker 1>So, you know, if I want to apply it to

NOTE CONF {"raw":[100,100,100,100,100,91,100,100,100,100]}

00:06:22.770 --> 00:06:25.320
<v Speaker 1>one and three, which was my example from the previous

NOTE CONF {"raw":[100,67,100,100,100,100,100,100,100,100]}

00:06:25.320 --> 00:06:25.920
<v Speaker 1>slide.

NOTE CONF {"raw":[100]}

00:06:25.920 --> 00:06:29.820
<v Speaker 1>So um, the num one in um from two one,

NOTE CONF {"raw":[100,100,96,97,100,55,60,100,100,100]}

00:06:29.820 --> 00:06:31.920
<v Speaker 1>three one is the lower bound, three is the upper

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:31.920 --> 00:06:32.220
<v Speaker 1>bound.

NOTE CONF {"raw":[100]}

00:06:32.220 --> 00:06:34.860
<v Speaker 1>So one is m, three is n.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:06:35.520 --> 00:06:35.940
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:06:35.940 --> 00:06:38.250
<v Speaker 1>So which of these cases applies.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:06:39.120 --> 00:06:41.940
<v Speaker 1>It's the second one because one is less than or

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:06:41.940 --> 00:06:43.080
<v Speaker 1>equal to three.

NOTE CONF {"raw":[100,100,100]}

00:06:43.080 --> 00:06:45.570
<v Speaker 1>And so the result is one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:06:45.780 --> 00:06:46.920
<v Speaker 1>Cons.

NOTE CONF {"raw":[95]}

00:06:47.040 --> 00:06:52.290
<v Speaker 1>The recursive call on this function from 2 to 3

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:06:52.290 --> 00:06:52.530
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:06:52.560 --> 00:06:53.670
<v Speaker 1>That's what we see here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:06:53.880 --> 00:06:57.930
<v Speaker 1>Number one enum from 213 is equal to one.

NOTE CONF {"raw":[69,97,83,100,100,100,100,100,100]}

00:06:57.930 --> 00:07:01.950
<v Speaker 1>The lower bound cons the recursive call with arguments two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:01.950 --> 00:07:04.620
<v Speaker 1>and three okay.

NOTE CONF {"raw":[100,100,83]}

00:07:05.310 --> 00:07:08.700
<v Speaker 1>Uh recursive call gives you two cons a num from

NOTE CONF {"raw":[98,100,100,100,100,100,100,50,83,100]}

00:07:08.700 --> 00:07:13.590
<v Speaker 1>two, three and three, again using the second case, and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:13.590 --> 00:07:17.400
<v Speaker 1>then and then, uh, carrying on I'm going to go

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:17.400 --> 00:07:19.560
<v Speaker 1>through this a little bit more quickly because you should

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:19.560 --> 00:07:21.960
<v Speaker 1>be getting used to this kind of thing the last.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:21.960 --> 00:07:22.290
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:07:22.290 --> 00:07:25.680
<v Speaker 1>So, so in num from 3 to 3 and three.

NOTE CONF {"raw":[100,100,63,69,100,100,100,100,100,100]}

00:07:26.190 --> 00:07:28.890
<v Speaker 1>Um, so the result of that is going to be

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:28.890 --> 00:07:30.780
<v Speaker 1>the list containing just three.

NOTE CONF {"raw":[100,100,100,100,100]}

00:07:31.860 --> 00:07:34.230
<v Speaker 1>And so we do three cons.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:07:34.230 --> 00:07:39.270
<v Speaker 1>This other recursive call where we're actually counted past the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,93,100]}

00:07:39.270 --> 00:07:41.550
<v Speaker 1>upper bound okay.

NOTE CONF {"raw":[100,100,100]}

00:07:41.550 --> 00:07:43.770
<v Speaker 1>We've added one to the lower bound.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:07:43.770 --> 00:07:46.080
<v Speaker 1>And so it's now num from 4 to 3.

NOTE CONF {"raw":[100,100,100,100,50,100,97,97,97]}

00:07:46.080 --> 00:07:48.330
<v Speaker 1>And that's the first case we get the empty list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:48.330 --> 00:07:51.330
<v Speaker 1>So we we count from the the lower bound up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:51.340 --> 00:07:53.770
<v Speaker 1>to the upper bound, and then one passed, and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,85,100,100]}

00:07:53.770 --> 00:07:57.340
<v Speaker 1>we stop with the empty list and we get this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:07:57.340 --> 00:07:58.300
<v Speaker 1>result here.

NOTE CONF {"raw":[100,100]}

00:07:58.540 --> 00:07:59.140
<v Speaker 1>Oops.

NOTE CONF {"raw":[44]}

00:07:59.860 --> 00:08:01.330
<v Speaker 1>Uh, oops.

NOTE CONF {"raw":[99,56]}

00:08:01.330 --> 00:08:01.870
<v Speaker 1>Wait a minute.

NOTE CONF {"raw":[100,100,100]}

00:08:01.870 --> 00:08:02.560
<v Speaker 1>Where am I?

NOTE CONF {"raw":[100,100,100]}

00:08:03.070 --> 00:08:03.610
<v Speaker 1>Yeah.

NOTE CONF {"raw":[96]}

00:08:03.640 --> 00:08:04.360
<v Speaker 1>There we are.

NOTE CONF {"raw":[100,100,100]}

00:08:04.480 --> 00:08:05.830
<v Speaker 1>Okay, that's the result.

NOTE CONF {"raw":[100,100,100,100]}

00:08:07.240 --> 00:08:07.780
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:07.780 --> 00:08:08.530
<v Speaker 1>Exciting.

NOTE CONF {"raw":[100]}

00:08:08.530 --> 00:08:09.250
<v Speaker 1>Yes.

NOTE CONF {"raw":[100]}

00:08:09.850 --> 00:08:10.240
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:08:10.240 --> 00:08:11.170
<v Speaker 1>Maybe not.

NOTE CONF {"raw":[100,100]}

00:08:11.200 --> 00:08:15.760
<v Speaker 1>Okay, so, um, but there's some small problem here.

NOTE CONF {"raw":[99,100,75,100,100,100,100,100,100]}

00:08:16.120 --> 00:08:17.050
<v Speaker 1>This works.

NOTE CONF {"raw":[100,100]}

00:08:17.050 --> 00:08:19.660
<v Speaker 1>You can you can run this function.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:08:19.660 --> 00:08:22.540
<v Speaker 1>I mean, that's the code that's in Haskell, built in.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:22.570 --> 00:08:24.010
<v Speaker 1>You can type it in yourself.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:08:24.010 --> 00:08:25.990
<v Speaker 1>Make sure that you believe that it works.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:08:25.990 --> 00:08:26.440
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:08:26.440 --> 00:08:29.890
<v Speaker 1>But last time I made the point when I explained

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:29.980 --> 00:08:31.420
<v Speaker 1>recursive definitions.

NOTE CONF {"raw":[100,100]}

00:08:31.420 --> 00:08:37.240
<v Speaker 1>The reason they work is that on each recursive okay,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,92]}

00:08:37.240 --> 00:08:40.479
<v Speaker 1>the recursive definition, you're defining something in terms of itself.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:40.690 --> 00:08:45.280
<v Speaker 1>And I said that works because you're defining, um, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,83,100]}

00:08:45.280 --> 00:08:48.760
<v Speaker 1>know, complicated lists in terms of simpler lists, or you're

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:48.760 --> 00:08:51.370
<v Speaker 1>defining a function for big lists in terms of that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:08:51.370 --> 00:08:55.630
<v Speaker 1>function, apply to small lists, and then eventually the list

NOTE CONF {"raw":[100,52,100,100,100,100,100,100,100,100]}

00:08:55.630 --> 00:08:57.460
<v Speaker 1>gets smaller and smaller and smaller until they're empty.

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100]}

00:08:57.460 --> 00:08:57.940
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:08:57.940 --> 00:08:59.620
<v Speaker 1>So what's going on here?

NOTE CONF {"raw":[100,100,100,100,100]}

00:08:59.620 --> 00:09:03.070
<v Speaker 1>This I've just done something that I said was the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:03.070 --> 00:09:04.120
<v Speaker 1>wrong way around okay.

NOTE CONF {"raw":[100,100,100,100]}

00:09:04.120 --> 00:09:07.870
<v Speaker 1>I'm defining enum from m n in terms of enum

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,89]}

00:09:07.870 --> 00:09:11.470
<v Speaker 1>from m plus one and n right.

NOTE CONF {"raw":[100,94,100,100,100,100,100]}

00:09:11.470 --> 00:09:13.720
<v Speaker 1>So m plus one is bigger than m.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:09:13.870 --> 00:09:15.520
<v Speaker 1>So what's going on here?

NOTE CONF {"raw":[100,100,100,100,100]}

00:09:17.230 --> 00:09:17.980
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:18.850 --> 00:09:22.330
<v Speaker 1>Uh the answer is there is something getting smaller.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:09:22.330 --> 00:09:25.990
<v Speaker 1>And what's getting smaller is the difference between n and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:25.990 --> 00:09:27.850
<v Speaker 1>m okay.

NOTE CONF {"raw":[100,100]}

00:09:27.850 --> 00:09:31.210
<v Speaker 1>So the list isn't there is no list here okay.

NOTE CONF {"raw":[100,100,100,67,100,100,100,100,100,100]}

00:09:31.210 --> 00:09:32.620
<v Speaker 1>The number is not getting smaller.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:32.620 --> 00:09:35.020
<v Speaker 1>The difference between the two limits is getting smaller.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:09:35.020 --> 00:09:37.660
<v Speaker 1>So we start off with with you know, the limit,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:37.660 --> 00:09:39.250
<v Speaker 1>the lower limit, the upper limit.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:09:39.250 --> 00:09:43.780
<v Speaker 1>And we progressively increase the upper the lower limit until

NOTE CONF {"raw":[100,100,100,97,100,100,100,100,100,100]}

00:09:43.780 --> 00:09:47.410
<v Speaker 1>it gets up to the upper limit and then passes

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:09:47.410 --> 00:09:47.530
<v Speaker 1>it.

NOTE CONF {"raw":[100]}

00:09:47.530 --> 00:09:48.340
<v Speaker 1>And then we stop.

NOTE CONF {"raw":[100,100,100,100]}

00:09:48.340 --> 00:09:48.610
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:48.610 --> 00:09:51.430
<v Speaker 1>So what's decreasing is the space between my hands.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:09:52.240 --> 00:09:52.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:53.680 --> 00:09:56.230
<v Speaker 1>And eventually we're finished.

NOTE CONF {"raw":[100,100,100,100]}

00:09:56.470 --> 00:09:57.040
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:09:57.040 --> 00:09:58.420
<v Speaker 1>So it has to be something.

NOTE CONF {"raw":[100,100,100,100,100,98]}

00:09:58.420 --> 00:10:00.340
<v Speaker 1>There always has to be something getting smaller.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:10:00.550 --> 00:10:05.020
<v Speaker 1>And that's what gives rise to a non that gives

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:05.020 --> 00:10:08.710
<v Speaker 1>what gives rise to a well-founded recursion terminology.

NOTE CONF {"raw":[100,100,100,100,100,99,86,100]}

00:10:08.920 --> 00:10:14.170
<v Speaker 1>Um otherwise the recursion doesn't terminate okay.

NOTE CONF {"raw":[89,100,100,100,100,100,100]}

00:10:14.170 --> 00:10:14.800
<v Speaker 1>Is that clear.

NOTE CONF {"raw":[100,100,100]}

00:10:14.800 --> 00:10:16.180
<v Speaker 1>Any questions about that?

NOTE CONF {"raw":[100,100,100,100]}

00:10:17.770 --> 00:10:20.080
<v Speaker 1>I don't see any hands okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:22.840 --> 00:10:27.580
<v Speaker 1>Um, here's another example, uh, that I don't think I

NOTE CONF {"raw":[100,100,100,100,61,100,100,100,100,100]}

00:10:27.580 --> 00:10:29.380
<v Speaker 1>want to go into.

NOTE CONF {"raw":[100,100,100,100]}

00:10:29.380 --> 00:10:29.890
<v Speaker 1>Really.

NOTE CONF {"raw":[100]}

00:10:29.890 --> 00:10:32.020
<v Speaker 1>I'll just say this is factorial.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:10:32.290 --> 00:10:35.920
<v Speaker 1>Um, factorial is usually written, uh, a number with an

NOTE CONF {"raw":[100,92,92,100,100,100,100,100,100,100]}

00:10:35.920 --> 00:10:38.110
<v Speaker 1>exclamation mark after it.

NOTE CONF {"raw":[100,100,100,100]}

00:10:38.110 --> 00:10:40.660
<v Speaker 1>And it's the product of all the numbers from one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:40.660 --> 00:10:42.040
<v Speaker 1>up to that number.

NOTE CONF {"raw":[100,100,100,100]}

00:10:42.040 --> 00:10:42.670
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:10:42.670 --> 00:10:44.170
<v Speaker 1>So you could define it.

NOTE CONF {"raw":[100,100,100,100,100]}

00:10:44.170 --> 00:10:48.230
<v Speaker 1>You could define it like this factorial of n is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:48.230 --> 00:10:50.030
<v Speaker 1>the product of the numbers from one to n.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:10:51.200 --> 00:10:54.620
<v Speaker 1>Okay, here is a recursive definition of the same thing.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:55.130 --> 00:10:56.960
<v Speaker 1>I don't think I want to go into this in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:10:56.960 --> 00:11:03.470
<v Speaker 1>detail, except to point out that the pattern of this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:03.470 --> 00:11:04.490
<v Speaker 1>definition.

NOTE CONF {"raw":[100]}

00:11:04.820 --> 00:11:06.560
<v Speaker 1>I'll point out a couple of things about this stuff.

NOTE CONF {"raw":[99,100,100,100,100,100,100,100,100,93]}

00:11:06.590 --> 00:11:09.260
<v Speaker 1>A definition if you look at this second part of

NOTE CONF {"raw":[49,100,100,100,100,100,100,100,100,100]}

00:11:09.260 --> 00:11:14.210
<v Speaker 1>the definition fact, the pattern that we have here, fact

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:14.210 --> 00:11:16.880
<v Speaker 1>m n and then you know, the case where m

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:11:16.880 --> 00:11:19.850
<v Speaker 1>is greater than n producing a result, and the case

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:19.850 --> 00:11:21.680
<v Speaker 1>where m is less than or equal to n with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:21.680 --> 00:11:22.910
<v Speaker 1>a recursive call.

NOTE CONF {"raw":[73,100,100]}

00:11:22.910 --> 00:11:26.330
<v Speaker 1>If you just for a second hold that in your,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:26.330 --> 00:11:28.430
<v Speaker 1>in your, in your mind, okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:28.430 --> 00:11:31.850
<v Speaker 1>And look back at this previous definition.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:11:32.930 --> 00:11:36.770
<v Speaker 1>This has exactly the same form.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:36.770 --> 00:11:39.890
<v Speaker 1>And what's different is what comes after the equal signs

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:39.890 --> 00:11:41.480
<v Speaker 1>on both in both cases.

NOTE CONF {"raw":[100,100,80,100,100]}

00:11:41.480 --> 00:11:42.050
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:11:44.000 --> 00:11:47.420
<v Speaker 1>And I just mentioned that because Later on, I'm going

NOTE CONF {"raw":[100,85,100,64,100,100,100,100,100,100]}

00:11:47.420 --> 00:11:49.370
<v Speaker 1>to come back to this example, and I'm going to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:49.370 --> 00:11:52.310
<v Speaker 1>show you how to capture the I'm going to call

NOTE CONF {"raw":[100,100,100,100,100,89,100,100,100,100]}

00:11:52.310 --> 00:11:54.920
<v Speaker 1>this a pattern of computation, okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:11:54.920 --> 00:11:57.560
<v Speaker 1>And I'm going to show you how to capture common

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:11:57.560 --> 00:12:01.910
<v Speaker 1>patterns of, of common patterns of computation in Haskell as,

NOTE CONF {"raw":[100,68,100,100,100,100,100,95,100,100]}

00:12:01.910 --> 00:12:05.750
<v Speaker 1>as kind of things that you can write, you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:12:05.750 --> 00:12:08.030
<v Speaker 1>write the pattern of computation, you can use the pattern

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:08.030 --> 00:12:10.340
<v Speaker 1>of computation, you can apply it to different cases.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:12:10.340 --> 00:12:10.760
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:12:10.760 --> 00:12:12.680
<v Speaker 1>So I don't think I want to go into this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:12.680 --> 00:12:15.260
<v Speaker 1>particular one because actually this is the this is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:15.260 --> 00:12:17.090
<v Speaker 1>obvious way to write factorial.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:17.090 --> 00:12:19.610
<v Speaker 1>And it's a bit perverted to write it like this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:19.610 --> 00:12:21.290
<v Speaker 1>Okay, you can do it if you want.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:12:21.740 --> 00:12:23.720
<v Speaker 1>Um, the other things I want to show you with

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,100]}

00:12:23.720 --> 00:12:28.250
<v Speaker 1>this example is, um, this is an example of a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:28.250 --> 00:12:30.920
<v Speaker 1>function defined in terms of another function.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:30.920 --> 00:12:34.310
<v Speaker 1>We we would often call this this thing down here

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:34.310 --> 00:12:35.450
<v Speaker 1>a helper function.

NOTE CONF {"raw":[100,100,100]}

00:12:35.450 --> 00:12:38.480
<v Speaker 1>So it's a function that I define only in order

NOTE CONF {"raw":[100,100,100,100,100,100,92,100,100,100]}

00:12:38.480 --> 00:12:41.990
<v Speaker 1>to use it in the definition of another function okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:42.020 --> 00:12:44.570
<v Speaker 1>Auxiliary function, helper function or something.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:12:44.570 --> 00:12:46.680
<v Speaker 1>And you can do that in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:12:46.710 --> 00:12:49.650
<v Speaker 1>I mean, you can write them separately and just use

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:49.650 --> 00:12:51.840
<v Speaker 1>the second one in the first one or the other

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:51.840 --> 00:12:53.460
<v Speaker 1>way around, whichever it is.

NOTE CONF {"raw":[100,100,100,100,100]}

00:12:53.490 --> 00:12:55.140
<v Speaker 1>Haskell, it doesn't matter what you order.

NOTE CONF {"raw":[100,90,100,100,100,51,100]}

00:12:55.140 --> 00:12:56.580
<v Speaker 1>You write the definitions.

NOTE CONF {"raw":[100,100,100,100]}

00:12:56.970 --> 00:12:58.620
<v Speaker 1>If you want to make it, if you want to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:12:58.620 --> 00:13:01.770
<v Speaker 1>make it explicit that this thing here is a helper

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:01.770 --> 00:13:04.800
<v Speaker 1>function in the definition of this thing, here you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:04.800 --> 00:13:06.780
<v Speaker 1>use this syntax with where.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:08.970 --> 00:13:09.600
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:13:09.600 --> 00:13:15.660
<v Speaker 1>So you know definition you're really interested in where.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:13:15.960 --> 00:13:17.730
<v Speaker 1>Definition of helper function.

NOTE CONF {"raw":[100,100,100,100]}

00:13:20.610 --> 00:13:21.210
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:13:21.210 --> 00:13:23.400
<v Speaker 1>And there's another way to do this I mean it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:23.400 --> 00:13:24.030
<v Speaker 1>almost the same.

NOTE CONF {"raw":[100,100,100]}

00:13:24.030 --> 00:13:25.110
<v Speaker 1>It's just the other way around.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:13:25.110 --> 00:13:29.700
<v Speaker 1>You can say instead of saying definition where other definition

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:30.240 --> 00:13:39.000
<v Speaker 1>you can say let helper function definition in definition of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:39.000 --> 00:13:40.350
<v Speaker 1>the thing you really want.

NOTE CONF {"raw":[100,100,100,100,100]}

00:13:40.350 --> 00:13:40.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:13:40.950 --> 00:13:43.710
<v Speaker 1>And I mentioned this partly because at the end of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:43.710 --> 00:13:46.170
<v Speaker 1>the last lecture, somebody asked me about this and I

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:46.170 --> 00:13:47.280
<v Speaker 1>gave the wrong answer.

NOTE CONF {"raw":[100,100,100,100]}

00:13:47.280 --> 00:13:48.060
<v Speaker 1>I said.

NOTE CONF {"raw":[100,100]}

00:13:48.270 --> 00:13:51.690
<v Speaker 1>It's called local definition in other definitions.

NOTE CONF {"raw":[100,100,100,100,100,100,98]}

00:13:51.690 --> 00:13:54.210
<v Speaker 1>So whoever that is, if they're there, I should have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:13:54.210 --> 00:13:54.810
<v Speaker 1>said let.

NOTE CONF {"raw":[100,100]}

00:13:54.840 --> 00:13:57.420
<v Speaker 1>I said local was a mistake because that's a different

NOTE CONF {"raw":[100,100,100,100,98,100,100,100,100,100]}

00:13:57.420 --> 00:14:01.920
<v Speaker 1>language that I also have taught in the past where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:01.920 --> 00:14:02.790
<v Speaker 1>it's called local.

NOTE CONF {"raw":[100,100,100]}

00:14:02.790 --> 00:14:03.600
<v Speaker 1>Never mind.

NOTE CONF {"raw":[100,100]}

00:14:04.080 --> 00:14:07.800
<v Speaker 1>Um, so you're going to be writing definitions with helper

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:07.800 --> 00:14:11.070
<v Speaker 1>functions in this course from time to time.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:14:11.070 --> 00:14:13.860
<v Speaker 1>So, um, you know, this is a this is a

NOTE CONF {"raw":[100,100,100,100,100,100,93,100,100,100]}

00:14:13.860 --> 00:14:14.610
<v Speaker 1>way to do it.

NOTE CONF {"raw":[100,100,100,100]}

00:14:16.290 --> 00:14:17.070
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:17.670 --> 00:14:18.060
<v Speaker 1>Clear.

NOTE CONF {"raw":[100]}

00:14:18.060 --> 00:14:20.160
<v Speaker 1>And the only reason, the only reason to sort of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:20.160 --> 00:14:23.400
<v Speaker 1>not just write these things one after the other is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:23.400 --> 00:14:27.270
<v Speaker 1>if you want to, um, make it explicit that this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:27.270 --> 00:14:31.110
<v Speaker 1>is, that this is a kind of definition only for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:31.110 --> 00:14:32.910
<v Speaker 1>the purpose of writing this other definition.

NOTE CONF {"raw":[100,100,100,100,100,100,92]}

00:14:32.940 --> 00:14:33.990
<v Speaker 1>See, it's used here.

NOTE CONF {"raw":[99,100,100,100]}

00:14:34.680 --> 00:14:35.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:35.400 --> 00:14:37.650
<v Speaker 1>The idea being that it won't be used anywhere else

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:37.650 --> 00:14:38.820
<v Speaker 1>in your program.

NOTE CONF {"raw":[100,100,100]}

00:14:39.090 --> 00:14:39.780
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:39.780 --> 00:14:41.580
<v Speaker 1>It's just temporary.

NOTE CONF {"raw":[100,100,100]}

00:14:41.610 --> 00:14:41.970
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:41.970 --> 00:14:45.640
<v Speaker 1>This is partly to avoid, like having lots and lots

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:45.640 --> 00:14:49.390
<v Speaker 1>of definitions that are that are only useful in particular

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:49.390 --> 00:14:50.380
<v Speaker 1>contexts.

NOTE CONF {"raw":[100]}

00:14:52.060 --> 00:14:53.830
<v Speaker 1>So I'm going to skip this, but it's on the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:53.830 --> 00:14:55.360
<v Speaker 1>slide if you want to go back and look at

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:14:55.360 --> 00:14:56.920
<v Speaker 1>it after the lecture.

NOTE CONF {"raw":[100,100,100,100]}

00:14:58.540 --> 00:14:58.870
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:14:58.870 --> 00:15:02.440
<v Speaker 1>I want to talk now about, um, something that's special

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,100,100]}

00:15:02.440 --> 00:15:07.900
<v Speaker 1>in Haskell, uh, which is, um, the ability to, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,91]}

00:15:07.900 --> 00:15:13.000
<v Speaker 1>compute with infinite data structures and, uh, for example, infinite

NOTE CONF {"raw":[100,100,100,100,100,94,56,100,100,100]}

00:15:13.000 --> 00:15:13.780
<v Speaker 1>lists.

NOTE CONF {"raw":[100]}

00:15:14.830 --> 00:15:15.310
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:15:15.310 --> 00:15:18.010
<v Speaker 1>So this is a notation in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:18.010 --> 00:15:20.950
<v Speaker 1>This is like I had a minute ago, except instead

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:20.950 --> 00:15:23.320
<v Speaker 1>of, uh, you know, from one up to 100 or

NOTE CONF {"raw":[100,91,100,100,100,100,100,100,100,100]}

00:15:23.320 --> 00:15:23.920
<v Speaker 1>something.

NOTE CONF {"raw":[100]}

00:15:23.920 --> 00:15:27.130
<v Speaker 1>I say I want the list of numbers from zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:27.820 --> 00:15:28.780
<v Speaker 1>Dot dot.

NOTE CONF {"raw":[100,100]}

00:15:29.320 --> 00:15:30.670
<v Speaker 1>No, no upper limit.

NOTE CONF {"raw":[91,100,100,100]}

00:15:30.670 --> 00:15:35.260
<v Speaker 1>So the numbers, the numbers from zero up to, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:35.260 --> 00:15:36.220
<v Speaker 1>know, forever.

NOTE CONF {"raw":[100,100]}

00:15:38.770 --> 00:15:39.130
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:15:39.130 --> 00:15:40.180
<v Speaker 1>You can do that in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:15:40.180 --> 00:15:41.770
<v Speaker 1>That's a bit unusual.

NOTE CONF {"raw":[100,100,100,100]}

00:15:42.790 --> 00:15:45.550
<v Speaker 1>and I'll explain a little bit about how that works.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:15:45.580 --> 00:15:48.460
<v Speaker 1>It's a mechanism called lazy evaluation.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:15:49.510 --> 00:15:51.820
<v Speaker 1>So this is something that's quite unusual.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:15:52.090 --> 00:15:55.780
<v Speaker 1>Um, well, first of all, it's, uh, it's something that's,

NOTE CONF {"raw":[100,100,100,100,100,100,81,100,100,100]}

00:15:57.280 --> 00:16:00.580
<v Speaker 1>uh, available in some functional programming languages, but not all.

NOTE CONF {"raw":[68,100,100,100,100,100,100,100,100,100]}

00:16:00.580 --> 00:16:02.440
<v Speaker 1>So it's a little bit special to Haskell, and it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:02.440 --> 00:16:03.550
<v Speaker 1>kind of cool.

NOTE CONF {"raw":[100,100,100]}

00:16:03.580 --> 00:16:05.470
<v Speaker 1>I mean, first of all, the idea that you can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:05.470 --> 00:16:08.440
<v Speaker 1>compute with infinite data structures is kind of is kind

NOTE CONF {"raw":[100,100,100,100,100,84,100,100,98,100]}

00:16:08.440 --> 00:16:10.240
<v Speaker 1>of odd, okay.

NOTE CONF {"raw":[100,100,100]}

00:16:10.240 --> 00:16:16.300
<v Speaker 1>Because there's, you know, your computer might have, you know,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:16.300 --> 00:16:19.270
<v Speaker 1>megabytes or gigabytes of, of storage, but it doesn't have

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:16:19.270 --> 00:16:20.500
<v Speaker 1>infinite amounts of storage.

NOTE CONF {"raw":[100,100,100,100]}

00:16:20.500 --> 00:16:22.630
<v Speaker 1>So where do you put all the, the values and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,75]}

00:16:22.630 --> 00:16:23.890
<v Speaker 1>these data structures?

NOTE CONF {"raw":[100,100,100]}

00:16:24.460 --> 00:16:25.150
<v Speaker 1>Okay.

NOTE CONF {"raw":[66]}

00:16:25.420 --> 00:16:25.780
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:16:27.970 --> 00:16:29.140
<v Speaker 1>So I'll come to that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:16:29.560 --> 00:16:34.060
<v Speaker 1>Uh, for now, let me just, uh, talk about this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:34.060 --> 00:16:34.510
<v Speaker 1>function.

NOTE CONF {"raw":[100]}

00:16:34.510 --> 00:16:38.560
<v Speaker 1>So, so this, this, um, this notation, 0...

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:16:38.560 --> 00:16:41.480
<v Speaker 1>This is an invocation of a function called enum from.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:41.480 --> 00:16:44.600
<v Speaker 1>It's not enum from two, it's just enum from, and

NOTE CONF {"raw":[84,100,100,100,100,100,100,94,100,100]}

00:16:44.600 --> 00:16:47.060
<v Speaker 1>you give it the lower limit and it goes and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:16:47.060 --> 00:16:49.220
<v Speaker 1>computes this infinite list.

NOTE CONF {"raw":[100,100,100,100]}

00:16:49.880 --> 00:16:50.660
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:16:51.200 --> 00:16:53.030
<v Speaker 1>So and here is the code.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:16:55.430 --> 00:16:57.020
<v Speaker 1>Okay enum from M.

NOTE CONF {"raw":[100,100,100,99]}

00:16:57.020 --> 00:16:59.690
<v Speaker 1>So it's a function from into a list of int

NOTE CONF {"raw":[100,99,97,100,100,100,88,100,100,100]}

00:16:59.840 --> 00:17:02.030
<v Speaker 1>enum from m m.

NOTE CONF {"raw":[100,100,100,100]}

00:17:02.030 --> 00:17:06.170
<v Speaker 1>It's m cons enum from m plus one okay.

NOTE CONF {"raw":[100,100,83,100,100,95,100,100,100]}

00:17:06.170 --> 00:17:08.720
<v Speaker 1>So you take the lower limit and you stick it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:08.720 --> 00:17:11.060
<v Speaker 1>on the front of a list starting from M plus

NOTE CONF {"raw":[100,100,100,100,68,100,100,100,100,100]}

00:17:11.060 --> 00:17:13.699
<v Speaker 1>one up forever.

NOTE CONF {"raw":[100,100,100]}

00:17:14.209 --> 00:17:14.900
<v Speaker 1>Okay.

NOTE CONF {"raw":[86]}

00:17:15.350 --> 00:17:16.040
<v Speaker 1>Clear.

NOTE CONF {"raw":[100]}

00:17:16.040 --> 00:17:19.819
<v Speaker 1>It's simpler than the previous definition, because you don't have

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:19.819 --> 00:17:23.240
<v Speaker 1>to bother checking that the lower limit is less than

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:23.240 --> 00:17:24.560
<v Speaker 1>or equal to the upper limit.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:17:25.370 --> 00:17:29.120
<v Speaker 1>Okay, so here is an example of a non one.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:17:29.630 --> 00:17:35.780
<v Speaker 1>Every other non well-founded recursive definition okay.

NOTE CONF {"raw":[30,42,100,100,100,100,100]}

00:17:35.780 --> 00:17:37.490
<v Speaker 1>There's nothing getting smaller.

NOTE CONF {"raw":[100,100,100,100]}

00:17:39.170 --> 00:17:40.730
<v Speaker 1>Um the arguments getting bigger.

NOTE CONF {"raw":[76,100,100,100,100]}

00:17:41.270 --> 00:17:43.730
<v Speaker 1>And so, in fact, this will run forever.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:17:49.730 --> 00:17:50.810
<v Speaker 1>So let me show you it.

NOTE CONF {"raw":[100,100,100,100,100,96]}

00:17:50.810 --> 00:17:51.740
<v Speaker 1>Running forever.

NOTE CONF {"raw":[100,100]}

00:17:53.420 --> 00:17:54.410
<v Speaker 1>Uh, just a second.

NOTE CONF {"raw":[100,100,100,100]}

00:18:11.900 --> 00:18:14.060
<v Speaker 1>Okay, so this, uh, this will run forever.

NOTE CONF {"raw":[100,100,100,89,100,100,100,100]}

00:18:14.060 --> 00:18:15.020
<v Speaker 1>Let me stop it.

NOTE CONF {"raw":[100,100,100,100]}

00:18:15.830 --> 00:18:17.720
<v Speaker 1>Uh, because I don't have forever.

NOTE CONF {"raw":[97,95,100,100,100,100]}

00:18:17.990 --> 00:18:18.290
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:18:18.770 --> 00:18:22.280
<v Speaker 1>Uh, so it's got up to 6800 and something.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:18:23.690 --> 00:18:25.580
<v Speaker 1>Let me just show you that it started at zero

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:25.580 --> 00:18:26.060
<v Speaker 1>if I can.

NOTE CONF {"raw":[100,100,100]}

00:18:26.060 --> 00:18:26.570
<v Speaker 1>If it's still.

NOTE CONF {"raw":[100,100,100]}

00:18:26.570 --> 00:18:26.840
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:18:26.840 --> 00:18:29.480
<v Speaker 1>So it started with zero, one, two, three, etc..

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:18:29.480 --> 00:18:30.020
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:18:30.020 --> 00:18:32.990
<v Speaker 1>And it'll just go forever as long as I want

NOTE CONF {"raw":[100,73,100,100,100,100,100,100,100,100]}

00:18:32.990 --> 00:18:33.740
<v Speaker 1>it to go.

NOTE CONF {"raw":[100,100,100]}

00:18:34.850 --> 00:18:35.660
<v Speaker 1>All right.

NOTE CONF {"raw":[99,99]}

00:18:36.230 --> 00:18:37.370
<v Speaker 1>Um, so that's interesting.

NOTE CONF {"raw":[100,100,100,100]}

00:18:37.370 --> 00:18:39.500
<v Speaker 1>I mean, this is very useful if what you want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:39.500 --> 00:18:42.440
<v Speaker 1>is your your screen to fill up with numbers that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:42.440 --> 00:18:43.610
<v Speaker 1>keep getting larger.

NOTE CONF {"raw":[100,100,100]}

00:18:44.120 --> 00:18:47.030
<v Speaker 1>Um, uh, okay.

NOTE CONF {"raw":[100,100,100]}

00:18:47.030 --> 00:18:49.700
<v Speaker 1>It's also useful for other things, uh, since that's not

NOTE CONF {"raw":[100,100,100,100,100,100,75,100,100,100]}

00:18:49.700 --> 00:18:52.370
<v Speaker 1>very exciting or interesting, but it does that.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:18:52.370 --> 00:18:52.910
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:18:53.120 --> 00:18:56.450
<v Speaker 1>Um, uh, so one of the things about this, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:18:56.450 --> 00:18:59.840
<v Speaker 1>might think, you know, what's the use of, uh, of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,52,100]}

00:18:59.840 --> 00:19:02.240
<v Speaker 1>going on forever with computations like this?

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:19:02.240 --> 00:19:03.800
<v Speaker 1>What's the use of the infinite data structure?

NOTE CONF {"raw":[100,100,100,100,100,100,100,81]}

00:19:03.800 --> 00:19:07.160
<v Speaker 1>So first of all, to convince you that that this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:07.160 --> 00:19:13.700
<v Speaker 1>actually, um, is useful for computation, I will say that,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:13.700 --> 00:19:14.570
<v Speaker 1>um, the mechanism.

NOTE CONF {"raw":[95,100,100]}

00:19:14.660 --> 00:19:18.680
<v Speaker 1>So mechanism of lazy computation is, um, the idea that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:18.680 --> 00:19:22.250
<v Speaker 1>you, you operate on an infinite data structures by only

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:22.250 --> 00:19:25.970
<v Speaker 1>doing enough computation to get the answer you're interested in.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:26.510 --> 00:19:27.230
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:27.230 --> 00:19:31.790
<v Speaker 1>So for example, suppose that I'm only interested in what

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:31.790 --> 00:19:33.950
<v Speaker 1>the head is of this list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:19:35.450 --> 00:19:36.260
<v Speaker 1>Okay.

NOTE CONF {"raw":[91]}

00:19:36.500 --> 00:19:37.140
<v Speaker 1>I don't.

NOTE CONF {"raw":[100,100]}

00:19:37.290 --> 00:19:38.790
<v Speaker 1>I don't have to compute the whole list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:19:38.790 --> 00:19:41.280
<v Speaker 1>I only have to compute the first bit to get.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:41.280 --> 00:19:42.570
<v Speaker 1>The answer is zero.

NOTE CONF {"raw":[100,100,100,100]}

00:19:44.460 --> 00:19:48.120
<v Speaker 1>Okay, that's lazy evaluation in operation.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:19:48.120 --> 00:19:48.570
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:19:48.570 --> 00:19:51.090
<v Speaker 1>And it's not a special thing about the first element

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:51.090 --> 00:19:52.470
<v Speaker 1>of an infinite list.

NOTE CONF {"raw":[100,100,100,100]}

00:19:52.470 --> 00:19:55.410
<v Speaker 1>It'll also work on you know it'll work.

NOTE CONF {"raw":[100,100,100,100,100,100,58,57]}

00:19:55.560 --> 00:19:59.040
<v Speaker 1>However, however far I need to go on this list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:19:59.040 --> 00:20:01.710
<v Speaker 1>to to get the answer that I'm interested in.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:20:05.190 --> 00:20:09.990
<v Speaker 1>Okay, here's, uh, the, uh, it's the seventh element we

NOTE CONF {"raw":[100,58,100,100,98,100,100,100,100,100]}

00:20:09.990 --> 00:20:10.290
<v Speaker 1>start.

NOTE CONF {"raw":[98]}

00:20:10.410 --> 00:20:12.510
<v Speaker 1>You know, zero is the first one, six is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:12.510 --> 00:20:13.200
<v Speaker 1>seventh one.

NOTE CONF {"raw":[100,100]}

00:20:13.200 --> 00:20:16.410
<v Speaker 1>Whatever amount of computation I need to get, I need

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:16.410 --> 00:20:18.540
<v Speaker 1>to do to get the answer, it will do that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:18.540 --> 00:20:19.530
<v Speaker 1>and no more.

NOTE CONF {"raw":[100,100,100]}

00:20:20.190 --> 00:20:20.520
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:20:20.520 --> 00:20:21.570
<v Speaker 1>That's lazy evaluation.

NOTE CONF {"raw":[100,100,88]}

00:20:21.570 --> 00:20:25.230
<v Speaker 1>It's a, you know, uh, it's for it's for people

NOTE CONF {"raw":[100,43,100,100,100,100,95,100,100,100]}

00:20:25.230 --> 00:20:27.030
<v Speaker 1>who don't like getting out of bed in the morning.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:27.030 --> 00:20:30.690
<v Speaker 1>They, uh, they avoid, um, doing work until it's absolutely

NOTE CONF {"raw":[100,67,100,100,78,100,100,100,100,100]}

00:20:30.690 --> 00:20:31.200
<v Speaker 1>necessary.

NOTE CONF {"raw":[100]}

00:20:31.200 --> 00:20:32.520
<v Speaker 1>So you do here work?

NOTE CONF {"raw":[100,100,100,100,100]}

00:20:32.790 --> 00:20:35.610
<v Speaker 1>Um, just the amount required to get the answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:20:35.760 --> 00:20:37.260
<v Speaker 1>And so that's some.

NOTE CONF {"raw":[100,100,100,93]}

00:20:39.690 --> 00:20:40.650
<v Speaker 1>That's a nice thing.

NOTE CONF {"raw":[100,90,100,100]}

00:20:40.650 --> 00:20:42.600
<v Speaker 1>You operate on infinite data structures.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:20:42.600 --> 00:20:45.300
<v Speaker 1>You never need all the values to get your answer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:45.300 --> 00:20:48.480
<v Speaker 1>You only need enough to compute the result you're interested

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:48.480 --> 00:20:48.870
<v Speaker 1>in.

NOTE CONF {"raw":[100]}

00:20:49.860 --> 00:20:53.850
<v Speaker 1>Um, and I'll show you a cool program that does

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:20:53.850 --> 00:20:57.210
<v Speaker 1>something uh, with that.

NOTE CONF {"raw":[100,85,100,100]}

00:20:57.210 --> 00:21:00.840
<v Speaker 1>So here is a program to compute the infinite list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:01.530 --> 00:21:02.910
<v Speaker 1>Yeah, that's on the screen.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:02.910 --> 00:21:03.300
<v Speaker 1>Yeah.

NOTE CONF {"raw":[86]}

00:21:03.810 --> 00:21:06.720
<v Speaker 1>Um, the infinite list of prime numbers.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:09.270 --> 00:21:09.990
<v Speaker 1>All right.

NOTE CONF {"raw":[95,95]}

00:21:09.990 --> 00:21:13.260
<v Speaker 1>And it's just two lines plus, uh, place plus type

NOTE CONF {"raw":[100,100,100,100,100,100,88,92,100,100]}

00:21:13.260 --> 00:21:13.710
<v Speaker 1>signature.

NOTE CONF {"raw":[98]}

00:21:13.710 --> 00:21:17.340
<v Speaker 1>So here's the program, uh, called primes.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:21:17.340 --> 00:21:20.760
<v Speaker 1>It gives you the infinite list of prime numbers and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:20.760 --> 00:21:26.070
<v Speaker 1>it uses a function called is primes is prime, which

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:26.070 --> 00:21:27.840
<v Speaker 1>takes a number and tells you if it's prime or

NOTE CONF {"raw":[100,100,100,100,100,100,100,94,100,100]}

00:21:27.840 --> 00:21:28.320
<v Speaker 1>not.

NOTE CONF {"raw":[100]}

00:21:29.190 --> 00:21:29.700
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:21:29.700 --> 00:21:30.570
<v Speaker 1>So let's look at this.

NOTE CONF {"raw":[100,100,100,100,100]}

00:21:30.570 --> 00:21:34.500
<v Speaker 1>This is one this this one doesn't use, uh, lazy

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,74,100]}

00:21:34.510 --> 00:21:35.260
<v Speaker 1>evaluation.

NOTE CONF {"raw":[100]}

00:21:35.260 --> 00:21:36.700
<v Speaker 1>But let's look at it anyway.

NOTE CONF {"raw":[100,100,100,100,95,100]}

00:21:36.700 --> 00:21:41.350
<v Speaker 1>It's, um, it's saying a number is prime if it

NOTE CONF {"raw":[100,100,100,100,100,100,94,96,100,100]}

00:21:41.350 --> 00:21:44.290
<v Speaker 1>has, if you look at all of the numbers between

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:44.290 --> 00:21:49.030
<v Speaker 1>two and n minus one, none of those are divisors

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:21:49.030 --> 00:21:50.260
<v Speaker 1>of n.

NOTE CONF {"raw":[100,100]}

00:21:53.050 --> 00:21:53.380
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:21:53.380 --> 00:21:55.510
<v Speaker 1>So it's uh, it's written as a as a list

NOTE CONF {"raw":[100,100,83,100,100,100,100,100,100,100]}

00:21:55.510 --> 00:21:56.500
<v Speaker 1>comprehension.

NOTE CONF {"raw":[100]}

00:21:57.700 --> 00:22:02.380
<v Speaker 1>It's computing uh, for, for x drawn from the list

NOTE CONF {"raw":[100,100,93,100,100,100,100,100,100,100]}

00:22:02.380 --> 00:22:04.450
<v Speaker 1>from two up to n minus one.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:22:04.450 --> 00:22:09.070
<v Speaker 1>It's, it's looking to see whether n mod x is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:09.070 --> 00:22:09.850
<v Speaker 1>equal to zero.

NOTE CONF {"raw":[100,100,100]}

00:22:09.850 --> 00:22:13.420
<v Speaker 1>So mod you haven't seen before I don't think uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,66]}

00:22:13.420 --> 00:22:18.730
<v Speaker 1>it means um it's, it means modulo or uh other.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,98]}

00:22:18.730 --> 00:22:20.740
<v Speaker 1>Another term is remainder.

NOTE CONF {"raw":[100,100,100,100]}

00:22:20.740 --> 00:22:24.550
<v Speaker 1>So n divided by the remainder of n divided by

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:24.550 --> 00:22:27.550
<v Speaker 1>x is what's being computed here.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:27.730 --> 00:22:33.520
<v Speaker 1>You know, the remainder like 1010 mod three is ten

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:22:33.520 --> 00:22:34.450
<v Speaker 1>divided by three.

NOTE CONF {"raw":[100,100,100]}

00:22:34.450 --> 00:22:35.290
<v Speaker 1>What's the remainder?

NOTE CONF {"raw":[100,100,100]}

00:22:35.290 --> 00:22:36.040
<v Speaker 1>It's one.

NOTE CONF {"raw":[100,100]}

00:22:36.730 --> 00:22:38.950
<v Speaker 1>Okay, nine divided by three.

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:38.950 --> 00:22:40.270
<v Speaker 1>Remainder zero.

NOTE CONF {"raw":[100,100]}

00:22:40.270 --> 00:22:41.320
<v Speaker 1>Ten divided by three.

NOTE CONF {"raw":[100,100,100,100]}

00:22:41.320 --> 00:22:42.220
<v Speaker 1>Remainder one.

NOTE CONF {"raw":[100,100]}

00:22:42.250 --> 00:22:43.450
<v Speaker 1>Are you familiar with this?

NOTE CONF {"raw":[100,100,100,100,100]}

00:22:43.600 --> 00:22:45.340
<v Speaker 1>Remainder okay.

NOTE CONF {"raw":[100,82]}

00:22:45.760 --> 00:22:48.430
<v Speaker 1>Uh, in mathematics called modular arithmetic.

NOTE CONF {"raw":[82,100,100,100,100,100]}

00:22:48.430 --> 00:22:50.050
<v Speaker 1>And that's the name here okay.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:22:50.050 --> 00:22:54.820
<v Speaker 1>So we're looking for x's all of the values x

NOTE CONF {"raw":[100,100,100,100,52,100,100,100,100,100]}

00:22:54.820 --> 00:23:00.040
<v Speaker 1>between two and n minus one such that dividing dividing

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:00.040 --> 00:23:04.750
<v Speaker 1>n the number I'm interested in here uh by x

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:05.140 --> 00:23:06.160
<v Speaker 1>is equal to zero.

NOTE CONF {"raw":[100,100,100,100]}

00:23:06.160 --> 00:23:10.420
<v Speaker 1>That means that x divides n okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:23:10.420 --> 00:23:16.000
<v Speaker 1>You know, two divides 56 uh, etc. you know.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:23:16.000 --> 00:23:16.270
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:23:16.270 --> 00:23:16.570
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:16.570 --> 00:23:18.820
<v Speaker 1>So we compute this list.

NOTE CONF {"raw":[100,100,100,100,100]}

00:23:19.420 --> 00:23:22.150
<v Speaker 1>There it is using list comprehension.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:22.150 --> 00:23:24.550
<v Speaker 1>And the number is is prime.

NOTE CONF {"raw":[100,100,76,39,100,100]}

00:23:24.550 --> 00:23:26.650
<v Speaker 1>If that list is empty right.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:23:26.650 --> 00:23:31.960
<v Speaker 1>If there are no divisors of n okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:23:31.960 --> 00:23:32.630
<v Speaker 1>Is that clear?

NOTE CONF {"raw":[100,100,100]}

00:23:32.630 --> 00:23:35.960
<v Speaker 1>That's the most complicated part of this definition, is the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:35.960 --> 00:23:37.940
<v Speaker 1>definition of what it means to something to be prime.

NOTE CONF {"raw":[100,100,100,100,100,86,100,100,100,98]}

00:23:38.810 --> 00:23:43.610
<v Speaker 1>Um, pretty, pretty concise definition that you can write in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:43.610 --> 00:23:46.100
<v Speaker 1>Haskell and then the list of prime numbers.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:23:46.730 --> 00:23:47.030
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:47.030 --> 00:23:50.240
<v Speaker 1>You take all of the numbers from n from two

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:50.240 --> 00:23:55.850
<v Speaker 1>on up, and you, uh, and you check to see

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:23:55.850 --> 00:23:57.170
<v Speaker 1>if they're prime or not.

NOTE CONF {"raw":[100,99,100,100,100]}

00:23:57.680 --> 00:23:58.850
<v Speaker 1>Each one of them.

NOTE CONF {"raw":[100,100,100,100]}

00:23:59.210 --> 00:23:59.810
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:23:59.810 --> 00:24:02.930
<v Speaker 1>And the result is the list of those that are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:02.930 --> 00:24:03.500
<v Speaker 1>prime.

NOTE CONF {"raw":[100]}

00:24:04.340 --> 00:24:05.000
<v Speaker 1>Okay.

NOTE CONF {"raw":[93]}

00:24:06.770 --> 00:24:09.290
<v Speaker 1>You couldn't be simpler than that.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:10.370 --> 00:24:10.790
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:24:10.790 --> 00:24:12.980
<v Speaker 1>Prime numbers are all the numbers from two on up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:24:13.430 --> 00:24:14.450
<v Speaker 1>which are prime.

NOTE CONF {"raw":[100,100,100]}

00:24:14.450 --> 00:24:16.130
<v Speaker 1>So let's see if this works.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:24.500 --> 00:24:25.400
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:24:25.400 --> 00:24:26.120
<v Speaker 1>Uh.

NOTE CONF {"raw":[100]}

00:24:28.880 --> 00:24:30.350
<v Speaker 1>So I can type primes.

NOTE CONF {"raw":[100,100,98,67,100]}

00:24:30.740 --> 00:24:34.850
<v Speaker 1>And I'm going to get this list, okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:24:34.850 --> 00:24:36.530
<v Speaker 1>And it's going to keep on going.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:36.890 --> 00:24:39.110
<v Speaker 1>Well yeah it won't let me.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:39.140 --> 00:24:42.050
<v Speaker 1>It won't look like it won't let me look at

NOTE CONF {"raw":[100,100,100,98,100,100,100,100,100,100]}

00:24:42.050 --> 00:24:44.450
<v Speaker 1>the first one because it's busy doing the other ones.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,88]}

00:24:44.510 --> 00:24:45.740
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[100,100]}

00:24:45.740 --> 00:24:47.450
<v Speaker 1>This is going to go on forever.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:24:49.010 --> 00:24:50.750
<v Speaker 1>And all these numbers are prime.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:24:51.740 --> 00:24:52.730
<v Speaker 1>Actually, I should have started.

NOTE CONF {"raw":[100,100,100,100,100]}

00:24:52.730 --> 00:24:55.100
<v Speaker 1>I should have started by convincing you that Isprime is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,82,100]}

00:24:55.100 --> 00:24:56.120
<v Speaker 1>actually correct.

NOTE CONF {"raw":[100,100]}

00:24:56.720 --> 00:24:59.120
<v Speaker 1>Who has a favourite large prime number?

NOTE CONF {"raw":[100,100,100,83,100,100,100]}

00:25:01.730 --> 00:25:03.530
<v Speaker 1>Anybody shout it out.

NOTE CONF {"raw":[100,100,100,100]}

00:25:04.190 --> 00:25:04.400
<v Speaker 1>Six.

NOTE CONF {"raw":[100]}

00:25:04.400 --> 00:25:04.610
<v Speaker 1>Five.

NOTE CONF {"raw":[100]}

00:25:04.610 --> 00:25:07.190
<v Speaker 1>5355535.

NOTE CONF {"raw":[100]}

00:25:07.190 --> 00:25:12.110
<v Speaker 1>No 5537.

NOTE CONF {"raw":[100,100]}

00:25:13.190 --> 00:25:14.450
<v Speaker 1>That's not prime.

NOTE CONF {"raw":[100,100,100]}

00:25:14.750 --> 00:25:14.840
<v Speaker 1>Uh.

NOTE CONF {"raw":[96]}

00:25:14.840 --> 00:25:18.770
<v Speaker 1>Let's try, uh, let's try that.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:25:19.190 --> 00:25:20.720
<v Speaker 1>That's also not prime.

NOTE CONF {"raw":[100,100,100,100]}

00:25:20.930 --> 00:25:22.100
<v Speaker 1>Um, okay.

NOTE CONF {"raw":[99,100]}

00:25:22.700 --> 00:25:24.770
<v Speaker 1>Uh, nope.

NOTE CONF {"raw":[100,100]}

00:25:24.770 --> 00:25:27.080
<v Speaker 1>We're not getting, uh.

NOTE CONF {"raw":[100,100,100,100]}

00:25:28.160 --> 00:25:29.720
<v Speaker 1>This is surely prime.

NOTE CONF {"raw":[100,100,100,100]}

00:25:29.820 --> 00:25:32.790
<v Speaker 1>Um, yes.

NOTE CONF {"raw":[91,100]}

00:25:32.790 --> 00:25:33.060
<v Speaker 1>Okay.

NOTE CONF {"raw":[94]}

00:25:33.060 --> 00:25:34.350
<v Speaker 1>So that's prime, for example.

NOTE CONF {"raw":[100,100,100,100,100]}

00:25:34.350 --> 00:25:34.860
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:34.860 --> 00:25:40.350
<v Speaker 1>Because because if we take, um, the numbers, uh, well

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:40.350 --> 00:25:42.510
<v Speaker 1>I won't I won't type it out, but, um, it's

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,63,100]}

00:25:42.510 --> 00:25:45.210
<v Speaker 1>checking all of the, all of the numbers from one

NOTE CONF {"raw":[100,100,97,100,100,100,100,100,100,100]}

00:25:45.210 --> 00:25:49.290
<v Speaker 1>up to five, five, three, zero from two up to

NOTE CONF {"raw":[100,100,100,100,100,87,100,100,100,100]}

00:25:49.290 --> 00:25:52.050
<v Speaker 1>there and checking to see whether they divide that number

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:52.050 --> 00:25:53.160
<v Speaker 1>or not evenly.

NOTE CONF {"raw":[100,100,100]}

00:25:53.520 --> 00:25:54.090
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:25:54.090 --> 00:25:55.890
<v Speaker 1>So I'm going to start so that that's used to

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:25:55.890 --> 00:25:57.810
<v Speaker 1>compute this infinite list of prime numbers.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:25:57.810 --> 00:25:58.740
<v Speaker 1>And it'll go on.

NOTE CONF {"raw":[98,94,100,100]}

00:25:58.740 --> 00:26:01.860
<v Speaker 1>It'll keep on going forever until I stop it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:26:02.790 --> 00:26:06.510
<v Speaker 1>So I'll let that compute and go back to my

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:06.510 --> 00:26:07.320
<v Speaker 1>lecture.

NOTE CONF {"raw":[100]}

00:26:07.830 --> 00:26:09.660
<v Speaker 1>Uh, and we can see how far it got.

NOTE CONF {"raw":[95,100,100,100,100,100,100,100,100]}

00:26:12.840 --> 00:26:13.710
<v Speaker 1>When I'm done.

NOTE CONF {"raw":[100,100,100]}

00:26:19.410 --> 00:26:23.610
<v Speaker 1>So this is, um, this is, uh, this is the

NOTE CONF {"raw":[100,100,100,84,100,100,100,100,100,97]}

00:26:23.610 --> 00:26:28.410
<v Speaker 1>computation sequence for this, um, in, um, from, uh, a

NOTE CONF {"raw":[100,100,100,100,100,91,93,100,81,37]}

00:26:28.410 --> 00:26:30.990
<v Speaker 1>Our function, which is computing the numbers from zero up

NOTE CONF {"raw":[56,100,100,100,100,100,100,100,100,100]}

00:26:30.990 --> 00:26:31.950
<v Speaker 1>on forever.

NOTE CONF {"raw":[100,100]}

00:26:31.980 --> 00:26:32.310
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:26:32.310 --> 00:26:32.910
<v Speaker 1>You can see that.

NOTE CONF {"raw":[100,100,100,100]}

00:26:32.910 --> 00:26:34.050
<v Speaker 1>That's what it does.

NOTE CONF {"raw":[100,100,100,100]}

00:26:39.360 --> 00:26:39.780
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:26:42.840 --> 00:26:45.510
<v Speaker 1>I'll say, by the way, more about lazy evaluation a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:45.510 --> 00:26:49.380
<v Speaker 1>bit later in the course when you have more under

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:26:49.380 --> 00:26:51.810
<v Speaker 1>your belt to understand what's going on.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:26:53.490 --> 00:26:55.620
<v Speaker 1>Um, for now, it's just a kind of curiosity.

NOTE CONF {"raw":[91,100,100,100,100,96,100,100,100]}

00:26:55.770 --> 00:26:56.190
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:26:58.410 --> 00:27:01.050
<v Speaker 1>Let me carry on to talk about, um, a couple

NOTE CONF {"raw":[100,100,100,100,100,100,100,68,100,100]}

00:27:01.050 --> 00:27:04.050
<v Speaker 1>of functions or actually one, one function.

NOTE CONF {"raw":[100,100,100,100,96,100,100]}

00:27:04.200 --> 00:27:04.800
<v Speaker 1>ZIP.

NOTE CONF {"raw":[99]}

00:27:05.250 --> 00:27:08.790
<v Speaker 1>Um, that is another built in function in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:08.790 --> 00:27:15.930
<v Speaker 1>And, um, it's, uh, the definition demonstrates another, um, uh,

NOTE CONF {"raw":[100,52,100,100,100,100,100,100,100,100]}

00:27:15.930 --> 00:27:17.670
<v Speaker 1>it's another pattern of recursion.

NOTE CONF {"raw":[100,100,100,100,100]}

00:27:17.790 --> 00:27:18.090
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:27:18.090 --> 00:27:18.870
<v Speaker 1>So let me explain.

NOTE CONF {"raw":[100,100,100,100]}

00:27:18.870 --> 00:27:19.440
<v Speaker 1>ZIP.

NOTE CONF {"raw":[100]}

00:27:20.550 --> 00:27:25.590
<v Speaker 1>So zip look at the type up here okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:27:25.590 --> 00:27:29.590
<v Speaker 1>It it takes It takes two lists and produces a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:29.590 --> 00:27:32.350
<v Speaker 1>list of pairs, and the two lists it takes can

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:32.350 --> 00:27:35.950
<v Speaker 1>have different types of elements in them and the pairs

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:35.950 --> 00:27:36.610
<v Speaker 1>that it produced.

NOTE CONF {"raw":[100,100,100]}

00:27:36.610 --> 00:27:37.960
<v Speaker 1>The list of pairs of produce has.

NOTE CONF {"raw":[100,97,100,100,79,97,92]}

00:27:37.960 --> 00:27:41.800
<v Speaker 1>This has an element from the first list, together with

NOTE CONF {"raw":[30,100,100,100,100,100,100,100,100,100]}

00:27:41.800 --> 00:27:43.330
<v Speaker 1>an element from the second list.

NOTE CONF {"raw":[90,100,100,100,100,100]}

00:27:44.500 --> 00:27:47.800
<v Speaker 1>Okay, and here's how to think of it.

NOTE CONF {"raw":[100,100,99,100,100,100,100,100]}

00:27:48.160 --> 00:27:50.350
<v Speaker 1>Uh, think of a zipper on your jacket or something

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:27:50.350 --> 00:27:50.890
<v Speaker 1>like that.

NOTE CONF {"raw":[100,100]}

00:27:50.890 --> 00:27:53.860
<v Speaker 1>Okay, so zipper has two sets of teeth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:27:54.730 --> 00:27:57.340
<v Speaker 1>Uh, here's the here's one of the set of teeth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:27:57.340 --> 00:28:00.760
<v Speaker 1>Here's one of the the teeth, the rows of teeth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:00.760 --> 00:28:02.350
<v Speaker 1>Here's the other row of teeth.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:28:02.350 --> 00:28:05.560
<v Speaker 1>So a zipper, you, um, you zip it up and

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:28:05.560 --> 00:28:07.600
<v Speaker 1>it and it interweaves the teeth.

NOTE CONF {"raw":[100,100,100,97,100,100]}

00:28:08.350 --> 00:28:10.690
<v Speaker 1>Okay, so that your jacket's closed.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:28:12.070 --> 00:28:13.570
<v Speaker 1>Okay, so that's zipping.

NOTE CONF {"raw":[100,100,100,100]}

00:28:13.570 --> 00:28:15.040
<v Speaker 1>Okay, this is almost like that.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:28:15.040 --> 00:28:16.450
<v Speaker 1>It's not quite like that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:28:16.660 --> 00:28:19.510
<v Speaker 1>Um, what you do here is you've got two lists

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:19.510 --> 00:28:24.160
<v Speaker 1>of teeth, and, um, and you don't interleave them, you

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100,100]}

00:28:24.160 --> 00:28:27.610
<v Speaker 1>put them next to each other Okay, so the first

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:27.610 --> 00:28:31.150
<v Speaker 1>thing in the list is the bottom, uh, the bottom

NOTE CONF {"raw":[100,100,100,100,100,100,100,95,100,100]}

00:28:31.150 --> 00:28:32.320
<v Speaker 1>pair of elements.

NOTE CONF {"raw":[100,100,100]}

00:28:32.350 --> 00:28:35.710
<v Speaker 1>The second thing in the list is the, uh, the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,93,100]}

00:28:35.710 --> 00:28:38.200
<v Speaker 1>pair of elements after that and so forth.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:28:38.230 --> 00:28:38.440
<v Speaker 1>Okay.

NOTE CONF {"raw":[98]}

00:28:38.440 --> 00:28:39.850
<v Speaker 1>So you've got a bunch of pair of elements.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:28:39.850 --> 00:28:41.980
<v Speaker 1>It's all the ones from the bottom up to the

NOTE CONF {"raw":[70,100,100,100,100,100,100,100,100,100]}

00:28:41.980 --> 00:28:42.970
<v Speaker 1>top of the zipper.

NOTE CONF {"raw":[100,100,100,100]}

00:28:42.970 --> 00:28:46.690
<v Speaker 1>Or, uh, the lists here are actually going, you know,

NOTE CONF {"raw":[100,81,100,88,100,100,100,100,100,100]}

00:28:46.810 --> 00:28:47.590
<v Speaker 1>uh, wait a minute.

NOTE CONF {"raw":[100,100,100,100]}

00:28:47.590 --> 00:28:50.470
<v Speaker 1>They're going from, uh, from this end to that end.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:28:50.470 --> 00:28:50.800
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:28:50.800 --> 00:28:53.650
<v Speaker 1>So, uh, starting with these two and those two and

NOTE CONF {"raw":[100,100,100,100,100,100,77,100,100,100]}

00:28:53.650 --> 00:28:54.130
<v Speaker 1>so forth.

NOTE CONF {"raw":[100,100]}

00:28:54.130 --> 00:28:54.730
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:28:55.210 --> 00:28:59.830
<v Speaker 1>My my visual aids here, uh, explain everything.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:00.310 --> 00:29:00.910
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:00.910 --> 00:29:03.130
<v Speaker 1>So it's like a zipper but not interleaving.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:29:03.790 --> 00:29:05.080
<v Speaker 1>And here's a definition.

NOTE CONF {"raw":[100,72,92,100]}

00:29:05.080 --> 00:29:07.060
<v Speaker 1>So this is, this is built in in Haskell.

NOTE CONF {"raw":[100,100,100,100,100,100,89,91,100]}

00:29:07.060 --> 00:29:09.070
<v Speaker 1>So you don't have to write it out yourself.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:09.070 --> 00:29:10.780
<v Speaker 1>But this is what it is okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:29:10.780 --> 00:29:16.510
<v Speaker 1>And this is interesting interestingly new because it uses simultaneous

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:16.510 --> 00:29:19.060
<v Speaker 1>recursion on both arguments.

NOTE CONF {"raw":[100,100,100,100]}

00:29:19.060 --> 00:29:24.280
<v Speaker 1>So the two arguments are lists and it's simultaneously, um

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:24.280 --> 00:29:25.840
<v Speaker 1>doing recursion on both lists.

NOTE CONF {"raw":[100,100,100,100,100]}

00:29:25.840 --> 00:29:28.570
<v Speaker 1>So, um, the recursive case.

NOTE CONF {"raw":[100,100,100,100,100]}

00:29:28.570 --> 00:29:29.890
<v Speaker 1>This last one.

NOTE CONF {"raw":[100,100,100]}

00:29:31.360 --> 00:29:34.570
<v Speaker 1>Uh, you need a, you need two lists, which are,

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:29:34.570 --> 00:29:37.600
<v Speaker 1>um, have at least one element in them each.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:29:37.900 --> 00:29:43.540
<v Speaker 1>And the recursive call is to, um, the same function

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:43.540 --> 00:29:47.410
<v Speaker 1>where you've removed the first element of each of these

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:47.410 --> 00:29:48.040
<v Speaker 1>lists.

NOTE CONF {"raw":[100]}

00:29:49.420 --> 00:29:50.110
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:29:50.770 --> 00:29:53.020
<v Speaker 1>So you know zip.

NOTE CONF {"raw":[100,100,100,100]}

00:29:53.440 --> 00:29:57.040
<v Speaker 1>So we've got a list of uh, yeah, a list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:29:57.040 --> 00:29:58.390
<v Speaker 1>of XS and a list of y's.

NOTE CONF {"raw":[100,79,100,100,100,100,65]}

00:29:58.390 --> 00:30:02.920
<v Speaker 1>So it's x cons x and y cons ys.

NOTE CONF {"raw":[100,96,100,100,100,100,100,100,67]}

00:30:03.340 --> 00:30:06.880
<v Speaker 1>And the result is we take the pair x y.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,96,96]}

00:30:06.880 --> 00:30:10.090
<v Speaker 1>So that's the first, you know pair of teeth in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:10.090 --> 00:30:10.660
<v Speaker 1>the list.

NOTE CONF {"raw":[100,100]}

00:30:11.710 --> 00:30:15.550
<v Speaker 1>And cons zipping all the rest of the teeth in

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:15.550 --> 00:30:16.240
<v Speaker 1>the list.

NOTE CONF {"raw":[100,100]}

00:30:18.490 --> 00:30:19.150
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:19.900 --> 00:30:23.990
<v Speaker 1>So it's, uh, it's removed one element from each of

NOTE CONF {"raw":[100,100,96,100,100,100,100,100,100,100]}

00:30:23.990 --> 00:30:26.540
<v Speaker 1>these two lists that are in the that are in

NOTE CONF {"raw":[100,100,100,100,100,100,96,100,100,100]}

00:30:26.540 --> 00:30:27.350
<v Speaker 1>the argument here.

NOTE CONF {"raw":[100,100,100]}

00:30:27.620 --> 00:30:28.010
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:28.010 --> 00:30:29.810
<v Speaker 1>So that's the recursive case.

NOTE CONF {"raw":[100,100,100,100,100]}

00:30:30.830 --> 00:30:33.110
<v Speaker 1>Um, we need two base cases.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:30:33.620 --> 00:30:36.050
<v Speaker 1>Two base cases, not one, but two.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:30:36.080 --> 00:30:40.610
<v Speaker 1>We need two because we've got two arguments and we

NOTE CONF {"raw":[100,100,87,100,100,100,100,100,100,100]}

00:30:40.610 --> 00:30:43.070
<v Speaker 1>don't know which one's going to be empty first.

NOTE CONF {"raw":[100,100,100,85,100,100,100,100,100]}

00:30:43.220 --> 00:30:46.100
<v Speaker 1>So we need to to check both of them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:30:46.790 --> 00:30:47.180
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:30:47.180 --> 00:30:49.850
<v Speaker 1>So the way that this function works is if you've

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,70]}

00:30:49.850 --> 00:30:51.560
<v Speaker 1>got two lists, they don't have to be the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:30:51.560 --> 00:30:51.980
<v Speaker 1>length.

NOTE CONF {"raw":[100]}

00:30:51.980 --> 00:30:54.530
<v Speaker 1>If one of them is shorter than the other one,

NOTE CONF {"raw":[100,100,100,73,73,100,100,100,100,100]}

00:30:54.530 --> 00:30:57.020
<v Speaker 1>then you throw away the extra amount of elements in

NOTE CONF {"raw":[95,100,100,100,100,100,72,72,100,100]}

00:30:57.020 --> 00:30:58.190
<v Speaker 1>the list that's longer.

NOTE CONF {"raw":[100,100,100,100]}

00:30:59.450 --> 00:31:00.110
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:00.200 --> 00:31:04.370
<v Speaker 1>So if, um, if you apply zip to an empty

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:04.370 --> 00:31:06.500
<v Speaker 1>list and y is this is a case where the

NOTE CONF {"raw":[100,100,44,74,100,94,100,100,100,100]}

00:31:06.500 --> 00:31:10.220
<v Speaker 1>the second list is, perhaps it could also be empty,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:10.220 --> 00:31:12.020
<v Speaker 1>but it could be anything.

NOTE CONF {"raw":[100,100,100,100,100]}

00:31:12.020 --> 00:31:16.010
<v Speaker 1>So, um, if you apply zip to a list, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:16.010 --> 00:31:18.920
<v Speaker 1>an empty list and then some other list, the result

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:18.920 --> 00:31:20.810
<v Speaker 1>is the empty list of pairs.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:20.810 --> 00:31:21.140
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:21.140 --> 00:31:22.880
<v Speaker 1>Because you don't have anything to put in it.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:31:24.110 --> 00:31:25.940
<v Speaker 1>You don't have any first elements to put in the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:25.940 --> 00:31:26.570
<v Speaker 1>pairs.

NOTE CONF {"raw":[88]}

00:31:26.570 --> 00:31:31.040
<v Speaker 1>And likewise, if you apply it to, um, any list

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:31:31.040 --> 00:31:34.460
<v Speaker 1>and the empty list, it will likewise produce the empty

NOTE CONF {"raw":[100,100,100,100,75,75,100,98,100,100]}

00:31:34.460 --> 00:31:37.370
<v Speaker 1>list because you haven't gotten any second elements to put

NOTE CONF {"raw":[100,100,100,100,81,100,100,100,100,100]}

00:31:37.370 --> 00:31:38.450
<v Speaker 1>into these pairs.

NOTE CONF {"raw":[100,100,100]}

00:31:44.060 --> 00:31:44.330
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:31:44.330 --> 00:31:46.280
<v Speaker 1>So it's truncating the longer list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:31:47.450 --> 00:31:50.840
<v Speaker 1>And there's two base cases because you're doing simultaneous recursion.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:52.070 --> 00:31:52.850
<v Speaker 1>All right.

NOTE CONF {"raw":[97,97]}

00:31:52.850 --> 00:31:57.770
<v Speaker 1>And um, I explained I think that Haskell takes these

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:31:57.770 --> 00:32:00.080
<v Speaker 1>things in order.

NOTE CONF {"raw":[100,100,100]}

00:32:00.350 --> 00:32:03.500
<v Speaker 1>You know, if you give it to lists, it'll it'll

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:03.500 --> 00:32:06.350
<v Speaker 1>check each of these cases one after the other.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:32:06.530 --> 00:32:07.190
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:32:07.190 --> 00:32:10.820
<v Speaker 1>So if you give it, for example, two empty lists,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:10.820 --> 00:32:13.220
<v Speaker 1>it'll match the first case.

NOTE CONF {"raw":[100,100,100,100,100]}

00:32:13.220 --> 00:32:15.920
<v Speaker 1>And the answer will be the empty list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:32:17.540 --> 00:32:21.080
<v Speaker 1>It happens to also match the second case, but that

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:21.080 --> 00:32:23.040
<v Speaker 1>doesn't matter because we don't get to the second case.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:23.040 --> 00:32:24.930
<v Speaker 1>We just, you know, two empty lists.

NOTE CONF {"raw":[100,100,100,100,100,100,95]}

00:32:24.930 --> 00:32:27.870
<v Speaker 1>It's the first case, but a non-empty list and an

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:32:27.870 --> 00:32:28.710
<v Speaker 1>empty list.

NOTE CONF {"raw":[100,100]}

00:32:28.830 --> 00:32:31.860
<v Speaker 1>It'll also produce the empty list as the result.

NOTE CONF {"raw":[95,100,100,100,100,100,48,100,100]}

00:32:33.420 --> 00:32:34.170
<v Speaker 1>All right.

NOTE CONF {"raw":[90,90]}

00:32:35.700 --> 00:32:36.060
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:32:40.020 --> 00:32:40.320
<v Speaker 1>All right.

NOTE CONF {"raw":[22,58]}

00:32:45.090 --> 00:32:48.930
<v Speaker 1>Um, so I said that, um, if you've got two

NOTE CONF {"raw":[99,100,100,100,100,100,100,100,100,100]}

00:32:48.930 --> 00:32:52.860
<v Speaker 1>lists of different lengths, it'll, it'll truncate the longer lists.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,69]}

00:32:52.860 --> 00:32:54.570
<v Speaker 1>So that was this definition.

NOTE CONF {"raw":[100,100,100,100,100]}

00:32:54.570 --> 00:32:59.730
<v Speaker 1>You could have written a definition that is uh, is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,99]}

00:32:59.730 --> 00:33:04.200
<v Speaker 1>uh, is strict and, and I wrote here uptight.

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100]}

00:33:04.200 --> 00:33:07.440
<v Speaker 1>So it requires the list to be the same length.

NOTE CONF {"raw":[100,100,100,100,54,100,100,100,100,100]}

00:33:07.440 --> 00:33:10.410
<v Speaker 1>And if they aren't the same length, it will, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:10.410 --> 00:33:11.700
<v Speaker 1>it will complain.

NOTE CONF {"raw":[100,100,100]}

00:33:11.820 --> 00:33:12.180
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:33:12.180 --> 00:33:14.460
<v Speaker 1>And this is, this is this is this definition.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:33:14.460 --> 00:33:15.330
<v Speaker 1>I'm calling this a zip.

NOTE CONF {"raw":[100,100,100,100,100]}

00:33:15.330 --> 00:33:16.080
<v Speaker 1>Harsh.

NOTE CONF {"raw":[98]}

00:33:16.440 --> 00:33:21.900
<v Speaker 1>So the the the the recursive cases exactly the same.

NOTE CONF {"raw":[100,100,100,100,100,100,98,100,100,100]}

00:33:22.740 --> 00:33:25.260
<v Speaker 1>Okay, but the base case is only one base case,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:25.260 --> 00:33:29.070
<v Speaker 1>and it's insisting that they're both going to be, um,

NOTE CONF {"raw":[100,97,100,100,100,100,100,100,100,47]}

00:33:29.070 --> 00:33:31.050
<v Speaker 1>becoming empty at the same time.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:33:31.890 --> 00:33:36.000
<v Speaker 1>Okay, so there is no case for zip harsh applied

NOTE CONF {"raw":[100,100,100,100,100,100,100,97,100,100]}

00:33:36.000 --> 00:33:38.310
<v Speaker 1>to the empty list and a non-empty list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:33:41.280 --> 00:33:42.990
<v Speaker 1>So you can write that if you want and it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:33:42.990 --> 00:33:44.340
<v Speaker 1>gives different results.

NOTE CONF {"raw":[100,100,100]}

00:33:44.430 --> 00:33:49.020
<v Speaker 1>So um, just as an example, here's, you know, here's

NOTE CONF {"raw":[100,63,100,100,100,100,100,100,100,100]}

00:33:49.020 --> 00:33:52.230
<v Speaker 1>zip applied to the list, um, 012.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:33:52.230 --> 00:33:55.170
<v Speaker 1>And the list, um, the list of characters ABC, you

NOTE CONF {"raw":[100,100,100,94,100,100,100,100,92,100]}

00:33:55.170 --> 00:33:59.280
<v Speaker 1>get, you know, zero one 1 or 0 A, one

NOTE CONF {"raw":[100,100,100,100,100,97,97,97,100,100]}

00:33:59.280 --> 00:34:00.450
<v Speaker 1>B and two C.

NOTE CONF {"raw":[100,100,100,100]}

00:34:00.450 --> 00:34:02.850
<v Speaker 1>So this is in each case an element from the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:02.850 --> 00:34:07.050
<v Speaker 1>first list 012 and an element from the second list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:07.050 --> 00:34:08.460
<v Speaker 1>a b c.

NOTE CONF {"raw":[100,100,100]}

00:34:09.960 --> 00:34:10.860
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:34:11.550 --> 00:34:13.950
<v Speaker 1>Um, zip harsh would do the same thing because they're

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:13.950 --> 00:34:15.179
<v Speaker 1>both the same length.

NOTE CONF {"raw":[100,100,100,100]}

00:34:15.330 --> 00:34:17.760
<v Speaker 1>But let's try it for lists of different lengths.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,76]}

00:34:17.760 --> 00:34:20.649
<v Speaker 1>So here's zero, one, two and a, b, c, d,

NOTE CONF {"raw":[100,100,100,100,100,100,94,94,94,94]}

00:34:20.649 --> 00:34:23.200
<v Speaker 1>e, so d and e are superfluous.

NOTE CONF {"raw":[73,100,100,100,100,100,100]}

00:34:23.230 --> 00:34:28.330
<v Speaker 1>It will produce um this list um list of pairs

NOTE CONF {"raw":[100,100,100,99,100,100,100,100,100,99]}

00:34:28.659 --> 00:34:30.310
<v Speaker 1>zero A, one, b and two.

NOTE CONF {"raw":[100,89,89,100,100,94]}

00:34:30.340 --> 00:34:32.260
<v Speaker 1>See if you try zip.

NOTE CONF {"raw":[100,100,100,100,100]}

00:34:32.260 --> 00:34:32.889
<v Speaker 1>Harsh.

NOTE CONF {"raw":[97]}

00:34:33.850 --> 00:34:34.750
<v Speaker 1>It will read.

NOTE CONF {"raw":[100,100,77]}

00:34:34.840 --> 00:34:39.190
<v Speaker 1>It will raise this exception which is saying I don't

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:39.190 --> 00:34:43.179
<v Speaker 1>have a case to handle the values you've given me.

NOTE CONF {"raw":[100,100,100,100,100,100,100,93,100,100]}

00:34:43.179 --> 00:34:43.450
<v Speaker 1>Okay?

NOTE CONF {"raw":[98]}

00:34:43.450 --> 00:34:46.870
<v Speaker 1>Because at this point, at this point it will apply.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:34:46.870 --> 00:34:49.870
<v Speaker 1>This is the computation with the recursive call.

NOTE CONF {"raw":[100,100,100,100,100,63,100,100]}

00:34:49.870 --> 00:34:52.810
<v Speaker 1>Just at the point when this exception is raised where

NOTE CONF {"raw":[100,100,100,100,95,100,100,100,100,100]}

00:34:52.810 --> 00:34:57.340
<v Speaker 1>the arguments are empty list and a list containing d

NOTE CONF {"raw":[100,100,100,100,100,100,85,100,100,93]}

00:34:58.420 --> 00:35:01.510
<v Speaker 1>okay for which there is no case.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:02.140 --> 00:35:03.280
<v Speaker 1>Okay, this is two empty list.

NOTE CONF {"raw":[100,100,100,94,100,100]}

00:35:03.280 --> 00:35:03.820
<v Speaker 1>This is.

NOTE CONF {"raw":[100,100]}

00:35:03.820 --> 00:35:05.920
<v Speaker 1>This is two lists with at least one element.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:35:06.220 --> 00:35:06.640
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:35:06.640 --> 00:35:09.940
<v Speaker 1>Interestingly it generates the exception after doing this amount of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:09.940 --> 00:35:10.720
<v Speaker 1>computation.

NOTE CONF {"raw":[100]}

00:35:10.720 --> 00:35:13.900
<v Speaker 1>This is actually lazy evaluation happening okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:35:13.900 --> 00:35:14.920
<v Speaker 1>Because it does.

NOTE CONF {"raw":[100,100,100]}

00:35:14.920 --> 00:35:19.450
<v Speaker 1>It does the printing the printing Um, does the evaluation

NOTE CONF {"raw":[100,100,100,100,100,100,94,100,100,100]}

00:35:19.450 --> 00:35:20.770
<v Speaker 1>and then prints the result.

NOTE CONF {"raw":[100,100,100,100,100]}

00:35:20.770 --> 00:35:23.950
<v Speaker 1>And when it's, when it's printing a list, it prints

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:23.950 --> 00:35:26.890
<v Speaker 1>the, the things one at a time, doing just enough

NOTE CONF {"raw":[78,100,99,100,100,100,100,100,100,100]}

00:35:26.890 --> 00:35:28.600
<v Speaker 1>computation to get the next element.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:28.600 --> 00:35:31.000
<v Speaker 1>And at this point, so it prints the first three

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:31.000 --> 00:35:33.250
<v Speaker 1>things and then it realises at this point there is

NOTE CONF {"raw":[100,100,100,100,97,100,100,100,100,100]}

00:35:33.250 --> 00:35:34.330
<v Speaker 1>no fourth thing.

NOTE CONF {"raw":[100,100,100]}

00:35:34.840 --> 00:35:36.310
<v Speaker 1>Um, there's an exception.

NOTE CONF {"raw":[100,100,100,100]}

00:35:37.930 --> 00:35:38.560
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:35:38.560 --> 00:35:39.910
<v Speaker 1>And here's the thing.

NOTE CONF {"raw":[100,100,100,100]}

00:35:39.910 --> 00:35:41.920
<v Speaker 1>Here's just showing that it would do it the same

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:35:41.920 --> 00:35:43.870
<v Speaker 1>way if it was the first.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:43.870 --> 00:35:47.950
<v Speaker 1>The first list was um, was on um, longer.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:35:49.420 --> 00:35:50.020
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:35:50.020 --> 00:35:51.280
<v Speaker 1>So this is zip.

NOTE CONF {"raw":[100,100,100,100]}

00:35:51.640 --> 00:35:53.620
<v Speaker 1>Um, so zip is used, um.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:35:57.070 --> 00:35:58.510
<v Speaker 1>For various things.

NOTE CONF {"raw":[100,100,100]}

00:35:58.810 --> 00:35:59.320
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:35:59.320 --> 00:36:01.660
<v Speaker 1>Here are a couple of examples of how you might

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:01.660 --> 00:36:02.590
<v Speaker 1>use zip.

NOTE CONF {"raw":[100,100]}

00:36:03.970 --> 00:36:09.040
<v Speaker 1>Um, uh, if we zip, uh, the list of numbers

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:09.040 --> 00:36:13.030
<v Speaker 1>starting from zero going on forever with a string.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:36:13.030 --> 00:36:17.480
<v Speaker 1>The result is a list of pairs Only as long

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:17.480 --> 00:36:18.500
<v Speaker 1>as the string.

NOTE CONF {"raw":[100,100,100]}

00:36:19.340 --> 00:36:21.860
<v Speaker 1>And it's kind of the, the, the characters in the

NOTE CONF {"raw":[100,58,100,100,97,95,100,100,58,100]}

00:36:21.860 --> 00:36:22.430
<v Speaker 1>string.

NOTE CONF {"raw":[100]}

00:36:22.430 --> 00:36:26.690
<v Speaker 1>So in this case Ward together with the positions that

NOTE CONF {"raw":[100,100,100,100,41,100,100,100,100,100]}

00:36:26.690 --> 00:36:29.540
<v Speaker 1>they are in the string zero, one, two, three.

NOTE CONF {"raw":[100,100,100,91,100,100,100,100,100]}

00:36:30.920 --> 00:36:31.340
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:36:31.340 --> 00:36:34.250
<v Speaker 1>So, um, you know, zero w because w is in

NOTE CONF {"raw":[100,58,100,100,100,100,100,100,100,100]}

00:36:34.250 --> 00:36:38.180
<v Speaker 1>position zero, we start counting from zero in computer science

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:38.180 --> 00:36:38.780
<v Speaker 1>often.

NOTE CONF {"raw":[100]}

00:36:38.780 --> 00:36:39.230
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:36:39.230 --> 00:36:42.860
<v Speaker 1>One paired with paired with O because O is in

NOTE CONF {"raw":[100,100,100,100,100,94,100,85,100,100]}

00:36:42.860 --> 00:36:46.490
<v Speaker 1>position one, two paired with R and three paired with

NOTE CONF {"raw":[100,100,56,100,100,84,100,100,100,100]}

00:36:46.490 --> 00:36:46.790
<v Speaker 1>D.

NOTE CONF {"raw":[100]}

00:36:46.790 --> 00:36:48.800
<v Speaker 1>And whatever the string is it would be the same.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:48.800 --> 00:36:49.070
<v Speaker 1>Right?

NOTE CONF {"raw":[100]}

00:36:49.070 --> 00:36:52.700
<v Speaker 1>So position of character followed by the character.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:36:53.270 --> 00:36:59.330
<v Speaker 1>Um, this is the way that that zip deals with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:36:59.330 --> 00:37:02.810
<v Speaker 1>um lists of different lengths is convenient here because this

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:02.810 --> 00:37:05.240
<v Speaker 1>list, this first list is always going to be longer

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:05.240 --> 00:37:08.120
<v Speaker 1>than the second list, okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:08.120 --> 00:37:10.760
<v Speaker 1>And it just stops when it when it's used up

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:10.760 --> 00:37:11.720
<v Speaker 1>enough numbers.

NOTE CONF {"raw":[100,100]}

00:37:12.830 --> 00:37:13.520
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:37:13.520 --> 00:37:16.490
<v Speaker 1>You don't have to you don't have to compute.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:37:17.270 --> 00:37:19.970
<v Speaker 1>In this case it would be length of second argument

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:19.970 --> 00:37:24.110
<v Speaker 1>minus one is the is the is the upper bound

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:24.110 --> 00:37:24.260
<v Speaker 1>there?

NOTE CONF {"raw":[96]}

00:37:24.260 --> 00:37:27.080
<v Speaker 1>You don't have to bother computing that because lazy evaluation

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:27.080 --> 00:37:28.550
<v Speaker 1>figures it out for you.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:31.610 --> 00:37:32.450
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:37:32.720 --> 00:37:34.310
<v Speaker 1>Um you got that.

NOTE CONF {"raw":[100,100,100,100]}

00:37:34.430 --> 00:37:35.570
<v Speaker 1>So that might be useful.

NOTE CONF {"raw":[100,100,100,100,100]}

00:37:35.570 --> 00:37:38.840
<v Speaker 1>Suppose you want to search for a character in a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,81]}

00:37:38.840 --> 00:37:40.820
<v Speaker 1>list, and you want to know which position the first

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:40.820 --> 00:37:41.840
<v Speaker 1>occurrence is in.

NOTE CONF {"raw":[100,100,100]}

00:37:44.180 --> 00:37:47.180
<v Speaker 1>So you could do a zip like this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:37:47.180 --> 00:37:50.570
<v Speaker 1>And then look for the occurrence of the character and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:37:50.570 --> 00:37:55.820
<v Speaker 1>return the position that is paired with, let's say, okay,

NOTE CONF {"raw":[100,100,100,100,92,100,100,100,100,100]}

00:37:56.390 --> 00:38:00.110
<v Speaker 1>um, let's look at the second example.

NOTE CONF {"raw":[100,100,100,100,89,100,100]}

00:38:00.110 --> 00:38:01.970
<v Speaker 1>So here's a list.

NOTE CONF {"raw":[100,100,100,100]}

00:38:02.300 --> 00:38:05.510
<v Speaker 1>Uh, it takes it's a function, it takes a list

NOTE CONF {"raw":[95,100,100,92,100,100,100,100,100,100]}

00:38:05.510 --> 00:38:07.850
<v Speaker 1>and it produces a list of pairs.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:38:08.540 --> 00:38:12.410
<v Speaker 1>Um, so whatever the, the the type is there, it

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:12.410 --> 00:38:14.330
<v Speaker 1>produces pairs of that type.

NOTE CONF {"raw":[100,100,100,100,100]}

00:38:14.360 --> 00:38:17.540
<v Speaker 1>And what it does is it zips the argument together

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:17.540 --> 00:38:19.100
<v Speaker 1>with the tail of the argument.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:38:20.660 --> 00:38:25.400
<v Speaker 1>And so, for example, uh, uh, if you give it

NOTE CONF {"raw":[100,100,100,100,75,86,100,100,100,100]}

00:38:25.400 --> 00:38:29.810
<v Speaker 1>the string word, so what it gives you is, is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:29.810 --> 00:38:34.490
<v Speaker 1>is pairs of adjacent characters w o r r d

NOTE CONF {"raw":[100,100,100,100,100,54,54,30,54,54]}

00:38:35.810 --> 00:38:36.260
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:38:36.260 --> 00:38:39.170
<v Speaker 1>And however long the list of characters is, or whatever

NOTE CONF {"raw":[100,100,98,100,100,100,100,100,100,100]}

00:38:39.170 --> 00:38:41.840
<v Speaker 1>the list is, it'll always produce the list of all

NOTE CONF {"raw":[100,100,100,57,100,100,100,100,100,100]}

00:38:41.840 --> 00:38:43.250
<v Speaker 1>of the adjacent pairs.

NOTE CONF {"raw":[100,100,100,100]}

00:38:44.810 --> 00:38:48.770
<v Speaker 1>Okay, um, so why might that be useful?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:38:50.150 --> 00:38:53.060
<v Speaker 1>Uh, if you've got something you want to do with

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:38:53.060 --> 00:38:56.120
<v Speaker 1>successive elements of a list, this is a way to

NOTE CONF {"raw":[100,100,100,92,100,100,100,100,100,100]}

00:38:56.120 --> 00:38:59.840
<v Speaker 1>produce the pairs of successive elements of the list.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:39:00.470 --> 00:39:01.250
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:01.250 --> 00:39:02.870
<v Speaker 1>Whatever is you want to do with them.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:39:03.380 --> 00:39:03.950
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:39:03.950 --> 00:39:07.520
<v Speaker 1>An example is, uh, counting the number of doubled letters

NOTE CONF {"raw":[100,100,100,82,100,100,100,100,95,100]}

00:39:07.520 --> 00:39:08.360
<v Speaker 1>in a string.

NOTE CONF {"raw":[100,100,100]}

00:39:13.230 --> 00:39:13.680
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:39:15.750 --> 00:39:16.560
<v Speaker 1>Just a second.

NOTE CONF {"raw":[100,100,100]}

00:39:21.660 --> 00:39:22.440
<v Speaker 1>Okay, here's.

NOTE CONF {"raw":[100,100]}

00:39:22.440 --> 00:39:23.130
<v Speaker 1>Wait a minute.

NOTE CONF {"raw":[100,100,100]}

00:39:23.700 --> 00:39:25.980
<v Speaker 1>Um, laptop.

NOTE CONF {"raw":[100,98]}

00:39:30.180 --> 00:39:33.060
<v Speaker 1>So here's the, uh, the list of prime numbers.

NOTE CONF {"raw":[100,100,100,58,100,100,100,100,100]}

00:39:33.060 --> 00:39:34.110
<v Speaker 1>I've got up to 100,000.

NOTE CONF {"raw":[100,100,100,100,100]}

00:39:34.110 --> 00:39:35.460
<v Speaker 1>I'm going to stop it now.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:39:35.580 --> 00:39:36.990
<v Speaker 1>Uh, you can see, by the way, it's going a

NOTE CONF {"raw":[58,100,100,100,100,100,100,100,100,100]}

00:39:36.990 --> 00:39:37.770
<v Speaker 1>little bit more slowly.

NOTE CONF {"raw":[100,100,100,100]}

00:39:37.770 --> 00:39:39.900
<v Speaker 1>And the reason it's going more slowly is that every

NOTE CONF {"raw":[98,100,100,100,100,100,100,100,100,100]}

00:39:39.900 --> 00:39:43.740
<v Speaker 1>prime number, it has to check all the numbers from

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:39:43.740 --> 00:39:46.710
<v Speaker 1>to up to that number minus one, to see if

NOTE CONF {"raw":[52,100,100,100,100,100,100,100,100,100]}

00:39:46.710 --> 00:39:48.510
<v Speaker 1>they divide that number.

NOTE CONF {"raw":[100,100,100,100]}

00:39:48.510 --> 00:39:49.170
<v Speaker 1>Okay.

NOTE CONF {"raw":[81]}

00:39:50.370 --> 00:39:54.060
<v Speaker 1>So let me do a little bit of live coding.

NOTE CONF {"raw":[100,100,100,100,100,95,100,100,100,100]}

00:39:56.190 --> 00:39:56.880
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:39:59.190 --> 00:40:02.430
<v Speaker 1>I just said you might want to produce a, um.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:04.710 --> 00:40:07.440
<v Speaker 1>A function that counts the number of number of doubled

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:07.440 --> 00:40:09.570
<v Speaker 1>letters in a, in a, um.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:11.940 --> 00:40:12.870
<v Speaker 1>In a string.

NOTE CONF {"raw":[100,100,91]}

00:40:12.990 --> 00:40:14.400
<v Speaker 1>Okay, so let's do that.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:15.240 --> 00:40:15.960
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:40:16.800 --> 00:40:17.160
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:40:23.610 --> 00:40:28.170
<v Speaker 1>Okay, so first of all, uh, what I want is

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:28.170 --> 00:40:29.820
<v Speaker 1>a function called num doubles.

NOTE CONF {"raw":[100,100,100,100,100]}

00:40:32.460 --> 00:40:32.940
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:40:35.640 --> 00:40:36.960
<v Speaker 1>Just looking at my notes.

NOTE CONF {"raw":[98,100,100,100,100]}

00:40:39.240 --> 00:40:40.860
<v Speaker 1>I could do it using zip.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:40:40.890 --> 00:40:42.990
<v Speaker 1>I'm going to do it without using zip.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:44.070 --> 00:40:48.660
<v Speaker 1>Um, okay, but but just to show you, uh, um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:40:50.310 --> 00:40:50.640
<v Speaker 1>okay.

NOTE CONF {"raw":[100]}

00:40:50.640 --> 00:40:51.900
<v Speaker 1>An example is.

NOTE CONF {"raw":[100,100,100]}

00:40:54.570 --> 00:40:56.610
<v Speaker 1>Well, let me just let me just code.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:40:56.790 --> 00:40:57.480
<v Speaker 1>Okay.

NOTE CONF {"raw":[93]}

00:40:58.830 --> 00:41:02.460
<v Speaker 1>Um, I'm going to I'm going to apply this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:41:02.460 --> 00:41:04.950
<v Speaker 1>When I'm done, I'm going to apply it to my

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:04.950 --> 00:41:08.880
<v Speaker 1>surname, uh, Sanela, which happens to have two double letters

NOTE CONF {"raw":[100,84,89,100,100,100,100,100,99,100]}

00:41:08.880 --> 00:41:09.420
<v Speaker 1>in it.

NOTE CONF {"raw":[100,100]}

00:41:11.080 --> 00:41:11.830
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:12.130 --> 00:41:14.140
<v Speaker 1>Um, so let's see, how will this work?

NOTE CONF {"raw":[81,100,100,100,100,83,100,100]}

00:41:17.200 --> 00:41:18.400
<v Speaker 1>Um, so num doubles.

NOTE CONF {"raw":[100,100,100,94]}

00:41:18.400 --> 00:41:22.120
<v Speaker 1>So we want a function that takes a string and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:22.120 --> 00:41:23.620
<v Speaker 1>produces an integer.

NOTE CONF {"raw":[100,100,100]}

00:41:24.100 --> 00:41:26.140
<v Speaker 1>So I'm doing this in order to show you how

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:26.140 --> 00:41:27.760
<v Speaker 1>to write recursive functions.

NOTE CONF {"raw":[100,100,100,100]}

00:41:28.300 --> 00:41:28.990
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:34.240 --> 00:41:40.030
<v Speaker 1>Um, so a typical pattern of a recursive function would

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:41:40.030 --> 00:41:42.700
<v Speaker 1>be, uh, on, on a, on a list.

NOTE CONF {"raw":[100,82,100,100,100,100,100,100]}

00:41:42.700 --> 00:41:43.000
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:41:43.000 --> 00:41:44.650
<v Speaker 1>String is a list of characters.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:41:55.210 --> 00:41:55.630
<v Speaker 1>Uh.

NOTE CONF {"raw":[100]}

00:42:05.200 --> 00:42:07.450
<v Speaker 1>I just realised I'm doing this the wrong way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:42:08.050 --> 00:42:08.380
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:42:13.330 --> 00:42:15.580
<v Speaker 1>Okay, let me do it the right way.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:42:16.000 --> 00:42:16.810
<v Speaker 1>I am.

NOTE CONF {"raw":[100,100]}

00:42:16.960 --> 00:42:19.870
<v Speaker 1>I am indeed going to use, um, the zip trick

NOTE CONF {"raw":[100,100,100,100,100,100,58,100,99,100]}

00:42:19.870 --> 00:42:20.560
<v Speaker 1>that I mentioned.

NOTE CONF {"raw":[100,100,100]}

00:42:20.560 --> 00:42:23.470
<v Speaker 1>Okay, so you give it a string and it's going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:23.470 --> 00:42:30.820
<v Speaker 1>to count, uh, count the number of doubles in zip

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:30.820 --> 00:42:33.340
<v Speaker 1>apply to S and tail of S.

NOTE CONF {"raw":[88,100,100,100,98,100,100]}

00:42:33.550 --> 00:42:36.460
<v Speaker 1>So as I said a minute ago.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:42:40.750 --> 00:42:45.340
<v Speaker 1>This is a handy trick for, uh, for producing pairs

NOTE CONF {"raw":[100,100,100,100,100,100,86,100,100,100]}

00:42:45.340 --> 00:42:46.570
<v Speaker 1>of adjacent letters.

NOTE CONF {"raw":[100,100,100]}

00:42:47.020 --> 00:42:48.970
<v Speaker 1>Okay, so I get a list of pairs of adjacent

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:42:49.120 --> 00:42:50.110
<v Speaker 1>letters here.

NOTE CONF {"raw":[100,100]}

00:42:50.890 --> 00:42:51.250
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:42:54.190 --> 00:42:57.610
<v Speaker 1>Okay, so that's what.

NOTE CONF {"raw":[100,100,100,100]}

00:42:57.610 --> 00:42:58.930
<v Speaker 1>That's what this does.

NOTE CONF {"raw":[100,100,100,100]}

00:42:59.350 --> 00:42:59.890
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:42:59.890 --> 00:43:04.360
<v Speaker 1>ZIP s tail of S computes the number of, uh,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:04.990 --> 00:43:08.290
<v Speaker 1>it computes the list of, uh, of pairs of adjacent

NOTE CONF {"raw":[100,100,73,100,100,93,100,100,100,100]}

00:43:08.300 --> 00:43:08.960
<v Speaker 1>letters.

NOTE CONF {"raw":[100]}

00:43:09.650 --> 00:43:10.100
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:10.100 --> 00:43:12.230
<v Speaker 1>And what I want to do now is I want

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:12.230 --> 00:43:17.120
<v Speaker 1>to count, uh, the ones in that list that are

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:43:17.120 --> 00:43:17.720
<v Speaker 1>doubled.

NOTE CONF {"raw":[83]}

00:43:20.570 --> 00:43:22.160
<v Speaker 1>So I give it a list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:23.180 --> 00:43:25.190
<v Speaker 1>Sorry that I was a little confused there.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:43:25.220 --> 00:43:29.180
<v Speaker 1>Um, I gave it a list of, um, of pairs

NOTE CONF {"raw":[100,100,93,100,100,100,100,100,100,100]}

00:43:29.180 --> 00:43:30.770
<v Speaker 1>of characters.

NOTE CONF {"raw":[100,100]}

00:43:34.820 --> 00:43:36.380
<v Speaker 1>And I produce an integer.

NOTE CONF {"raw":[100,100,86,100,100]}

00:43:37.280 --> 00:43:37.700
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:43:37.700 --> 00:43:40.640
<v Speaker 1>The number of times that I've got doubled characters.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:43:40.640 --> 00:43:43.160
<v Speaker 1>So as I was, I was beginning to say.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:43:43.160 --> 00:43:44.780
<v Speaker 1>And then got got messed up.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:45.080 --> 00:43:47.540
<v Speaker 1>Uh, typical example of a of a.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:43:47.960 --> 00:43:48.290
<v Speaker 1>Yeah.

NOTE CONF {"raw":[57]}

00:43:49.070 --> 00:43:54.200
<v Speaker 1>Typical, um, pattern of a recursive definition would be um,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,92]}

00:43:54.200 --> 00:43:56.840
<v Speaker 1>on lists would be like this.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:43:58.790 --> 00:44:02.810
<v Speaker 1>This is a, this is a definition on a list

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:02.810 --> 00:44:05.390
<v Speaker 1>of, um, lists of pairs.

NOTE CONF {"raw":[100,100,100,100,100]}

00:44:06.680 --> 00:44:07.070
<v Speaker 0>Um.

NOTE CONF {"raw":[100]}

00:44:10.460 --> 00:44:10.850
<v Speaker 0>Uh.

NOTE CONF {"raw":[100]}

00:44:13.310 --> 00:44:13.700
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:44:15.140 --> 00:44:15.530
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:44:23.180 --> 00:44:23.660
<v Speaker 0>Okay.

NOTE CONF {"raw":[100]}

00:44:23.660 --> 00:44:27.440
<v Speaker 1>So, um, so typically you'd have two cases.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:44:28.220 --> 00:44:30.020
<v Speaker 1>The first is the empty list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:44:30.260 --> 00:44:32.720
<v Speaker 1>The second is the non-empty list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:44:32.720 --> 00:44:35.240
<v Speaker 1>And this is a this is a list of of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:35.240 --> 00:44:36.500
<v Speaker 1>pairs of characters.

NOTE CONF {"raw":[100,100,100]}

00:44:36.500 --> 00:44:39.170
<v Speaker 1>And so the first thing in the list is going

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:39.170 --> 00:44:40.070
<v Speaker 1>to be a pair.

NOTE CONF {"raw":[100,100,100,100]}

00:44:40.550 --> 00:44:42.350
<v Speaker 1>I'll say a comma b.

NOTE CONF {"raw":[100,100,100,100,100]}

00:44:42.470 --> 00:44:43.880
<v Speaker 1>And here's the rest of the list.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:44:43.910 --> 00:44:44.660
<v Speaker 1>ABS.

NOTE CONF {"raw":[100]}

00:44:45.290 --> 00:44:46.370
<v Speaker 1>So abs.

NOTE CONF {"raw":[100,99]}

00:44:47.810 --> 00:44:48.290
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:44:48.290 --> 00:44:50.900
<v Speaker 1>And there's going to be a recursive call probably of

NOTE CONF {"raw":[100,100,100,100,100,84,100,100,100,100]}

00:44:50.900 --> 00:44:51.680
<v Speaker 1>this form.

NOTE CONF {"raw":[100,100]}

00:44:52.430 --> 00:44:52.850
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:44:52.850 --> 00:44:55.100
<v Speaker 1>So this is not always the case but it's a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:44:55.100 --> 00:44:56.960
<v Speaker 1>common a common pattern.

NOTE CONF {"raw":[100,98,100,100]}

00:44:57.830 --> 00:44:58.280
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:44:58.280 --> 00:45:01.100
<v Speaker 1>And now writing the definition is a matter of filling

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:01.100 --> 00:45:02.240
<v Speaker 1>in the blanks here.

NOTE CONF {"raw":[100,100,100,100]}

00:45:04.340 --> 00:45:04.730
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:45:04.730 --> 00:45:05.550
<v Speaker 1>So Are.

NOTE CONF {"raw":[100,34]}

00:45:05.550 --> 00:45:08.850
<v Speaker 1>Anybody know how many doubled characters there is?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:08.850 --> 00:45:11.340
<v Speaker 1>There are in the empty list of doubled.

NOTE CONF {"raw":[100,100,100,100,100,100,100,97]}

00:45:11.370 --> 00:45:14.070
<v Speaker 1>Of of of of pairs of characters.

NOTE CONF {"raw":[99,100,100,100,100,100,100]}

00:45:16.410 --> 00:45:16.740
<v Speaker 1>Yeah.

NOTE CONF {"raw":[100]}

00:45:16.740 --> 00:45:17.400
<v Speaker 1>Anybody?

NOTE CONF {"raw":[100]}

00:45:18.150 --> 00:45:19.020
<v Speaker 1>Zero.

NOTE CONF {"raw":[100]}

00:45:19.050 --> 00:45:19.470
<v Speaker 1>Hooray!

NOTE CONF {"raw":[98]}

00:45:19.470 --> 00:45:19.800
<v Speaker 1>Yes!

NOTE CONF {"raw":[100]}

00:45:19.800 --> 00:45:20.490
<v Speaker 1>Very good.

NOTE CONF {"raw":[100,100]}

00:45:20.940 --> 00:45:24.000
<v Speaker 1>Um, there's there's none because there aren't any pairs.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:45:24.720 --> 00:45:28.950
<v Speaker 1>Okay, what about the case where we've got at least

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:28.950 --> 00:45:29.280
<v Speaker 1>one.

NOTE CONF {"raw":[100]}

00:45:29.280 --> 00:45:32.280
<v Speaker 1>We've got, we've got a pair, A comma B how

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:45:32.280 --> 00:45:35.820
<v Speaker 1>many doubled characters are there in that list?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:35.820 --> 00:45:36.630
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:45:38.520 --> 00:45:42.510
<v Speaker 1>One uh, you know, one is, uh, uh, I mean,

NOTE CONF {"raw":[100,95,86,86,100,100,100,97,100,100]}

00:45:42.510 --> 00:45:43.470
<v Speaker 1>there could be one.

NOTE CONF {"raw":[95,100,100,100]}

00:45:43.920 --> 00:45:45.900
<v Speaker 1>There could be one, there could be zero.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:45:46.050 --> 00:45:46.860
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:45:48.180 --> 00:45:48.900
<v Speaker 1>It depends.

NOTE CONF {"raw":[100,100]}

00:45:48.900 --> 00:45:51.210
<v Speaker 1>It depends on A and B, right.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:45:53.010 --> 00:45:53.280
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:45:53.280 --> 00:45:54.870
<v Speaker 1>So we need a case analysis.

NOTE CONF {"raw":[100,100,100,91,100,100]}

00:45:56.670 --> 00:45:59.100
<v Speaker 1>We're going to have two cases uh whether A is

NOTE CONF {"raw":[100,87,87,100,100,100,65,100,100,100]}

00:45:59.100 --> 00:46:00.240
<v Speaker 1>equal to B or not.

NOTE CONF {"raw":[100,100,100,100,100]}

00:46:07.710 --> 00:46:08.070
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:08.310 --> 00:46:12.930
<v Speaker 1>If A is equal to B, then we produce something,

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:12.930 --> 00:46:14.520
<v Speaker 1>and if A is not equal to B then we

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:14.520 --> 00:46:16.620
<v Speaker 1>produce something maybe different.

NOTE CONF {"raw":[100,100,92,97]}

00:46:17.280 --> 00:46:17.970
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:20.190 --> 00:46:20.580
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:20.580 --> 00:46:24.090
<v Speaker 1>And here we've got the um the recursive call.

NOTE CONF {"raw":[100,100,100,100,100,81,100,100,100]}

00:46:26.160 --> 00:46:29.430
<v Speaker 1>Perhaps in both perhaps in both cases perhaps not.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:46:30.600 --> 00:46:31.050
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:31.050 --> 00:46:32.580
<v Speaker 1>But we'll put it there for now.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:32.700 --> 00:46:33.420
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:33.600 --> 00:46:36.210
<v Speaker 1>Um, a way to if you, if you sort of

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:36.210 --> 00:46:37.860
<v Speaker 1>looking at this and you're getting stuck.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:46:38.040 --> 00:46:38.790
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:46:39.090 --> 00:46:42.000
<v Speaker 1>Um, one thing to do is to look at examples.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:42.360 --> 00:46:45.330
<v Speaker 1>I'm just going to type them down here to, um.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:46.230 --> 00:46:46.770
<v Speaker 1>Whoops.

NOTE CONF {"raw":[98]}

00:46:47.790 --> 00:46:52.500
<v Speaker 1>Um, uh, to record to record some examples.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:46:52.500 --> 00:46:57.360
<v Speaker 1>So suppose it's like, um, uh, I don't know, a

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:46:57.360 --> 00:46:59.400
<v Speaker 1>and uh, a.

NOTE CONF {"raw":[100,97,100]}

00:47:01.560 --> 00:47:04.410
<v Speaker 1>Cons, let's say the empty list.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:05.700 --> 00:47:06.360
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:47:07.980 --> 00:47:10.230
<v Speaker 1>So that's a case where A is equal to B.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:10.230 --> 00:47:12.030
<v Speaker 1>That is to say the I should maybe should use

NOTE CONF {"raw":[100,100,100,100,100,100,67,100,100,100]}

00:47:12.030 --> 00:47:14.100
<v Speaker 1>different very different names here.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:14.100 --> 00:47:16.560
<v Speaker 1>Um f and f okay.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:16.560 --> 00:47:20.610
<v Speaker 1>That's the case where we've got a list like this.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:20.610 --> 00:47:23.400
<v Speaker 1>Characters A and B are F and f.

NOTE CONF {"raw":[100,100,100,100,80,100,100,100]}

00:47:23.760 --> 00:47:24.990
<v Speaker 1>They're the same.

NOTE CONF {"raw":[90,100,100]}

00:47:24.990 --> 00:47:26.910
<v Speaker 1>And so we're in the first case here.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:47:26.910 --> 00:47:29.100
<v Speaker 1>What do we want to produce okay.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:47:29.100 --> 00:47:35.220
<v Speaker 1>Well we want to produce something uh uh, building on

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:35.220 --> 00:47:39.930
<v Speaker 1>top of the result of count doubles applied to to

NOTE CONF {"raw":[100,100,100,100,100,100,100,76,100,100]}

00:47:39.930 --> 00:47:41.850
<v Speaker 1>what's after that pair.

NOTE CONF {"raw":[100,100,100,100]}

00:47:42.030 --> 00:47:43.680
<v Speaker 1>Okay, that's the empty list.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:43.680 --> 00:47:48.030
<v Speaker 1>So this is this is something, uh, we do something

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:47:48.030 --> 00:47:51.270
<v Speaker 1>to zero to give the the right answer here.

NOTE CONF {"raw":[100,100,100,100,98,100,100,100,100]}

00:47:51.270 --> 00:47:52.470
<v Speaker 1>The right answer is one.

NOTE CONF {"raw":[100,100,100,100,100]}

00:47:52.470 --> 00:47:53.010
<v Speaker 1>Right.

NOTE CONF {"raw":[100]}

00:47:53.010 --> 00:47:54.660
<v Speaker 1>So it's it's one.

NOTE CONF {"raw":[100,100,100,100]}

00:47:55.290 --> 00:47:56.010
<v Speaker 1>Sorry.

NOTE CONF {"raw":[100]}

00:47:56.010 --> 00:47:58.260
<v Speaker 1>So the answer is one plus.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:47:59.100 --> 00:48:01.290
<v Speaker 1>Uh, sorry, I'm not doing this very well.

NOTE CONF {"raw":[100,100,96,100,100,100,100,100]}

00:48:01.320 --> 00:48:03.400
<v Speaker 1>Um, doubles of the empty list, right?

NOTE CONF {"raw":[100,100,100,100,100,98,100]}

00:48:05.950 --> 00:48:06.400
<v Speaker 1>So just.

NOTE CONF {"raw":[100,99]}

00:48:06.520 --> 00:48:07.990
<v Speaker 1>I'm just writing down some examples.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:48:07.990 --> 00:48:08.950
<v Speaker 1>So, um.

NOTE CONF {"raw":[100,97]}

00:48:11.440 --> 00:48:13.900
<v Speaker 1>What if what if the things were not the same?

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:15.610 --> 00:48:17.320
<v Speaker 1>Okay, then it wouldn't be one.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:48:17.320 --> 00:48:21.970
<v Speaker 1>Plus, the recursive call would be zero plus the recursive

NOTE CONF {"raw":[100,100,100,100,95,100,100,100,100,100]}

00:48:21.970 --> 00:48:22.240
<v Speaker 1>call.

NOTE CONF {"raw":[100]}

00:48:22.240 --> 00:48:24.640
<v Speaker 1>Or that is to say just that.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:48:27.700 --> 00:48:28.420
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:28.660 --> 00:48:31.300
<v Speaker 1>Now this is of course not a general case.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:48:31.300 --> 00:48:34.750
<v Speaker 1>This is the case where the second, uh, where where

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:34.750 --> 00:48:36.940
<v Speaker 1>you've only got one thing in the list and then

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:36.940 --> 00:48:38.200
<v Speaker 1>you've got nothing.

NOTE CONF {"raw":[100,100,100]}

00:48:38.200 --> 00:48:38.890
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:38.890 --> 00:48:42.700
<v Speaker 1>But, um, you could at this point say, well, maybe

NOTE CONF {"raw":[100,88,100,100,100,100,100,100,100,100]}

00:48:42.700 --> 00:48:46.510
<v Speaker 1>the answer here is that it's one plus, uh, one

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:48:46.510 --> 00:48:47.380
<v Speaker 1>plus that.

NOTE CONF {"raw":[100,100]}

00:48:55.150 --> 00:48:55.930
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:48:55.930 --> 00:48:57.610
<v Speaker 1>Um, in this case, this is the right answer.

NOTE CONF {"raw":[69,100,100,100,100,100,100,100,100]}

00:48:57.610 --> 00:48:58.210
<v Speaker 1>All right.

NOTE CONF {"raw":[100,100]}

00:48:58.600 --> 00:49:03.100
<v Speaker 1>Um, so we've kind of generalised from this.

NOTE CONF {"raw":[100,100,100,100,100,75,100,100]}

00:49:03.100 --> 00:49:05.440
<v Speaker 1>You could write down if it's more complicated example, you

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:05.440 --> 00:49:08.380
<v Speaker 1>might want to write down more than one example.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100]}

00:49:09.790 --> 00:49:14.530
<v Speaker 1>Um, but by by taking those, by taking a couple

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:14.530 --> 00:49:16.810
<v Speaker 1>of examples, you can kind of generalise and see what

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:16.810 --> 00:49:17.470
<v Speaker 1>the result is.

NOTE CONF {"raw":[100,100,100]}

00:49:17.470 --> 00:49:19.480
<v Speaker 1>So what is it you need to do with the

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:19.480 --> 00:49:22.870
<v Speaker 1>number of doubles in a list to make it, uh,

NOTE CONF {"raw":[100,100,100,100,73,100,100,100,100,100]}

00:49:22.870 --> 00:49:25.990
<v Speaker 1>give the right answer for this, for this, um, for

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,100,100]}

00:49:25.990 --> 00:49:26.860
<v Speaker 1>these cases.

NOTE CONF {"raw":[100,100]}

00:49:26.860 --> 00:49:27.130
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:49:27.160 --> 00:49:29.590
<v Speaker 1>Now let's just quickly show you that this actually gives

NOTE CONF {"raw":[100,76,100,100,100,100,100,100,100,100]}

00:49:29.590 --> 00:49:30.280
<v Speaker 1>you the right answer.

NOTE CONF {"raw":[100,100,100,100]}

00:49:30.280 --> 00:49:31.840
<v Speaker 1>And then we're finished for today.

NOTE CONF {"raw":[100,100,100,100,100,100]}

00:49:32.110 --> 00:49:32.320
<v Speaker 1>Um.

NOTE CONF {"raw":[100]}

00:49:32.320 --> 00:49:34.090
<v Speaker 1>So count.

NOTE CONF {"raw":[100,98]}

00:49:39.160 --> 00:49:39.460
<v Speaker 1>This.

NOTE CONF {"raw":[93]}

00:49:39.460 --> 00:49:40.690
<v Speaker 1>The answer should be two.

NOTE CONF {"raw":[95,100,100,100,100]}

00:49:41.350 --> 00:49:45.160
<v Speaker 1>Uh, the answer is, uh, that I've, uh.

NOTE CONF {"raw":[100,100,100,100,100,100,100,100]}

00:49:45.160 --> 00:49:45.790
<v Speaker 1>Oh, it's.

NOTE CONF {"raw":[100,90]}

00:49:45.790 --> 00:49:47.650
<v Speaker 1>Yeah, because I've got the wrong function.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:49:48.040 --> 00:49:49.750
<v Speaker 1>Um, let me try again.

NOTE CONF {"raw":[100,100,100,100,100]}

00:49:49.750 --> 00:49:51.790
<v Speaker 1>The function is called num doubles.

NOTE CONF {"raw":[98,62,62,100,100,100]}

00:50:00.500 --> 00:50:02.300
<v Speaker 1>The answer is to yeah, okay, so I did this

NOTE CONF {"raw":[100,98,98,78,100,100,100,100,100,100]}

00:50:02.300 --> 00:50:05.180
<v Speaker 1>correctly despite making a mess of it.

NOTE CONF {"raw":[100,100,100,100,100,100,100]}

00:50:05.390 --> 00:50:05.900
<v Speaker 1>Okay.

NOTE CONF {"raw":[100]}

00:50:05.900 --> 00:50:06.650
<v Speaker 1>Thanks.

NOTE CONF {"raw":[100]}

00:50:06.830 --> 00:50:07.970
<v Speaker 1>Uh, that's it for today.

NOTE CONF {"raw":[93,100,100,100,100]}

00:50:07.970 --> 00:50:09.170
<v Speaker 1>So see you tomorrow.

NOTE CONF {"raw":[100,100,100,100]}

00:50:14.600 --> 00:50:17.300
<v Speaker 1>I should say sorry about the mess with learn and

NOTE CONF {"raw":[100,100,100,100,100,100,100,100,94,94]}

00:50:17.300 --> 00:50:17.630
<v Speaker 1>stuff.

NOTE CONF {"raw":[100]}

00:50:17.630 --> 00:50:18.800
<v Speaker 1>Not our fault.

NOTE CONF {"raw":[100,100,100]}

00:50:18.800 --> 00:50:19.730
<v Speaker 1>The university.

NOTE CONF {"raw":[60,100]}

00:50:19.730 --> 00:50:21.440
<v Speaker 1>The whole university was screwed up.

NOTE CONF {"raw":[100,100,100,100,100,100]}
