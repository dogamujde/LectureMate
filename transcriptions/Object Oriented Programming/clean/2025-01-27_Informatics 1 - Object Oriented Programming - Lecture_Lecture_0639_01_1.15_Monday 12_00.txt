Now that you know who we are.
Please scan the QR code to find out more about
other sessions.
You might have seen our posters in Appleton.
So we're looking forward to seeing you.
Come along, get some free snacks and chat to all
the students.
This semester we're also going to recruit new leaders at
the end of the semester.
So if you're potentially interested in getting involved helping out
next year, and it's a really great and fun thing
to do, so go for it and follow our Instagram
if you're interested in getting updates.
Because we occasionally, usually we're always in the same room.
Occasionally we have to change room, but usually we're always
there.
Cool.
Thank you so much.
Thanks very much, guys.
, so just to emphasise, you totally should go along
to us.
We get asked loads of questions, especially about things
internships and all kinds of things these guys are doing
anyway, and they do it really brilliantly.
So do go to empowers.
You'll get a lot out of it.
It's going to make your lives way easier.
So thanks very much.
I think we got one more.
Did you send me a slide as well?
Oh, God.
Sorry.
Yeah.
Thanks for coming.
Okay.
So sorry.
What did you send me?
Yeah.
Here we go.
I did download it.
Okay, I just pick this one up.
Oh, no.
Yeah, just use this one, actually.
There you go.
Thank you so much.
Testing.
Oh, there we go.
Perfect.
If I just give you a note for you to
just switch the slide over it, that's fine.
Perfect.
Brilliant.
All right.
Hello, everyone.
, yeah.
Welcome to your average F1 b lecture.
I'm here to talk to you guys about Hagler, Boro.
Hagler.
Boro is back for its 11th iteration this year.
So pack for 2025 is coming on the first the
2nd of March.
If you don't know what hack is it's our annual
24 hour hackathon.
It's run by Comstock in collaboration with other societies.
And the school really likes it.
, it's an absolutely amazing opportunity for your CV.
It's an absolutely amazing opportunity for any of you to
get involved with your very first hackathon.
You do not need mountains of experience.
, there's plenty of challenges ranging from easier to harder
ones.
You can sign up with your friends.
, there's plenty of prize to be won.
We have very big companies sponsoring us.
I can't reveal who they are just yet because those
are being reviewed by our social media team.
But in the past few years, we had big names
Blackrock a few years ago, and maybe at
companies Optima, I'm pretty sure.
So, you know, that might give you an idea of
who we might be getting this year.
, yeah.
So basically, all I'm here to tell you guys and
ask you is that you get involved.
Try and apply for it again.
It's really great for your CV's.
If you've never done a hackathon before, please try and
get in on this one because this is the big
one.
This is the one that the School of Informatics probably
treats as the biggest one in the university, and it's
the biggest hackathon in Scotland.
So save the date 1st or 2nd of March.
And if we just switch the slide there, there's the
QR codes.
So applications are now officially open.
We've opened them today.
We now have a hack our website.
We have an Instagram and a discord.
If you guys just scan any of those QR codes
you will be able to , you'll be able to
apply, you'll be able to be kept in the loop
on what we're doing.
And yeah, if I just give you guys some time
to scan this QR codes, that'll be great.
Thank you so much.
Great.
Thank you very much.
So just to again back that up, I really this
is such a great opportunity.
Quite a lot of people have already been asking me
about internships and stuff.
Internships are really hard to get after first year, but
building up your skills, showing the active being involved in
bigger projects is exactly the way you get to build
up that kind of CV presence that's going to help
you a lot.
And also hackathons are a lot of fun.
So I'll just give you a couple of seconds.
I will put these on the info on the website.
So if you own the open course page.
So if you miss this you will be able to
go there.
But we've got a lot to get through today so
I'm going to push on with that.
All right.
So let's go back to Woo clap see how people
are feeling about the assignments.
Now I've lost everything.
Okay okay.
So assignment one is released today I think the email
about that has just gone out.
I think it is now live.
you will have hopefully you'll have tried the tests.
You have a bit of time to do this.
Take it easy.
Take take your time over it.
I would start quite soon, but I wouldn't necessarily rush
through.
As I said, I think last week some of it's
going to be quite hard if you're just beginning with
just the stuff we're covering now.
So don't get too ahead of yourself, but some of
them you'll be able to do so.
Just take a look at it.
Don't leave it all to the last minute.
I sent an email about all of this earlier.
, okay.
So we're going to have a very quick look at
feedback from last week.
, so how much live coding.
So most people the live coding, but there's really,
, a division pretty much exactly equal split between whether
you want it really focussed on live coding and not
so much on the slides, , or a bit more
mixed up.
So I'll try not to just completely ignore the slides,
but the slides are always there for you to go
and look at, whereas the live coding isn't.
You'll find there's not there's hardly any live coding.
There's not much live coding today.
It depends on the lecture, but I'll bear that in
mind.
Most of you are enjoying the course.
Yay!
So only 4% are not enjoying the course.
That makes me feel quite happy.
So most of you are.
That's great.
, most of you have not been to a lab
session because you don't feel you need the support right
now.
That's absolutely fine.
They're not intended for you to have to go to
them.
But do I think these are really underused and people
who actually would get a lot out of it don't
go.
So if you want a bit of a 1 to
1 tutoring or, you know, not a whole hour of
1 to 1 tutoring, but but a bit of attention
from someone who knows the course.
Do go.
Only a small number of people thought it wasn't as
helpful as as they'd .
If you do, if you do go along and you
find it isn't as helpful as you'd .
Please get in touch with me.
I'd to know more about that.
Most people are more or less all completely understand what
they need to do, which is really good.
So far the level of the course is good.
Yes, I'm really happy with that.
Challenging is okay.
I'd expect maybe a bit more people to find it
challenging, but it's early days.
But that's all fine.
And there's a real mix between how much people have
been doing the labs.
I don't expect this to be most people, because if
you have got a lot of object oriented and Java
experience, you probably don't need to be doing the labs.
But if you're trying to learn this, the labs are
where you get that practice in.
, okay.
Most people, quite a lot of people have signed up
to Piazza, but most people haven't actually been using it.
It's just I would definitely get onto onto onto Piazza,
especially now the assignments are live just to see what
the chat is.
People are really asking questions that actually is quite useful
for you.
You'll see what people are talking about.
It's really useful to be involved in the buzz of
the class and and to pick up things that you
maybe wouldn't have done on your own.
Okay.
There's a lot of academic families.
I don't have time to go through that now, but
I think something's coming out really strongly from that is
that it hasn't been as active as people would .
A lot of people haven't really heard from their parents
that much.
This is the first year we've been running it, so
we haven't had a lot of support for the academic
parents, and that means they have not a lot of
them haven't been engaging that much with the with with
you guys.
So we're going to try I was away the whole
of last semester, which didn't help, but we're going to
try and ramp that up.
And your feedback is really, really helpful.
So thanks for that.
Some of you have been really enjoying it, but I
know that for a lot of you, it hasn't really
taken off because your parents haven't been that engaged.
Okay.
So woo I'm now going to go back.
These are the questions, the actual sensible questions that we
had last time.
More practice writing loops and functions.
This is in the labs.
Do the labs.
But also it'll be in the tutorials and you'll be
getting it in the assignments as well.
So do the labs do the tutorials.
This is where you'll get the practice.
Okay so this is a comment about memory.
, about well okay.
Actually I don't want to go through this in too
much detail because we'll be talking about memory later on.
, couldn't you use else if statements along with break
statements to make it more readable?
So there's so there's different ways you can do this.
We looked at one way of doing it.
, but yes, you can use break statements in that
as well.
Why are I considered Doctor of philosophy or PhDs, whether
it's in neuroscience or English literature or anything, is a
doctor of philosophy.
That's just a really ancient thing, because the whole idea
is it's about love of knowledge, which now specifically refers
to an individual subject.
But originally when the 14th century or whenever they started
it, , it was more general.
Okay, can we use plus plus I instead of I
plus plus.
So I'm just going to show you this is this
is true.
You can.
So I didn't show you this because I didn't want
to bring in too many, , new things.
But let's have a quick look at that.
, so here we said, , If we do?
None.
Plus.
Plus, this doesn't work, right?
Because.
Do you remember why this is?
Because this is post incremental.
So it does this thing return num.
And after that it adds one.
So we got around this by doing this doing this
that.
So we first of all we increment by one and
then we return the value.
Oh and we also haven't assigned it here.
Okay.
But somebody pointed out somebody who maybe knows a bit
of Java that you can do pre increment here.
Plus plus this is the same as num plus plus
plus plus num num plus plus are the same except
for the point at which the increment happens.
So this means first of all increment num and then
do whatever the instruction says.
Whereas num plus plus means do whatever the instruction says
and then increment.
So if we do it this, we will see
that it does return one because it's first adding it
before it returns it.
So yes you can.
Why do you have four times I plus J in
the deck.
So I'm not going to go through this.
But this is is because you need the deck to
be 52.
And also if you're interested in this, just get out
a piece of paper.
Go back to the code on cards.
Look at the for loop with the eyes and the
JS and work out how that is, how that is
iterating through to add something in every space for 52
spaces in the deck.
If you didn't have that full time, it wouldn't work.
I don't really have time to explain that, but you
can figure that out yourself.
That's a really interesting little problem.
Is there a chance of getting an index out of
bounds error on the cards?
Example if Math.random returns one.
No there isn't.
Because Math.random does not return one, it returns something less
than 1.0, so it's never going to return one.
It's always going to be less than one.
What if the array doesn't?
We define doesn't have a fixed length, but it changes
by how many times the user gives an input.
You can't do that with arrays in Java.
If you want to do that, you have to use
different structures that we'll talk about later.
Do we have tutorials today?
No tutorials.
That was on Thursday.
The answer's no.
Also none today.
We don't have tutorials on Monday and Tuesday, but this
is the week that tutorials start, so you will have
your tutorial this week.
This is the same question these two.
How do you use an enhanced for loop to iterate
through 2D array.
So 2D arrays you've got two things going on.
So you have to have nested for loops.
We will look at that later.
I don't want you to worry about that, but if
you're interested in it you can do it.
Is it still possible to get the Informatics 2D?
No, it is not still possible.
I'm afraid not.
So there's the Informatics hoodie with the dark, which was
this one.
I don't really know what the duck is all about,
but that was the one that the students designed and
it was heavily subsidised by the school.
Those are all sold out.
I'm afraid you have to act quickly when you get
the email about the hoodies.
You can get informatics hoodies in the university shop, which
is just right by the forum, but they're not subsidised,
they're full price and they don't have the duck on.
So sorry about that.
They go quickly.
Everybody loves the hoodies okay, so that's last week.
So this week part of the lecture we got Willow
who's a Jack Russell Chihuahua mix.
she was the runt of the litter, but she's
the cutest and best behaved and very greedy, so probably
won't be around for very long.
That's super cute.
And then.
Oh, okay, we do have another pet somewhere.
Oh, we don't have another pet.
Sorry, I had some birds, but for some, somehow they're
not in here.
I don't know what's going on there, but never mind.
We'll have them next week instead.
Okay.
Teaching awards.
Teaching awards.
Open.
Do nominate people for teaching awards.
If you ever.
If you think anyone's doing a good job, please nominate
them.
I had a colleague who messaged me yesterday saying I've
got another nomination.
This is his second and he's so excited about it.
It really makes a difference.
You guys, for example, have been telling me how great
Julian is.
Okay, has anyone nominated Julian for a teaching award?
If you think he did a good job, if he
was fun, if he made learning good or whatever, just
nominate him.
It only takes a second.
You have to write something about why you're nominating the
person, but it's only really brief.
So this makes a huge difference.
And also last year Informatics didn't get that many nominations
and I spoke to lots of students.
I was , oh, do you think, you know, people
aren't in teaching?
They're , no, no, there are loads of great teachers.
I just didn't get around to nominating them.
So, you know, I'm not saying nominate for the sake
of it.
So informatics looks good.
I'm just saying if you think someone's done a good,
good, good job, do nominate them because it makes everyone
very happy and it makes the school very happy.
Okay.
Assignment one I think you've got the email about that.
, this is just saying don't leave it to last
minute.
27th of February is a deadline, so you've got plenty
of time.
But pace yourselves and read the emails about it.
Okay.
Office hours.
Which two was the winner?
So I'm going to have rich tea.
And that's going to start at 4:00 in 606 as
usual.
, so do it was great.
Last week loads of people came to say hello.
So do come along and say hello or come along
with any questions or whatever.
I'll be there with my rich tea and I'll bring
much more than I did last time.
All right.
So I want to go back to what we were
talking about last time.
So we were talking about , passing by value and
what that means.
So if we look in here, we are back in
IntelliJ.
So remember with this one we if we just called
add one, but we didn't actually do anything with it.
This didn't do anything right.
Because we're passing the number back here.
It's just a local variable.
It changes the variable locally.
But then we jump out of that function and that
local variable is forgotten.
If we want to do anything, we have to pass
it back.
We're passing by value.
so this should be x.
So here if we actually part, we take what comes
out of this and we assign it to something, then
that's how we retain it.
Okay.
But having said that things don't work quite that
with arrays right.
So arrays oh so raises slightly different.
So I'm going to go to let me see
add one array.
Okay.
So here what we're doing.
We're just printing out an array not doing anything about
it.
Said this array is zero one.
You can see it's just printing the array.
Now we've got something called we're going to do add
one.
And this is add one for an array.
So it takes an integer of arrays.
And just to the first number it adds one.
So we would expect the outcome of this method to
be one one.
However this is returning.
This is not returning anything and we're not assigning it
to anything.
So what's going to happen.
So the return the answer here is one one.
So this has made a change even though this is
just happening this this is not returning anything.
Okay.
So what is going on here.
And this is to do with the way things work
in memory okay.
So as we know, the array itself and its length
cannot be changed.
But the elements can be changed and it's changing.
The value of an element of an array is a
side effect of the function.
This is something you have to be careful with because
often you change things accidentally.
So you have to be very conscious about this.
So this is the code that we've been looking at.
So here we're calling this code, we're passing to add
one to our array.
And and it's adding one as we've seen.
So why does this make a difference.
This is because the calling code is pointing to a
in memory.
So it's pointing to something we've created in memory which
is an array.
And this array has the values in memory.
We looked at a little bit about how we created
arrays in memory.
And then we send this to the method.
And this is also talking about this same as pointing
to the same bit of memory.
So when we change things locally it's actually going to
memory and changing things in memory.
Right.
Which does not happen when it's a variable.
It happens when it's an array.
So if we look back at what's going on here.
What's not doing that.
Okay.
So A and A and B and C and whatever.
Yeah I guess so.
So so it's these are not living in memory in
the same way.
These are variables.
Whereas the array has got this spot in memory where
we're changing the values of that array.
So it's pointing to this array.
And a memory is something we'll talk about a bit
more later on okay.
So I'm not going to look at we'll look at
this very briefly.
This is kind of a so this is going back
to returning things.
So here we're cubing a number I've got some questions
for this.
But I don't think we need to really go into
that.
So what is going to go here.
We're just we need to have the return statement because
we're not because it's not void.
And we can put all the, , actual action of
the, of the code, which is this multiplication into the
return statement because it's really straightforward.
, okay.
So have a look at this.
What's going on here.
So we've got this main method.
We've got two integers A and b.
We're printing out a and b.
And then we're going up to this code that's swapping
them around.
Printing out these swapped ones.
And then we're coming back to the main method.
And we're printing out A and B.
So I'm going to put this up on woo clap.
Oh no sorry.
That's this one.
Okay.
So which of these answers is it going to print
out.
I'll just give you a few seconds for that.
People.
Oh sorry.
Actually you're on the different wook lab okay I won't
do that through.
Woohoo!
Clap.
Because that's a bit complicated, but the answer is, oh,
somebody's on there.
Okay, so what's it going to print out?
It's going to print out 255225 because it prints out
what's here.
It swaps them around.
But then it hasn't actually changed anything in memory.
And it's not passing anything back.
So A and B just reverts.
Within this context A and B are just the same
as they have been.
Whereas here we've got an array and we're printing out
the first and second elements of the array.
And then we're swapping the array up here, printing that
out and then printing out again what's going to happen.
So here we're going to get two five.
And then we swap.
We're going to get five two just the same.
But here because of the way this is changing something
in memory, when we go back to the main function
that swap is going to persist.
Whereas with the variables it didn't persist.
Okay.
So we're going to look a little bit very briefly
at the whole idea of breaking of what functions how
you use functions to make code more readable.
Okay.
So we're looking at nearest neighbour to a central point.
This doesn't really matter very much the details of this.
But this is the code right.
This is the code for finding the centre point.
So if you have a look at this okay.
Can you pick up pretty easily what's going on in
this code that you can't pick up pretty easily.
This is really hard to read right.
So even if you understand how you work out nearest
neighbours, even if your Java is really good, this is
going to take you a long time to figure out
exactly what's going on here, Because there's no structure to
it.
There's no functions, there's no arguments.
So if we want to make this really nice and
organised, we have to think what is the logic of
what we're trying to do?
So good coding is always about following the logic.
Okay.
So first of all you need to parse arguments.
You're passing all these arguments in.
You've got to parse them.
Then you're going to find the centre.
Then you're going to print the centre.
Then you're going to get the neighbours all around the
centre.
You're going to calculate the distances between the neighbours in
the centre.
Print those distances, calculate the minimum of all those distances,
print minimum okay.
So these are the steps you're going to do.
That is the logic.
So you have to think about what's going into this.
So here we're passing in the arguments that we start
with.
We're parsing them and that's returning our points.
Get centre takes those points and returns a centre.
Print centre takes the centre and doesn't return anything.
And so on and so forth.
At each point, we're using what we've got before to
pass things into a function and to do something else.
Okay, so instead of this crazy code that you saw,
let's have a look at how we might do that.
So let's look at nearest neighbour.
Okay.
So we're going to have a main method.
And we are going to start with what are we
going to start with.
Oh I haven't got here anyway.
So let's have a look at this.
We're going to want to parse the arguments right.
So we're going to oops.
Parse arguments.
And this is going to take in the args oops.
And it's parse arguments is going to return something.
It's going to return the points.
And what kind of thing of the point is going
to be a double array.
Okay.
So it's not happy with parse arguments because I'm calling
a method that doesn't exist.
But you can see what's going on here.
So then I'm going to take the points I'm going
to get the centre.
So get centre takes points and it's going to assign
those to something called centre which is going to be
A double.
And then we're going to have print centre which takes
the centre doesn't return anything okay.
And then we're going to have all the other things.
But this is where we start off.
So that you can see this is immediately quite clear
what's going on here.
Now we have to put in these methods.
So let's do public static.
we're going to do parse arguments here which takes
in args.
so we have to think what is the return
value we're going to put in here.
Double array.
Yeah.
So we've already said it's it's something that returns double
rated.
This has got to match.
And then we've got to tell it what kind of
thing ARGs are.
And then we're going to have whatever we're doing.
We're going to have a return going to return something
that's a double array.
And we're going to have some code in here.
So this is how we structure it right.
We have all these different methods.
You go to main, you can clearly see the logic.
And then if you want to see what's happening in
each of those methods.
You go inside them in detail.
Okay, so this is what it looks when we've
got, , everything in there.
, so in here, we've got all the codes.
I'm not going to go through all the code because
it's not really relevant to the point we're making.
But if you want to have practice at code, you
can have a look at how it's coding all these
different paths.
Arguments get sent to get neighbours and all of those
things.
It's all in there.
So why do you want to do this?
Do you want to break programs down into well named
functions?
All the functions I had had names that gave you
an idea of what it was.
They did make something really complex into something much clearer.
It hides implementation details.
So I might want to know how you're getting centred.
I can go and look at it, but likely I
don't really care how you do that.
I just need that to happen so I don't need
to see the difference.
I think we did the dry we mentioned this last
time, didn't we?
Don't repeat yourself.
Readability.
Maintainability.
Super important.
10 to 12 lines.
, so it encourages good program practices by emphasising the
discrete reusable methods.
It self documents the code to some extent because you
can understand what it's about.
Use descriptive names so you can understand it and it
reduces code duplication, which is a really bad thing as
we've said before, because it leads to errors and it's
really hard to change recursive functions.
Yeah.
So the basic concepts are the same as in Haskell.
, okay.
So that's just picking up on some of the stuff
about functions that we didn't quite cover last time.
So let's now move on to classes and objects.
So we are, as I think has already come up
in the questions.
This is an object oriented course.
We haven't really talked about objects very much at all.
That's because we need to get in the basic functional
stuff first okay.
So why object orientation?
Why is this such a common paradigm in coding is
because changing code is really hard and expensive.
But the world is really dynamic.
So changing your code all the time, you know, on
your phone how often you get app updates and so
forth.
You're constantly changing, updating, improving.
Because you have to.
Because the world's changed or because you want to.
Because you've thought of new features.
This happens.
This is mostly what coding is about, starting from scratch
and creating something new.
It doesn't happen all that much.
I mean, it happens quite a lot, but mostly it's
about improving and extending what you already have.
Okay, so you want to minimise the amount of code
that you have to change, and you want to make
it really easy to work out which bit of code
you have to change.
And the kind of the fundamental rule is that code
that, that, that you need to change.
The things you want to change at once should live
together, right?
If the logic makes it makes a this is this
is something that's happening.
So if you want to change this, it all happens
in this place.
It should be a place where they live together instead
of code all over the place where you have to
go all into different things.
Because one thing has changed and that's affecting lots of
different things.
You want it to affect one thing that you can
change, and then that spirals out to all the other
things that are affected.
We've talked about hiding information so that so that the
code doesn't depend on it.
I actually maybe I want to change how I do
this.
I can do that.
It doesn't change anybody using that code.
For example the parse arguments, maybe I've got an actually
much more efficient way of doing this.
I'll just change that.
Nobody's using that method needs to care about that.
It's still doing the same thing for their point of
view.
So modularity and abstraction via functions you're using functions to
get this modularity okay.
So the interface between the user of the code and
the implementation is the API.
So this is the implementation is what's under the hood
what Java is actually doing.
The the user is, is the person what they want
it to do.
And the API is how we're telling it that that's
supposed to happen.
So for example, , these slides weren't actually done that
long ago, but this is a bit retro.
, but we have a client.
This is, this is the example of a tele.
The API would be the remote control, right.
That's how the user interacts with the machine.
You don't need to care about what's going on under
the hood.
You don't need to care about, you know, the cathode
ray tube or however it's happening.
You just need to know the buttons you need to
press to get it to what you want to do.
An API probably is a concept most of you are
really familiar with.
Okay, so data representation.
So a data type is a set of values and
operations on those values.
And as we've said in Java it's a type language.
Types are really important.
You can't do anything in Java until you've told it.
What the type of thing you're what type everything you're
talking about is.
So we have primitive types and we've seen these before.
Integers double boolean.
Those are all the really basic ones we started off.
Also you have user defined.
So a lot of them I mean mostly when you're
programming you're going to be creating your own types.
And these you can call anything but you can call
them anything.
But you always should call them something that's logical and
clear so that people coming to it fresh will understand
what it is those things are supposed to be doing.
So the quick way to tell the difference, if you're
looking at something, you want to know which one it
is.
Although it's pretty obvious because you know you know what
the primitives are.
But primitives always start with lowercase letters, whereas user defined
always start with uppercase letters, and when you have new
words in it, you shove all the words together and
each one starts with a capital letter.
And you can have them be arbitrary long, but the
longer they get, the more difficult they are to read.
There is occasional exceptions, for example strings.
So you may have noticed that when I do ints
it's always lowercase, but when you put strings in is
always an uppercase.
This is because string is not a primitive.
However, string is so common that it kind of behaves
a primitive.
It has a lot of built in stuff in the
standard library, so you can do a lot of things
with strings that are already built in.
So effectively you can treat it a primitive, but
it starts with a capital okay.
You don't need to know how the data type is
implemented in order to use it.
So we don't need to know printer.
Q how does a printer Q work?
I don't care, I just care that there's a print
Q and it's going to help me print stuff.
So you should read the documentation.
Actually, I should show you all the Java documentation.
I haven't got that up today, but I'll show you
that on Thursday.
Maybe.
But there's good documentation about everything built in in Java.
It will tell you what it takes in and what
it returns and what it does.
And when you are, we'll get on to this later.
When you're writing your own stuff, you need to provide
documentation so people understand what they're for.
So there's this difference between abstraction and encapsulation, which are
actually generally used fairly interchangeably.
But a slightly, subtly different abstraction means you don't need
to know about implementation, and encapsulation means you can't depend
on implementation.
So in encapsulation, things can actually be changing under the
hood.
But the documentation should always be telling you what it's
doing.
And this varies between languages.
Okay, so as I was saying it's mostly pretty procedure.
What we've been doing so far.
That's because we're building up the underlying stuff.
So we've looked at primitive types control flow and how
to put things into array.
None of that is object orientation.
That's just the tools that you're going to need when
you're doing some object orientation.
Okay.
So but the philosophy of object orientation, which as, as
we've been saying software changes a lot.
So structuring based on oh so structuring based on what
your software should do is really expensive, right.
Because that is going to change.
However, the world, the domain in which you live or
what you're structuring this or what you're setting it, it
doesn't change as much.
Right?
So the kind of objects that can exist in your
world are much less likely to change in the kinds
of things you want them to do.
So if you if you think of it all in
terms of objects and how they interact with each other,
that's a much more stable design.
And you can change how they do things within the
objects without changing that overall structure.
Whereas if you're structuring it all around what it's actually
going to do, then when you when what you want
it to do changes that, that means much more fundamental
changes.
So this is a much more stable way of coding,
which means it's easy to to exist in a very
dynamic world without doing with doing the minimum amount of
maintenance.
Okay, so I think we came into this right at
the beginning.
Things in the world, i.e. objects, they know things and
they do things knowing things as instant variables, that's the
values that they have.
Doing things as methods.
Right.
What are the kinds of methods that they can do?
So objects have states, which is what they know the
instance variable.
And they have behaviour which is the things that they
can do which are defined in the methods.
So here we have a car right.
We're creating an object a class of car type car
which is going to create objects of type car.
Okay.
So what can it what does it know about itself.
So it might know there's all kinds of things you
could put in here.
But for example it might know whether it's engines on
it might know what speed it's travelling at.
It might know how much petrol it's got.
These are these are facts about the object.
What kinds of things can it do.
What are the methods that might exist.
So you might want to start the engine.
You might want to stop the engine maybe accelerate, maybe
break, maybe refill petrol.
And again with the car there's loads of things you
can put in there.
But when you're designing objects, when you're designing, when you're
writing classes, just write the stuff that you need.
Don't think about, oh, maybe one day I'd really want
to know how many doors are open.
Or maybe one day I really want it.
You know, there's loads of stuff you can do.
You can do that as you go along, as you
need to keep it as simple as as you can
as you're writing it, and only write stuff that you
know you're going to want it to do, and then
you can easily add stuff as you go.
So programs run by objects sending messages i.e. initiating behaviour
to one another.
So that's what we've seen before.
For example, we had the main in the nearest neighbours
thing.
We had the main thing that was running and it
wanted to get the point.
So it sent a message off to parse arguments to
do something useful.
So they send messages and they receive messages that tell
them to do stuff, which maybe change dates and maybe
send more messages and so forth.
Okay, so how does this work in Java?
So Java is a class based object oriented language and
we organise code in classes.
Classes.
And that's how you define your data types.
So and we have these class diagrams right.
So here we've got the name of the class here.
This is a class of car.
We start off with the state.
We have the things the things that it knows the
variables that we have, whether or not it's running, what
its speed is, how much petrol it has.
And and because it's Java, of course we have to
say the type.
So running is boolean.
Either it's either the engine's on or it's not.
Speed is an integer.
Petrol is a double.
I mean we could do either of these either way
around, depending how precise we want to be or whatever.
And this is its behaviour, the kinds of things it
can do.
So you have the name of the method.
And the convention is here that these start with a
lowercase.
So class names always start with an uppercase method.
Start with a lowercase and then an uppercase for every
extra word.
And then you have the arguments you're passing to it.
So some methods don't have any arguments.
Start engine doesn't need anything passed into it.
It just it just turns on or off.
But accelerate.
You need to pass something in because accelerate is not
just something you do or you don't do, you do.
How much do you want to accelerate?
So you need more information there and brake again.
How much do you want to brake?
How much petrol do you want.
So you could just have refill petrol with no arguments.
And that might just mean fill it right up to
the top.
Or you could have an argument and that means just
fill it out by this amount.
Okay.
So so far we've looked at behaviour defining behaviour.
But we haven't really looked at building state okay.
So state and behaviour these are the two super important
things in class.
There's one more thing that's really important and that is
a constructor.
Okay.
So the point of a constructor is when you want
to create an object, you use a constructor to do
it.
What does it mean to create an object?
When an object is a virtual abstract thing, what does
it actually mean to create it?
What it means is you're creating a space in memory
that's going to put that that object is going to
point to, and that's going to have spaces for information
about its about its state.
Okay.
So construct is essential.
And.
Okay.
So the constructor is a special method that has the
same name as a class.
So here you can see this is our constructor here.
It's called car.
That's because it's a constructor for a class car.
And then you use the constructor to create all these
instances.
And it allocates memory for class instance and initialises the
state.
So in Java instances of classes are objects.
That is what objects are you create your classes to
say what kinds of things there are in the world.
And when you initialise that to construct a particular instance,
you are creating an object.
Okay.
So here we can see we are using a class
car class and its API.
And here we are using this keyword new.
As we've said before, you cannot create something without using
the keyword new.
New means make some space in memory.
Making some space in memory is what means for something
to exist.
It's got to have its space in memory.
So here we've got my car, and my car doesn't
know anything.
, but, , and if it's got, , the, the,
the state variables will be initiated to whatever the default
is.
, so now we're doing some things to it.
So we're going to say start the engine.
So as we've seen before, the dot is what you
use to signify that you're applying a method.
So this is my object and this is the method
that I'm applying to it.
I'm going to start the engine.
I'm going to accelerate by 30.
Then I'm going to brake by 30, which presumably means
I come to stop and then we'll stop the engine.
I'm going to refill petrol.
So these are all things I can do with my
car now that I've initialised it.
So we have two independent ideas here.
So we've got conceptual objects, the class instances such as
my car.
, and then we have the static types that define
their behaviour.
Right.
So the car class is saying what can happen.
So we have these objects.
And then the class definition is telling what the object
can do.
So objects have a static compile time type defined inside
a class.
Everything that an object can do will be defined by
the class that it's an object instance of.
, instances of classes are created at runtime, and they
need a constructor and the keyword new.
And their reference types, which means they're referencing a piece
of memory.
Okay.
So what's happening in memory.
So memory is something we're going to get into in
more detail a bit later on.
But this gives you a little bit of an idea
about what's actually happening.
So first of all we're creating.
So now we're looking at an array.
It's an array of integers.
And we're saying it's five long.
So here we create it in memory because we use
a keyword new.
We're now creating the space in memory that's got five
slots always going to have five slots.
We can't change that.
These are all initiated to initialise to zero because it's
of type integer and zero is the default for integer.
But then we go on to change things.
So we're going to say write my array three.
I want that to take the value four and my
array two adds whatever's in 410 to whatever's in four.
, and so this is actually changing things in memory
when you're doing these, , these operations.
Okay.
So what about a car.
So that's an array.
But what happens when we have an object, a user
defined object that has, , that has variables, that has
state.
So here we're creating new car.
This is creating a space in memory called my car
is going to have three slots in it.
Because the class definition says that there are three state
of state, , there's three aspects of state, which is
whether it's running what its speed is and , how
much petrol it has.
So then we can do all of these things.
, so why are these, these values actually, that's maybe
sorry.
That's maybe slightly unclear.
That slide I should probably update that because actually this
is not the default.
We have changed these.
We initially we initialised this car and then we've changed
these values.
And we've said it's going travelling 30 and we.
Yeah okay.
So this this is what is happening as a result
of these methods.
So we start the engine.
That means that running is true but it accelerates.
That means that the speed is 30.
So we're changing the values in the memory.
Okay.
So creating class instance reserves memory for its state a
constructor is executed to initialise this memory.
So we use a constructor which has the same name
as a as the class and the local variable Mycar
holds a reference to the actual object.
So my car is always pointing to the actual object
and what it means.
What the actual object is, as we've said, is a
space in memory.
That is what the object is.
So you're pointing to this space in memory.
Okay, so this is a kind of an aside, but
just because we're at this point where this makes sense
now, but just to just to go back to arrays,
.
So an object in Java is either a class instance
of one of these classes that you've created or it's
an array.
, so arrays are treated class instances.
So in many ways you can think of arrays as.
Now we've looked a bit more what it means to
be a class instance or an object.
Arrays are very similar to objects in many ways.
They're just the same.
You need the keyword new they reference in memory.
You have the underlying class definition.
, but there are special things about arrays.
And this is because arrays are so cool.
So it's really useful for programmers to have these kind
of built in things.
So you can do this, this kind of, , terminology
where you're where you're looking at, we extract the value
of something in a particular index in an array.
There's built in things length and it doesn't have
any methods.
So, , arrays is just a kind of special object.
Okay, so what happens if you don't?
Initialise an object.
So here we're saying there's a, there's something called mycar
which is of type car.
And I want to do I want to start its
engine but I haven't used the keyword new.
Well maybe maybe somewhere else.
You've created a new car, but I'm just creating my
car.
But let's imagine you're just typing this in without having
created anything.
Okay, this is not going to compile okay.
So this is the error you'll get variable mycar might
not have been initialised if there's no memory allocated with
it.
Java's not going to do anything with it.
It's not going to be able to do anything with
it.
It's going to complain about that.
There's no new object.
There's no space for it in memory.
It doesn't exist.
It is actually occasionally possible to fool the compiler into
not noticing that.
And then if you're trying to do something with it,
you'll get a null pointer exception.
Right.
And what this means is it needs to be pointing
to somewhere in memory, but it isn't pointing to anything
in memory.
.
So where do references point if there's no corresponding object?
They point to null, right?
So if you talk about my car and you haven't
initialised it, it's just null.
, which means it's pointing at nothing.
And if you use it, you'll get a null pointer
exception.
So creating something in memory absolutely fundamental to object oriented
programming or to Java.
Okay.
So now we're going to copy something right.
So we're creating this new thing called Mycar.
This is where it is in memory.
And then we're saying wait there's another car.
Your car.
And this is the same as my car, right.
But we haven't used the word new again.
So this means we're not creating a new space in
memory.
We're not creating a different object.
We're essentially just saying that your car is a different
name for my car, but it's the same object because
it's pointing to the same reference.
So here we've got this other name, but this the
slots in memory are the same as the same object.
, so so so so when we assign the reference
of an object to a local variable is just copying
the reference to the memory, right?
It's not creating new memory with those values, it's just
creating a reference to the original memory.
, and here.
But here we're doing something different, right?
We're first of all, we're creating mycar and now we're
creating your car.
So we've used the keyword new.
So this is something different in memory.
It's got its own bit of memory.
And then we are copying everything that's up here.
We're copying to here.
So we're saying all these values we want them to
be the same right.
So these are separate objects.
They have the same values but they're the separate objects
here.
These are just the same objects.
Okay.
So what is this going to print.
So we're looking at equals here.
okay let's just quickly go to IntelliJ to this
I think this might be quite useful.
what do we want.
Comparison.
Okay.
So what does it mean in Java?
So first of all we're printing A and B.
This is hello world.
We print A and B we print C.
.
And then we say, are these two things the same?
So we've printed out okay.
This is going to say.
, they.
All say hello world.
And this says this is true, right.
If we do equals, are these the same.
Yes.
That's true.
They're the same.
But what if we use this double equals sign which
we also which also means equals, but in a different
way.
Okay.
So this is going to say false.
Right.
So double double equals what this is saying is are
these the same objects.
Is this pointing to the same bit of memory.
Whereas the equals the equals method that we had before.
What this means is do these things have the same
value.
They're not necessarily the same object, but do they have
the same values.
So here what is this print.
These are different objects.
And this is this double equals means.
Are these pointing the same bit of memory.
So this is going to be false.
Okay.
It compares object references and not object states.
.
This is going to be true, right?
Because here your car is just the same as just
referencing my car.
So these are the same thing because we haven't created
different things in memory.
That's the same reference.
It's just referenced in this bit of memory.
So the reference is the same.
So double equals here will return true.
, and here we're saying these are different objects.
But what we want to know here is, is this
value of speed the same.
Right.
And this will return true.
, because this is a primitive type, this is an
integer.
And double equals means for an integer.
Sorry.
And for a primitive type it means do these things
have the same value.
, so yeah we looked at that there.
, oops.
So if we compare these so there's actually some subtleties
to this I don't want you to worry about, I
just want to touch on now so that when you
come back to them later, you will understand.
So are these the same?
This will print true okay.
Because they're because they're primitive values.
So we can compare them with a double.
Equals.
This as we've seen.
What's this going to print?
This is going to print false.
Because although these have the same value.
They're not printing.
Pointing to same objects.
A, B and C are all they're all different in
different places in memory.
So they're not pointing to the same bit of memory.
However, if we use equals that is saying do these
things have the same value and then it will return
true because they they look the same.
, yes.
Let's very quickly we're almost out of time.
But , so there are occasionally there are things that
you can't do with primitive values.
So when we get on to collections later on, you
have to have objects in that.
You can't have primitive values.
So you have these things called wrappers where you can
turn primitive types into an object.
, and it used to be a real pain, but
now it's much easier.
So if you say so when you're saying, , you've
got a variable you're assigning to something, you can, you
can say it's an integer with a capital I, that
will mean it's an object of type integer rather than
the primitive type ints that we usually use.
You wouldn't generally use this, but you'd only use it
if you're in a situation where you need it to
be an object.
And it works both both ways around.
Java is really happy converting between these two, depending on
what's most useful for you.
, okay, so now here, this is just the same.
Only we're using this as an object.
So now this is going to be true.
Okay.
So this is where it gets a little bit technical.
And I don't want you to worry about it too
much, but just to refer to it so you know
that there's a thing.
This is because of caching.
So it's, , kind of doing things under the hood.
That means with, with these, , five is a literal.
So it's been cached by the compiler.
So don't worry about this.
But if this comes up later then you might remember
that we talked about this.
This only happens for small integers.
So for 200 it's going to say false.
Because integer literals are only cached between 1 to 8
and -1 to 8 and 1 to 7.
Now what's going to happen here?
Are these is this going to be true or not.
The double equals It is because string literals are also
interned.
But here we're specifically creating a new bit of memory
to say these things belong in different bits of memory,
so that now these are not the same.
False.
Okay.
You're using constructors.
So you're explicitly making different bits of memory.
Okay.
So to compare things for primitives you can always use
double equal.
For objects you use double equal.
If you want to know are these the very same
object.
And you use dot equals if you want to know
do these things have the same value.
Are they in the same state, which is almost always
when you're doing equals?
I don't know about almost always, but it's very commonly
what you want to know.
Are these do these things have the same state.
Not are these actually pointing to the same bit of
memory?
So because of inheritance, which we're going to talk about
later, you can use for anything you make, you create
without defining it.
It'll inherit a definition, but the inherits the definition inherits
is just that equals is the same as this double
equals, which is almost never what you want, because that's
really not giving you very much.
So mostly whenever you define a new class, you're going
to want to define the equals method so that you
know in your context, what does it mean for two
things to be equal.
And generally what that means is that all the state
variables are the same we saw with the car.
If it's going the same speed, if it's, you know,
if all these things are the same, then it is,
we consider them equal.
But it's not always that sometimes you want to do
different things.
, okay.
So the methods , okay.
So I think, , I kind of wanted to finish
this lecture today and we're almost at the end, but,
, I think we're going to run out of time.
I don't wanna trust you.
, so let me just quickly say next Monday or
I'm going to leave this up as well.
We got loads of volunteers.
That's great.
But there's lots of time for a couple more.
But next Monday, we're going to have the two hour
session.
Let me quickly show you timetable so you can see
here.
This is info on B lecture goes for two
hours just in week four and week eight.
That means you need to go to the second calculus
lecture.
If you're doing calculus, we will be providing lunch.
It's not going to be super intense, you're
working for hours and hours because it's going to be
more relaxed and more interactive, but it's going to be
really useful and really valuable.
So add questions to ask me any questions, and I
will answer them on Thursday.
And maybe see you in my office hour.