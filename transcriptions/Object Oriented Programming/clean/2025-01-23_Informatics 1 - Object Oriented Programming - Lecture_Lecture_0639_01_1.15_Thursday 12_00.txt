We have snacks.
We have snacks.
Okay, okay.
Oh.
We can also do, , a tournament for Mario Kart
to make it a bit more fun.
And yeah.
That's it.
Hopefully we can see a lot of you guys there.
So.
Yeah.
Yeah.
Thank you.
Okay.
Thanks for that.
That sounds fun.
So that's tonight in the chaplaincy.
If anyone's interested.
, so look out for that.
Okay.
The red lights here.
So let's get started.
So, what's first on my list?
All right.
Tutorials.
Tutorials are starting next week.
Everybody should have their tutorial in their timetable now.
Tutors have been allocated to tutorial groups now.
So you should be able to find out who your
tutor is.
We take attendance and tutorials.
You need to be there.
If you can't be there, email your tutor and hopefully
if you've been given a given a slot that clashes,
then you have followed up on that.
Was that a question at the front?
You still don't have it?
Okay.
Does anyone here not have a tutorial slot in their
timetable?
Just one person.
Okay.
Come and see me afterwards.
Give me your name.
Okay.
Everybody else.
Can you put your hands up if you have got
a tutorial slot in your timetable?
Okay, so it looks .
I mean, not everyone's put their hand up, but most
people have got their hands up and nobody else put
their hand up, so they hadn't.
So hopefully everybody else does.
Don't know what's going on with the other thing.
, anyway, so the assignment one practice tests have been
released.
, there was an announcement about that, but because of
the stupid not sending an email thing from learning, I'm
not sure if all of you saw that.
, but that is an announcement.
If you go to learn, you'll see that, , and
you'll be hearing more about assignments in the upcoming weeks.
Let me just quickly go to Open Course and show
you the schedule for that.
So we're here on week three.
So assignment ones have been.
The tests have been released.
, right.
Okay.
So, , that's week three.
So forget about that.
Week two, which we're on.
The practice tests become available.
We'll be releasing the actual test next Monday.
I think I will tell you more about that then.
, so this is where we are, though.
You got some practice tests?
You have a lot of time for assignment one.
There's no need to rush.
And just so you know, I'll reemphasize this on Monday,
but assignment one contains things we haven't covered yet.
, it will.
We will have covered it well before the deadline for
assignment one, but we release it early to give you
plenty of time.
But if you haven't done a lot of AP before,
just pace yourself.
Don't expect to be able to do all of them
right now, but you will certainly be able to do
all of them in plenty of time.
Okay.
So.
Whew.
I'm now.
I don't have any idea what that means.
, I'm going to go back to last week and
go through the questions.
So I think I've worked out quite a good way
to do Questions.
If I just, , do it in the next lecture,
I can then go through, make it a list and
delete all the things that are not saying anything useful.
It's still helpful for me if you don't put in
a ton of random things into the ask me anything
stuff.
But anyway, here we've got some stuff.
So I'm going to go through this and answer this.
So first one is can I code double array ten.
Now what is this asking I think is this somehow?
, I think I don't want to do that.
, let's do it here.
Okay.
So think what this is asking is.
So I said, right, say we want to have a
an array of doubles.
What we have to do is we declare the type,
we give it a name, and then we use a
keyword new, and we say what it's going to be,
and we say how long it's going to be.
Right.
So if we do that, , and then there's my
array of doubles and we can print that out, we'll
use a enhanced for loop.
So for elements Sorry.
, in array, an element will be a double.
Because we've just said everything in array is a double.
, print array.
Print element.
Sorry.
Okay, so that's going to go through.
That's that's that's a made in new array.
length ten.
It hasn't instantiated anything specifically.
And now it's going through and printing it all.
Is that going to work.
Yeah.
So this just prints out ten elements of 0.0.
So I think sorry I'll just close that down so
I don't have to go through so many screens.
I think what this is saying is could we here
instead let's just put this ten in here and then
not really bother with this because what we're doing is
saying we're declaring this array.
It's it's a double of type ten.
But as you can see from all the read in
here, we can't do that.
Or if we put the keyword new in here or
something okay.
We can't do that.
This makes sense.
Logically.
You can read it and understand what you're saying, but
it's not how you do it in Java.
You have to do it.
I said in Java.
No shortcuts.
You have to use the keyword new.
The exception to that is when you use the shorthand
of the curly braces that we looked at, but otherwise
you have to do it this.
Okay.
So the answer to that is no, you can't come
in blank.
One question what was length?
We didn't define it.
Okay.
So this is something that came up several times in
the lecture.
Let me see.
So here is an example right.
We are we're using this dot which we introduce is
something that means applying a method to something.
So length is a method.
And we're applying it to b which is b is
a double array.
Length is not something we've defined.
Length is a built in function.
Okay.
So you get various built in functions for basic things
that are done all the time.
And we'll come across quite a lot of these.
There are other more complex built in functions in libraries.
So we had a quick look at the maths random
one.
So you have to load the maths package.
If you just use random without saying where it comes
from.
It won't work, but you can use Math.random and Java
will know what it is.
Here length is just built in so you don't need
to define it.
This is predefined for you and there are quite a
few of these.
And you will see them more and more of these
as we go along.
The index.
The array index basically offsets a pointer under the hood.
So index zero is offset of zero.
So first element.
Okay.
So this is not a question.
This is an explanation I left that up because I
think that's a really nice one.
So what the what the index is saying is how
much offset are you.
From this from the top.
So if you're in the first position you're not offset
at all.
So somebody asked last time why do you start an
array at zero and not at one?
The first element kind of seems it should be
element one, but it's not.
Not because what you're talking about is an offset.
So position one is offset by zero from the beginning.
So that might help a little bit.
When should we use enhanced for loop over array for
each.
So for each is a method that's built in.
That's in the arrays package that you can use.
It is in some ways similar to the enhanced for
loop, but we're not covering right now.
So I'm not going to talk about for each.
It's something you might come across later.
But for now don't worry about it for each.
So I don't want to get into details of that
right now.
Oh my God, please don't add stuff.
I thought this was blocked.
Okay, if you add stuff, it makes it really hard
to go through this.
, who do I ask about scheduling clashes?
, they would look back to the announcement on learn
or the email you got about tutorials as an email
there.
Is this okay?
Double n array?
No, we already looked at that.
That's not okay.
Please can you explain re explain how for loop we'll
be looking at more examples of that today.
Other than weekly quiz and lab exercises what do I
have to do this week?
The answer is not really anything, except I would recommend
starting to have a look at the assignment practice tests.
, that's that.
They haven't been released then.
, and tutorials.
Not this week.
So you don't have to do that, but you do
have to do it next week.
Does the intelligent intro course follow along this course?
It doesn't follow along.
It's not designed in conjunction with it.
It will cover a lot of the same stuff.
I don't know the intelligent intro IntelliJ intro course in
detail.
I imagine it's quite useful.
So do look at that if you want to.
When do we start working on proper object oriented projects?
So we do do object object orientation in this course.
This is a course about object orientation.
But there is quite a lot of groundwork before we
can get on to even to really talking about objects,
which we'll do quite soon.
But then what really what object orientation means and how
you design with that in mind is something we get
onto later on in the course, because we have a
lot of people in this course who don't have experience
with programming.
So we have to cover quite a lot of the
basics, which aren't really anything to do with object orientation.
And when we've got those in place, we'll move on.
, have you read Clean Code by Robert C Martin?
I have not, but that sounds really good.
So maybe you guys should look at that.
You could have used break statements instead of nesting ifs.
Yes you could.
And so I think I mentioned that in the course
we looked at breaking and then we looked at nested
ifs.
Usually, nesting ifs are considered better practice.
Breaking is quite easy to make it break at the
wrong time to do the wrong thing, and it's also
much more difficult to read.
So sometimes breaking is really useful.
But.
And we could have done it then.
But nesting ifs is another way of doing it and
often better.
Dot length is a method.
Functional programming is better.
That is a that's a matter of opinion function.
Functional programming is definitely not nearly as common, so you're
unlikely to use functional programming very much.
In industry, for example, you will use object oriented a
lot, whether that's Java or something else.
Whether or not it's better is something that people could
argue about for for weeks and months.
I don't have a strong opinion about that.
Does the if need to be nested inside the alpha
alpha?
Could you just use Elsif?
Okay, so let's quickly look at where were we doing
that.
That was in I think that was still in hello
world wasn't it.
Okay.
So we've got the if here if statement in brackets,
then this is what you do.
Else so each if statement can only have one else.
Well actually.
Yeah.
So else.
Else statements don't have conditionals right.
So if you have lots of conditionals.
You nest it in this way.
I don't think you can do that differently.
Why do arrays always start from zero?
Had a helpful comment to explain that which is more
efficient initially?
Initialising I at the beginning or inside the for loop?
I don't think that really matters.
, so when you're doing a for loop, you're always
yeah, you need to initialise a counter inside.
, that's part of the the structure of a for
loop.
I don't think it makes much difference to efficiency in
general.
Whereabouts you initialise things as long as you do it
before you use them.
Is it nesting if statements a bad practice?
, this comes back to something we talk about a
lot, and I've already mentioned readability and maintainability of code.
Yes.
If you have 15 nested ifs all in one, that's
going to make it really hard to read.
Which in turn makes it hard to maintain.
And you have loads of brackets all over the place,
which makes it hard to maintain.
So you want to keep the structure fairly simple.
And that's something we'll be talking about in this lecture.
Nested ifs are not bad practice in general.
Often they're the best thing to do.
But if you're getting really, really deep and complex, probably
that's not a good idea and you're going to need
to think about a different way.
You might be able to structure something so that it
doesn't get that that depth and complexity.
So, so a really high complexity in the structure of
code is something that you want to avoid because it
makes it difficult to maintain and difficult to understand.
Okay.
Right.
So that's all the questions from last lecture.
So this lecture will have a slide again.
And you can add anything new.
All right.
Part of the lecture this is Mika.
She is a three year old former stray.
And I'm sure she's very happy to be living in
her loving home now.
And we've got two this week, this lecture.
This is Jack, who looks very cute.
I love the bow tie so I've got loads of
pet pictures.
I'm definitely going to do two Electra.
I might have two up to three.
So thanks for sending and do keep them coming.
I can put more in.
All right, live design I'm going to quickly move on
to the biscuits question whilst I go back to this.
This is just a placeholder to remind me.
, my office hour on Monday was great.
I had loads of people coming along.
I totally ran out of biscuits.
, so that was really good.
So please do come along on Monday just to say
hello, just to just to have a chat.
And obviously also if you have questions so you can
vote for biscuits this time I've restricted your choice so
we don't get crazy things coming in.
I think word clouds are dodgy.
So you just got a choice of five this time.
But I might I might change that.
I mean I will change that week by week.
Okay.
So what I want to mention quickly now I'm going
to talk about this more on Monday.
, we've, we're trialling this new thing in from B.
So this is not object oriented programming but it is
part of your core learning in year one.
, and it's the stuff we're doing around life design.
So this is coming out of a program they run
in Stanford.
, so it was originally designed by two product designers
in Silicon Valley, Bill Burnett and Dave Evans, both of
whom have done really seminal things.
I think one of them did something really seminal to
do with how mouse touchpads are used and stuff there.
They've done really seminal design, and then they both went
to work at Stanford, and they were thinking about how
students respond to their courses and thinking about how this
tech, this these approaches they use in product design is
actually really helpful for students to think about their university
experience.
So and this was this is now taught at Stanford,
I think to everyone.
But it was particularly originated in computer science for computer
science students.
So it's a bit more of an abstract way for
you guys to look at your learning and, and more
broadly, your experiences at university and what we're going to
do in week four and week eight.
On the Monday we're going to run, these sessions are
going to be two hour sessions.
You're going to get free lunch provided we've sorted out
how it interacts with your math courses.
So it should all be fine.
But we'll talk about this more.
Another that's probably maybe next week.
But what I want to do right now is that
we want a few people to help us run this.
So we're looking for a few volunteers who will be
will be helping us out with the organisation.
, and if you do this, we'll be super grateful.
And I think it'll be really great learning experience to
to look at how you facilitate this also.
We'll have some cool free stuff that we can give
out to people who are helping us.
, I mean, actually, I don't know how cool it
is.
I don't know what we've got, but I'll find some
good stuff for you.
, so you need to be able to come along
about 20 minutes early to the lecture, and there's a
sign up.
If you use that QR code, you can sign up
to volunteer as a facilitator.
We'd be really, really grateful if people are interested in
doing this.
So please do consider doing that.
, I'll send out an email about that later on
if I don't already have enough people signed up.
, fine.
Oh, wow.
Rich tea.
This makes me so happy.
Rich tea is actually my favourite biscuit, but most people
think it's incredibly boring.
But it seems to be the clear favourite.
Okay, so we'll have Jammie Dodgers seven people.
Really?
That's madness.
, five for biscotti.
Anyway, Richie is the clear winner.
We'll have Richie on Monday, but we'll maybe have some
of these others in weeks to come.
, okay.
So now let's get back to some actual Java.
Okay, so last lecture, we were just getting on to
the, , looking at arrays through the example of a
pack of cards, which we can actually do on IntelliJ,
because I had forgotten I had updated it and I
had the updated version and not the original version that
I want to show you how to update.
Okay.
So the idea here is that we have two arrays.
One, they're both arrays of strings.
One is called rank and that is every value you
can get for cards.
So that's two up to ace.
And the other is an array of the suits
which is clubs diamonds hearts and spades.
Okay.
And we want to use these two arrays to populate,
, or to print out every possible value.
, or that you can get in a pack of
cards.
Well, actually no, that's not what we're doing right now.
What we're doing now is, , just picking a random
card.
So this is , pick a card, any card.
So we get Math.random to pick a random number.
So when Math.random always returns a number between 0 and
1.
So if we multiply that by 13, we'll get a
number between one.
Well we get it.
We'll get a double that's somewhere between zero and
and 13.
And then we cast that to an integer.
And that will therefore give us an integer between 1
and 13, one and 12.
, sorry.
Zero and 12.
, and that will therefore , and if we look
at whatever's in that rank, it will be randomly one
of these.
And then again we multiply by four.
That will randomly help us pick one of the clubs,
one of the suits.
And then if we print it out every time, it
will come up with something different depending on what random
numbers are generated.
, okay.
So now let's look at IntelliJ.
, I don't want Hello World anymore.
What I want is cards.
Okay.
So what we're doing here, we've got this nested for
loop.
Okay.
So we're going.
First of all we've got a counter called I that's
going through number 0 to 13 stopping before it gets
to 13.
And then within that it's going through another iterator J
which is going through four.
And then every time we are populating this new array
called deck which we defined up here, , and we're
giving it a rank and a suit.
So it's going to, it's going to say , so
if I is five and J is spades is going
to be the five of spades.
Okay.
So first of all have a think about this.
Is it is it going to print out things
this.
Is it going to be output one or is it
going to be output two i.e. is it going to
go through everything of the same number, going through the
different suits and then move on to the next number,
or is it going to go stick with a suit
and go through each number in there.
So I'm just going to give you just a minute
to have a look at that and see if you
can think what's going to happen there.
Okay.
So who thinks it's going to be output one.
I fix the number and go through the suits.
Okay.
And who thinks it's going to be output two.
Okay.
Quite mixed.
So let's run and see okay.
So it's going to be output one.
It fixes the number and then it goes through the
suits.
Now why does it happen this.
Because this is the outer loop.
Right.
So first of all, we're we're we're choosing a rank.
So we'll start off with rank two which is in
position zero.
Not it's not rank two.
So the the value of the card is two.
And then with this fix with them within this four
loop we're going to go through every suit.
And only when we've gone through the suit and we've
populated the deck with that suit, and we're going to
come out of this inner for loop and go back
to this for loop, where we'll iterate and go on
to the three.
So that's why it's happening that way.
Okay.
So what do I want to show you about this.
Okay.
So this is stuff I mean this is actually not
directly to do with arrays, but this is important stuff
you need to know in coding.
So you can see it.
Very often when we have arrays we might want to
move stuff around.
So we had an array of buildings last time.
We might want to change the buildings around.
We might want to change the names when they change,
when they change the David Hume out of 40, George
Square or whatever, we might want to change that.
But in a suit of cards, sorry, a pack of
cards.
We don't want to change things.
These have been set forever.
So we want to just nobody.
We don't ever want anybody to mess around with what's
actually there.
So we can use the key word final.
Oops.
Okay.
Okay.
And what this means is that you cannot change what's
in this array.
This array is fixed.
Those values will always be the values in that array.
Okay.
, and the convention is when you, when you have
something that's final, you give its name.
Its name is in uppercase.
Okay.
So this is saying this.
These are the ranks.
These will always be the ranks.
And nobody will ever be able to change them.
Now you see here that this now is in red.
And what it's saying is that it doesn't it can't
resolve the symbol rank.
This is because Java is case sensitive.
So it will not connect this rank to that rank.
You've got to have the cases matching.
So I can just change those and that.
So it doesn't make any difference to how it runs.
It just makes a difference to what might happen in
the future.
.
Okay.
So also we have this number 52, right?
What is the significance of number 52?
Well, because we've been talking about cards, it's probably fairly
obvious to you what that what the significance of that
number is.
It's it's how many cards you have in a deck
of cards in a deck of cards, but that's not
explained anywhere.
And if you come back to this at another time
and you're looking at this one, you haven't been thinking
about cards, you can be , well, here's this number.
What does that mean?
This is what we call magic numbers.
These are numbers that float about.
And they're they're, , they're meaning might be obvious to
you when you're coding, but it's not necessarily immediately obvious
to anyone who's reading it.
So you want to get rid of magic numbers.
You want to explain what these numbers are instead.
So what we're going to do here is we're going
to we're going to have an integer and we're going
to call it card.
And this integer is going to be rank times length.
Sorry.
The length of rank Multiplied by the length of suit.
Okay.
And actually this is going to be final.
So so card this is the number of cards.
And this is 52 right.
What we're doing here is exactly what we did in
our heads here multiplying the rank by the suit.
So we get 52.
But it's explaining where that number comes from.
And this we also want to make final.
There's always 52 cards in a pack of cards.
So we've made that uppercase.
And instead of saying 52 here we'll say card okay.
So again this is just tidying it up so that
you know you can always figure out what's going on
with card.
This is about good practice.
All right.
So those are just a couple of points I wanted
to point out.
And this is the explanation in the slides.
It's exactly what we've already gone through.
so don't so generally any number in there should
be replaced by some explanation of what it's doing.
Are you working it out so you can see.
Don't overdo it if you've got a zero.
You know, that's fine.
But generally you don't want to have numbers floating about,
, readability and maintainability.
, shuffling.
I think I'm going to leave this to you to
have a look at as an extra example, if you
, this is just doing more stuff with integers.
There's nothing especially different here.
, okay.
So we'll look briefly at two dimensional arrays.
Okay.
So that's , where you've got not just one kind
of data but multiple data.
So an example is students and grades.
So all students do multiple.
So what courses are students enrolled on.
There's loads and loads of courses and most students have
more than one course.
So you've got different dimensions of data.
and there's loads and there's loads and loads of
situations where you have it's table data essentially.
So in, in maths, do you think of this as
an abstract in Java this is a 2D array.
So here for example we have a double array
of doubles where we just have these values and.
Okay.
So in order to access it you would.
Exactly the same.
You use the square brackets to say what you're talking
about.
And the first thing you look at, the first number
you put in there is the row.
And the second is the column.
So if we use the short term with the.
With the two double brackets, if you're first of all
you give the row and then you give the column.
And as always of course things start at zero.
So what this is doing here is this is.
This is initiating a new array.
And you declare it in just the same way with
the code word new.
The kind of the thing that says what kind of.
Thing you've got in there, and then the length of
each of the arrays.
And they don't need to be square.
So these don't need to be the same here.
We've got this has got 1010 rows but only three
columns.
And then what this is going what this is doing
is going through and setting everything to 0.0.
Although we don't need to do that because it initialises
that anyway.
Okay.
Okay.
So each.
Okay.
So and here you've got the curly brackets notations again.
So we've got we're declaring something called P which is
a a double array of doubles.
And so we start off with the square bracket with
sorry with the curly braces.
, which shows that this is an array.
, as, as we've seen before.
And then every element where before, for example, in the
buildings, we had that as strings here it's another array.
So it's just the same notation.
Okay.
So what is P13.
I think we've got a question.
Woke up about that.
Yes.
Okay.
So what is P13.
Have a look at that and see if you if
you ask it to return P13.
What is it going to return.
I'll give you another few seconds to do that.
Okay.
We've got quite a good response.
So the most popular response is 0.32.
Okay.
So we're looking at row one which is the second
row down because the top row will be row zero.
And then so when we look at the row first
and then the column which is the fourth one because
the fourth one is at index three.
And that gives us 0.32.
Okay.
this is another example of matrix addition.
, so have a look at that.
It's really just the same thing going on here.
Matrix addition is I can't even remember how to do
matrix addition.
But this tells you you have to find what's in
each column, and then you're creating this new array by
adding things up.
So have a look at that.
Matrix multiplication.
The maths is slightly more complicated, but the idea with
the arrays is exactly the same.
Enhanced for loops.
We already looked at this.
Let's just look at another one, particularly because we were
asked about that.
But I think that's going to.
Are we going to have we'll have more examples of
this later.
Anyway.
Here we've got a for loop.
We're going through everything in the deck and we're printing
out whatever it is.
, but again, we're just doing the same thing for
every element.
So we don't need this complex thing.
We just need to say for every element in in
deck, do the same thing.
, so IntelliJ is going to do this for us
because it's nice and helpful.
So I look at the message this is a yellow
message.
It's happy to run this, but it's telling me this
is not great practice.
, and then it's telling me what I can do
to make it better if I can.
Actually.
There we go.
It's saying, do you want me to replace this with
the hearts for loop?
Yes I do, so here it's giving.
This doesn't matter what it's calling it.
It's saying there's something called S and deck.
It knows that this is going to be a string
because I've told it here.
her that deck is an array of strings, and you
just need to go through every element of deck and
print that element out.
That's what this for loop is saying.
Okay, so if that's still not clear, you'll get a
bit of practice at this in the labs.
And the tutorials should become clearer as you practice.
Okay, I think we've said this all.
I don't want to , label this.
Here's another example.
, we're just printing out the words.
Okay.
So, , things we looked at, we looked at arrays.
Rays are super, super common ways of storing data.
You're uses all the time.
And they don't have to be single arrays.
They can be, , multiple multi-dimensional.
, and if you have local contents that you don't
want to change, use the word final and use for
loops unless you've got a good reason not to.
All right.
So let's have a look at functions.
Functions or static methods.
I mean technically in Java.
Static methods is a better.
Is more correct.
But you will find that generally people just refer to
them as functions.
Functions and methods are the same thing.
It's just different terminology.
So why are they so helpful.
So first of all we're going to look at this
program.
Okay.
So I'm going to look at this in IntelliJ.
Here is somewhere.
Let's see.
This is called duplication.
This is actually not a very good name for this
duplication I should have given this something clearer.
But here we've got something that works out stuff around
pocket money.
So we've got names of kids.
We've got how much they get, pocket money per week
and how much they're trying to save.
So then it's looking at how many weeks it's going
to take them to save the amount that they want
to save.
Now you can see there's a lot of repetition here.
So I thought, this is quite long.
There's a lot of lines in here and it's quite
long, but there's also lots of repetition.
So I'm adding names together.
, so let's look at this first of all.
So instead of doing this just adding names together here,
this is kind of annoying because we're doing it in
two places.
What I can do.
All right I know it's uppercase is I can create
a method.
Right.
So instead of saying I'm going to do this by
adding these two, I'm going to create a method that
is called join names.
Okay.
So I'm going to get rid of that join names.
And I'm going to pass it in the names I
want it to join which is jock and MacInnes.
, and I don't need this anymore because I've got
a method.
So this is going to go off and do that
for me.
The stuff that I was doing above is now going
to be done in a separate method, and I can
put this in here as well, join names and then
put these names in.
Get rid of that.
Okay, so now you can see those already look a
little bit neater.
And I'm already using the same method to do to
two different things which is nice.
It's got this in red of course because I'm calling
a method, but it doesn't know what this method is.
And I can't call a method that doesn't exist.
So if I want to do this, I need to
first create my method before I can run this.
So it's quite common practice to put in methods that
don't exist that you know you want to create and
then create them afterwards, but obviously you can't run it
until you have created them.
Okay.
So I'm so methods they can go anywhere in a
class file as long as it's before they're called.
Right.
So they've got to be physically before they're called.
So main will go at the bottom generally because it's
calling things that you need to define elsewhere.
So I'm going to call a method called join names
and what?
What?
What is this?
What is the input going to be?
It's going to be first name and last name.
Okay, now, as with all everything in Java, I have
to tell it what type these things are going to
be.
So these are both going to be strings.
And with all methods I need to give it certain
information about it.
So I want this to be a public method and
it's going to be static.
We're going to look later on what that means.
Now what do I want to do.
What do I want this method to return.
Do I want it to turn anything?
Yeah, I want it to return a string.
Right.
That's kind of obvious because we're getting a name out
of it.
But we can also see here we are assigning it
to something that's a string.
So what we're saying is call this name, this is
going to return something.
And that's something is going to be a string.
So this has got to be a string.
So I'm saying here this is going to return a
string.
Now I'm going to use the word return.
So every method that's not void has to have the
keyword return.
That's telling you telling the method what it should return.
That's only not the case if it isn't returning anything
a void method.
What do I want it to return?
Just first name plus last name.
And as we saw last week, this is doing the
job of string concatenation.
So it's just shoving those together.
So if I run that.
That should work.
Although you can see that I don't have a gap.
Those are run straight together because I'm concatenating straight together.
Actually I probably would want a space with that.
So let's put in a space and run that.
Okay.
And then that's got a space.
Okay.
And there's other things we can do.
So there's weeks to save.
You can see there's some duplication coming in here as
well.
So I can just quickly do that.
to oops.
To say ten.
And to.
Ten.
Get rid of that.
And I'm going to make a method here, which is
also going to be public and static.
And this is going to return an integer weeks to
save int.
What is this pocket money.
And an integer which is target.
And what's this function going to look .
What am I actually trying to do here.
We can see here I just want to divide them.
So I'm just going to return target.
Divided by pocket money okay.
And if I haven't messed that up that should work
okay.
So you can see this is already looking much easier
to read.
I need to do this again at the bottom so
that I'm using the method again here.
So I'm separating these out.
It's just much clearer and easier.
All right.
Oops.
So this is talking through everything we've just discussed.
If you'd to see it written down.
Have a look at that.
So why do I want to do this?
I'm breaking down a complex task into simpler steps.
I'm hiding the implementation details from anybody who calls it,
which is actually really useful.
So it's useful to me, perhaps as someone using this
to say, oh, right, is his his.
They're going to join the names I and some others
doings join names.
I don't care how you do during names.
I don't want to see all that code, all the
detail of how you do this.
How does maths generate random numbers?
I don't know, I don't really want to look at
those codes, that code.
I just need to know that that's what it's going
to do.
So very often you don't want to look at this
code of methods.
You just need to know the functionality.
So it's kind of a way of hiding the implementation
so that it's not, , not cluttering things up.
, okay.
This principle writing dry code.
Have I mentioned this before?
I'm going to bang on about this a lot.
Okay.
Dry is an acronym for Don't Repeat Yourself.
If you're if you're typing the same code in different
parts in different places.
That should be a function.
And instead of typing the same code in different places,
you should be calling that function okay.
Why should you do this?
Because it's easier to read and it's easier to maintain.
So here, for example, I might decide actually I want
middle name as well.
String middle name.
So I just need to go to this function.
And then I'm going to add that there.
Okay.
And now every call to that function I'm going to
have to change because that now takes a different number
of arguments.
, but I don't have to change the code how
I'm putting those together.
Or it might be I'm not even out in an
argument.
I might say, actually, it's better if they're the other
way around.
, I want to be last name and then first
name.
I can just do that here.
Okay.
And then this is going to happen in every place
I call.
This Is this going to happen to both Jane and
to John and to what's he called jock?
Whereas if I hadn't got this in a function, I'm
going to have to go through both of those and
change it twice, which when it's twice, not too bad.
But if it's multiple, it gets more and more complicated,
more and more easier to make a mistake.
So it just makes it much better code.
You can reuse code across multiple programs.
So it's not just something that's happening within a method.
It's something that I can call from elsewhere.
So it's just much better in all kinds of ways.
So how do you know when to put something into
a method and when not to?
So generally, if it's a subtask, a clear kind of
unit you should be putting elsewhere.
A good rule of thumb is that a method should
never be more than ten to.
Well, a method should generally not be more than 10
to 15 lines long.
So if you look to the coding I had to
begin with, that was more than 15 lines long, I
think.
So generally you look at that and you're , well,
probably the stuff that we can put up in a
method, this is not a hard rule.
There are some cases where you really do need a
method that's longer than this, but if it's more than
about ten lines, just begin to start thinking.
Actually, maybe I can put some of this into separate
functions and that's going to be better.
And certainly if you're writing things twice, if you're repeating
yourself, you shouldn't be repeating yourself.
You should be putting that in a method and calling
that method.
Okay.
So this is some examples of ways we might want
to change and how it's nice and useful to have
that in functions much easier to localise modifications.
Okay.
Now we're going to look at Euclidean distance between two
points.
Okay.
So maybe if you've done a lot of math recently
this is really familiar to you.
I haven't actually done Euclidean distance for a long time.
But this is basically you're trying to find a you're
given a point P, and you're trying to figure out
how close other points are to P.
So for example, you might be trying to find the
closest point to P.
And you've got this sort of vaguely complex equation to
tell you how to do that.
So here We've got that coded.
So we've got what's going on here.
Distance takes in four doubles which is the two points.
It works out the distance between the x values and
the distance between the y values.
And then and this does this equation.
okay.
So just to look at the anatomy of a Java
function because we've talked about these quite a lot.
So probably most of these are familiar to you now.
So public and static or whatever they may be.
These are called modifiers.
These are attached to classes and methods and tell you
things about about the class that we'll talk about later.
As we've seen the next one is called the return
type tells you what is going to be returned.
Then you have the method name, and then you have
the parameters which have both the parameters themselves, the names
of the parameters, and they have the type of the
parameters.
, and you might have local variables which you're giving
specific values within the class.
, And you always have a return statement unless your
method is void.
, this bit here where they're doing the working out
is called the function body.
And the whole thing is the declaration.
Okay, so that is the kind of language we're using.
If you're not quite clear about this, you should come
back to the slide and take a look.
But I will be using this quite frequently.
Okay.
So calling a function we've got literal arguments right here
D has got something.
This is grounded in something specific.
These are literals that have actual values.
Whereas D here is a variable.
We're defining it in terms of other arguments.
And these here these are literals.
But these could also be variables.
Okay.
So a variable is defined in terms of other things
a literal has an explicit value.
All right.
So now we're going to look at the structure control.
Okay.
So functions provide ways to control the flow of execution.
Okay.
So when you start off, when you first call a
function.
So when you when you begin, you always call.
When you run a class that always calls main.
That means the control of what's happening is in main.
It's in the function when when you call another function,
it passes control over to that function.
It'll go off.
Something will happen in that function, and then that function
will return something assuming it has a return value, or
just do whatever it's doing and not return anything if
it's void and that pass is controlled back to where
it happens, right?
If that's not clear, we're going to have a lot
of practice looking at what that really means when you're
doing it in practice.
, okay.
So in Java we use what we call pass by
value okay.
So that means parameter values are assigned the values given
by arguments to the call.
I'll give you examples of this later.
yeah I think it's better.
I think it's easier if I give you an example
later rather than randomly trying to find one now.
But the idea is that when I'm calling an argument,
I'm sorry, when I call a function, I tell it
what the arguments are.
Those pass in to the parameters of the function as
the arguments.
So I'm passing the values of the arguments around.
So the function itself only has access to the value
of its argument and not the arguments themselves.
Right.
So it only knows what's being passed into it.
We'll look at examples of what this means in a
minute okay.
So let's go to add one.
Oh sorry I was on silent okay.
So what's going on here.
Right.
So we start in the main method I'm instantiating an
integer to zero calling x.
And then I'm printing it out.
But I've also got this add one method right.
And what this does is it takes a value
and num plus plus we looked at this with iterators.
This means add one to it okay.
So this is called add one.
So if I, if I run this what does it
return.
Well it just returns zero because I'm not actually using
this.
But let's uncomment this.
So now this is actually passing control up to this
method here.
so what is it going to do.
So have a little think what is this going to
do.
I'm passing at zero.
I'm doing this one and then I'm printing out zero.
Do I have a minty for this?
No.
Okay.
, so what is what is actually going to do?
Let's have a look.
Okay.
It's going to return zero.
Right.
So what's going on there.
Right.
I call this add one function.
This add one adds one to it.
But it didn't make any difference okay.
This is because variables are local within functions.
So I'm passing it zero and it's taking in an
argument.
And now within this locally this is called num num
is now assigned to zero I'm integrating in iterating it
I'm adding one.
NUM now has the value one.
But I'm not passing anything back right.
So this is void I'm not passing anything back.
So now this this is only.
So this is incremented by one but only locally.
I'm not doing anything with it.
So that's just completely forgotten.
I go back here and X hasn't changed.
Okay.
Because X is just within this this function here.
So if I want to pass changes back I have
to be passing the values.
So that means here I have got to collect this.
So I want to say x equals add one x.
So this is saying go and do add one and
then assign that whatever comes back assign that to x
and then print x out.
Now obviously it doesn't this because this is void.
It's not returning anything.
So I need to say what I want it to
return.
What is x.
X is an integer okay.
And I need the magic keyword return.
So let's run that.
There's another I don't know whether I should put this
computation in.
Maybe it's just confusing.
But if I run that okay.
This is also returning zero.
This is not anymore because of local variables.
This is because this is because of how iteration works.
And this is something that trips you up a lot.
You'll be practising this in tutorials because this is kind
of weird.
But basically iteration this what this shorthand means is do
whatever you're doing.
And after you've done it, add one.
This is why it's useful in four loops, because you
do whatever's happening in the for loop.
And then when everything's finished you add one and you
move on.
So basically what this says is return number.
And after you do that add one to number.
So number is now at one.
But what's returned was before that happened.
So what we actually need to do here is say
num.
We can just do that.
That should work right.
Oops.
Semicolon there.
Let me just check.
That works okay.
So this now works.
So I'm saying first of all increment num and then
return it.
So now it's it's passing x.
It's passing whatever the value of x is which is
zero back here is adding one to it.
It's returning the new value.
And then that's assigning it to one and printing it
out okay.
So it's not it's so it's passing the local value
back to the original control.
And therefore it's still knows what's going on okay.
So this is a lot to do with what's actually
happening in memory.
So we'll get on to memory, , quite soon, a
couple of weeks.
, but basically it's all to do with the calling
code.
So we're passing this number over and number is local
here.
, so in memory X and number are completely unrelated.
We can see how they're related, but they're not related
in memory.
So anything we do to num is not being passed
on to X.
You actually have to write it.
Write it over to X, assign it to X.
to pass that information on.
, this is just more about the structure.
I actually should have put these before.
So here's the examples.
This is what we call a signature.
This is a name with the values of the arguments.
And the head of the definition has also got the
modifiers.
We've done all the return types.
Okay.
We've got five minutes.
I'm just going to have a look quickly at this.
yeah I think we've covered all of what this
is saying.
So the passed by value, , here this is being
passed over because we're actually assigning the value to something
that's in the main code.
So arrays of reference types.
Okay.
So actually no I don't want to get into this
now.
We'll have a look at this tomorrow.
So this is what happens with most things.
But arrays slightly complicate the issue.
Arrays do things a little bit differently.
and we'll go on to that , on Monday.
Okay.
So.
I'm going to put the ask me anything up.
, so just put questions in now.
I will answer them on Monday and , but if
anything comes up actually answers come in if it's useful.
Ah.
Okay.
Oh.
How is it possible to get an Informatics hoodie?
I actually have no idea, but I can find that
out.
By the way, I'm not sure what's happening with the
ceilidh tomorrow, because there's this red warning for wind, which
is quite serious, so they might.
If you've got tickets for ceilidh, just look out for
information about that.
I hope they can still run it, but it's quite
bad.
Read warnings so just watch out tomorrow it's going to
be really bad.
Okay, okay.
I'm going to answer these questions later.
I.
Know you don't have tutorials today.
Whoever asked that there are no tutorials on this week.
Tutorials start next week.
Oh yes.
No I can I found it Oh, you did okay.
There was an error with the calendar.
Okay, good.
That's good.
Do you know where I might find the PDF version
of the book other than the epub one?
No.